---
title: OS Develop 1
date: 2022-03-17 13:23:10
tags: OS
---

#### 简介
本章对操作系统开发，涉及的概念做讨论，深入讨论见后续。


### CPU工作方式
CPU大体分为3部分：控制单元、运算单元和存储单元。
{% asset_img cpu_workflow.png cpu workflow %}


### X86、X64、X86-64、IA-32和IA-64
- **X86**：这是一种指令集架构家族，最初由英特尔开发。它基于英特尔8086微处理器及其8088变体。8086于1978年推出，作为英特尔8位8080微处理器的完全16位扩展。

- **X64**：这是一个通用术语，指的是x86指令集的64位扩展。它最初由AMD使用，名为AMD64，后来由英特尔实施，名为Intel64。

- **X86-64**：这是x64和AMD64的另一个名称，表示x86指令集的64位扩展。它支持比其前身可能的虚拟内存和物理内存的大量增加，使程序能够在内存中存储更大量的数据。

- **IA-32**：这是x86指令集的一个版本，支持32位计算。它于1985年由英特尔引入，尽管基于30多年前的设计，但它仍然是今天销售的大多数台式机和笔记本电脑的基础。

- **IA-64**：这是一种64位指令集架构，由英特尔开发并于2001年引入，配备了用于企业和高性能计算的Itanium处理器。它与x86架构不向后兼容。


### x86寄存器简介
1，通用寄存器
通用寄存器可以有多种用途，可以同来保存任何数据；虽说通用，但还是约定了它们的惯用法，比如一般情况下，将cx寄存器用作循环的次数控制，bx用于存储起始地址，这是约定俗成的东西。
{% asset_img common_registor.png tools shwo %}

2，段寄存器
x86的段寄存器有6个----CS/DS/ES/SS/FS/GS，均为16位。
CS：存储代码段的段选择子，代码段保存正在执行的指令。处理器从代码段读取指令时，CS中的段选择子与EIP的值(要执行的下一条指令在代码段中的偏移量)组成逻辑地址。
DS：数据段寄存器。
SS：堆栈段寄存器。
ES，FS和GS：给操作系统用的，不用操作系统，用途不一样。

3，状态寄存器
16位模式下，标志寄存器名称为FLAG，寄存器大小16位。
32位模式下，标志寄存器的名称为EFLAG，寄存器大小32位。
64位模式下，为RFLAG，寄存器大小64位。

它的主要作用包括：
- 存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位
- 执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。
- 控制CPU的工作方式，例如IF、VM、TF等标志位。

状态寄存器的各位作用：
{% asset_img flag_registor.png flag registor %}


4，控制寄存器
控制寄存器决定处理器的操作模式当前执行任务的特性，比如实时模式和保护模式。
{% asset_img control_registor.jpeg flag registor %}


### 内存寻址方式
分为三大类：
- 寄存器寻址
- 立即数寻址
- 内存寻址

内存寻址用分为：
- 直接寻址
- 基址寻址
- 变址寻址
- 机址变址寻址


### 段寄存器和总线
数据总线，它的宽度决定数据交换速度。
控制总线，它的宽度决定可以控制的外设数量。
地址总线，它决定了内存寻址范围。

段寄存器产生是由于数据总线和地址总线宽度不一致；数据总线宽度，也就是ALU宽度，也是我们常说的16位和32位CPU（也是寄存器的宽度），比如32位的CPU地址总线可以是32位，也可以是36位。

早期，Intel决定让8086访问地址空间为1M，也就是地址总线为20位，但此时数据总线是16位，地址总线宽度大于数据总线，Intel想了一个办法，它加了4个16位的段寄存器(CS,DS,ES,SS)，它们存储的是地址总线高16位的段基址，原来的16地址就变成了段内的偏移量，这样就可以访问到1M内存了。


### MMIO和PMIO
- MMIO
内存映射方式（并不是映射到主板插的内存条上，是总线访问的内存地址）。

- PMIO
通过寄存器端口访问。

### 实时模式和保护模式
- 8086 具有 16 位的段寄存器、指令指针寄存器和通用寄存器（CS、SS、DS、ES、IP、AX、BX、CX、DX、SI、DI、BP、SP），因此，我们称它为 16 位的处理器。尽管它可以访问 1MB 的内存，但是只能分段进行，而且由于只能使用 16 位的段内偏移量，故段的长度最大只能是 64KB。8086 只有一种工作模式，即实模式；当然，这个名称是后来才提出来的。

- 80286 也是一款 16 位的处理器，大部分的寄存器都和 8086 处理器一样。因此，80286 和 8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段；尽管它有 24 根地址线，理论上可以访问 2^24，即 16MB 的内存,但依然只能分成多个段来进行。但是，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16 位保护模式很少为人所知的原因。

- 1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。和 8086/80286 不同，80386 处理器的寄存器是 32 位的，而且拥有 32 根地址线，可以访问 2^32，即 4GB 的内存。80386以及所有后续的 32 位处理器，都兼容实模式，可以运行实模式下的 8086 程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相当于一个非常快速的 8086 处理器。只有在进行一番设置之后，才能运行在保护模式下。在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。32 位保护模式兼容 80286 的 16 位保护模式。

### 实时模式内存布局
![](/images/real_time_mm.png)

### 虚拟地址空间
1，虚拟地址空间的大小是怎么决定的
X86_64体系结构的CPU工作在Long Mode（64位模式）时，虚拟地址的宽度是64位，但是当前的实现都不允许使用2^64字节（16EB）的整个地址空间。在可预见的未来，大多数操作系统和应用程序不需要这么大的地址空间，因此实现如此宽的虚拟地址只会增加地址转换的复杂性和成本，而没有真正的好处。因此，AMD决定在该体系结构的第一个实现中，实际只将虚拟地址的最低有效48位用于地址转换（页表查找）中。

2，小内存如何应对大虚拟地址空间
物理内存的大小和虚拟地址空间的大小是完全没关系的，虚拟地址空间虽大，但虚拟地址空间的虚拟地址主要用于页表转换，页表能顺利转换的前提是要完成页表填充，页表填充又发生在缺页异常处理中，缺页异常填充页表时首先要向伙伴系统申请内存，而伙伴系统分配的内存都是从物理内存中划分出来的，物理内存的大小决定了它能分配的page数。所以物理内存的大小和虚拟地址空间的大小是没有直接对应关系的。


### 全局描述符表（GDT）
它是由段描述符构成的表。
段描述符用来描述内存段的属性，它占连续的8个字节。
{% asset_img gdt.png gdt %}

- G-为0表示“段界限”的单位是字节，为1表示单位为4K。
- D/B-用来指定段内偏移地址和操作数的大小；对于代码段来说，此位是D，为0表示是16位，为1表示32为；对于栈段来说，此为使B，若为0则使用的是16位的sp寄存器，若为1则使用的32位的esp寄存器。
- L-为1表示64代码段，为0表示32位代码段。
- AVL-操作系统可以随意使用，没有具体功能。
- P-为1表示段存在于内存中（如内存不足时，置换到磁盘），0表示在内存中。
- DPL-Descriptor Privilege Level，用来表示段的特权级；分别是 0、1、2、3 级特权，数字越小，特权级越大。
- S和TYPE-S为0表示系统段，为1表示内存段，在S不同值下，用通过TYPE来区分具体的段类型。


### 选择子(selector)
在保护模式下，段寄存器中保存的不再是段基址了，里面保存的内容叫“选择子(selector)”；选择子就像数组下标一样用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组。


### A20
实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以16后再加上段内偏移地址。 实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”访问策略继续可用，CPU采取的做法是将超过1MB的部分自动回绕到0地址。超过1MB多余出来的内存被称为高端内存区HMA。对于只有20位地址线的CPU，不需要任何额外操作便能自动实现地址回绕。

CPU发展到了80286后，虽然地址总线从原来的20位发展到了24位，从而能够访问的内存范围可达到2的24次方，即16MB。但任何时候，Intel都会把兼容放在第一位。80286是第一款具有保护模式的CPU，它在实模式下时，其表现也应该和8086/8088一模一样。按照兼容的要求，80286及后续CPU的实模式应该与8086/8088完全一样，即仍然只使用其中的20条地址线。

在保护模式下，我们要使用80286的24条地址线，如果访问0x100000～0x10FFEF之间的内存，系统将直接访问这块物理内存，并不会像8086/8088那样回绕到 0。 IBM设计了A20Gate来控制是否20位回环。 

如果A20Gate被打开，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存。如果A20 Gate被禁止，当访问0x100000～0x10FFEF之间的地址时，CPU 将采用8086/8088的地址回绕。

### 开启保护模式
- 配置GDT
- 打开A20
- 将CR0的pe置为1


### 流水线
为了提高CPU执行效率，将每一步操作就绪划分成粒度更细的微的操作，然后将这些微操作放到多级流水线上同时去执行。


### 开启分页机制
- 准备好页目录表和页表
- 将页表地址写入控制寄存器cr3
- 寄存器cr0的PG位置1


### 为啥要多级分页
每当进程创建时，操作系统都会为进程分配页表，整个操作系统并非只有一个页表。
在32操作系统中，每个页为4K，每个页表项为4B，虚拟地址空间为4G（2的32次方），那么页表的大小就为4M，当进程创建时，如果单级页表的话，那就要将页表内容全部创建出来，那么每个进程都要4M的页表内存空间，那内存消耗时巨大的。如果是多级页表就可以按需分配。


### 操作系统和用户进程
用户进程必须运行在低特权级，当用户进程访问资源时，需要向操作系统申请，操作系统去操作，然后将结果返回给用户进程，进程可以有无限多个，而操作系统是所有用户进程共享的。可以把操作系统看作服务端，用户进程看作客户端。



