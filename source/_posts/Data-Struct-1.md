---
title: Data Struct 1
date: 2022-01-05 18:10:23
tags:    
    - IT-Basics
    - Algorithm
---

### 简介
数据结构讨论第一章，包括：数组，链表，栈，队列，哈希表。


### 数组(array)
数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。
{% asset_img struct_array.png struct array %}
优点：
- 空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。
- 支持随机访问：数组允许在 时间内访问任何元素。
- 缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。
局限：
- 插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。
- 长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。
- 空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。

### 链表(linked list)
常见的链表类型包括三种:
- 单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。
- 环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。
- 双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。
{% asset_img struct_link_list.png link list %}

### 栈(stack)
栈是一种遵循先入后出逻辑的线性数据结构。
{% asset_img struct_stack.png link list %}
操作：
push，元素入栈到栈顶，时间复杂度O(1)。
pop，栈顶元素出栈，时间复杂度O(1)。
peek，访问栈顶元素，时间复杂度O(1)。


### 队列(queue)
队列是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。
{% asset_img struct_queue.png queue list %}
操作：
push，元素入队，即将元素添加至队尾，时间复杂度O(1)。
pop，队首元素出队，时间复杂度O(1)。
peek，访问队首元素，时间复杂度O(1)。


### 双向队列(double-ended queue)
双向队列提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作;双向队列的实现与队列类似，可以选择链表或数组作为底层数据结构。
{% asset_img struct_double_queue.png queue list %}
操作：
push_first，将元素添加至队首，时间复杂度O(1)。
push_last，将元素添加至队尾，时间复杂度O(1)。
pop_first，删除队首元素，时间复杂度O(1)。
pop_last，删除队尾元素，时间复杂度O(1)。
peek_first，访问队首元素，时间复杂度O(1)。
peek_last，访问队尾元素，时间复杂度O(1)。


### 哈希表(hash table)
哈希表，又称散列表，它通过建立键key与值value之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键key，则可以在时间内获取对应的值value。
{% asset_img struct_hash_table.png hash table %}
1，实现
{% asset_img struct_hash_imp.png hash table implement %}
2，哈希冲突
常情况下哈希函数的输入空间远大于输出空间，因此理论上哈希冲突是不可避免的。我们通过下面两个策略来解决冲突：
- 改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。
- 仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。

哈希表的结构改良方法主要包括“链式地址法”和“开放寻址法”。

3，链式地址(separate chaining)法
在原始哈希表中，每个桶仅能存储一个键值对。「链式地址 separate chaining」将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。
{% asset_img hash_table_link_addr.png hash table implement %}
查询元素，输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比key以查找目标键值对。
添加元素，首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。
删除元素，根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。
局限：
占用空间增大，链表包含节点指针，它相比数组更加耗费内存空间。
查询效率降低，因为需要线性遍历链表来查找对应元素。

当链表很长时，查询效率很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至。


4，开发寻址(open addressing)法
开放寻址不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。








