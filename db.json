{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/hingle/source/static/hingle.css","path":"static/hingle.css","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/hingle.js","path":"static/hingle.js","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/kico.css","path":"static/kico.css","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/kico.js","path":"static/kico.js","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/img/icon.png","path":"static/img/icon.png","modified":0,"renderable":1},{"_id":"source/images/real_time_mm.png","path":"images/real_time_mm.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"1c2796c37847ce2895a6587efabfc9b345db7fd8","modified":1710222052478},{"_id":"source/_posts/.DS_Store","hash":"1474bdb43eb808a94bfc142dc9bb2e021f8db254","modified":1710222052460},{"_id":"source/_posts/Algorithm-1.md","hash":"9fba8460e9980204ee2117f4242bf94798a5de58","modified":1710308685116},{"_id":"source/_posts/Algorithm-2.md","hash":"2555f4632475d52a9491a6954a285245ec390ba9","modified":1710234860202},{"_id":"source/_posts/Algorithm-4.md","hash":"ec1fdcb2d99c671e9ed6b1f12cadf932ebbda4bd","modified":1710235162553},{"_id":"source/_posts/Algorithm-3.md","hash":"7838d48209be7023cafc3a6e5fc48536430110e0","modified":1710246881841},{"_id":"source/_posts/Backend-Node.md","hash":"3197ee400a2a830210ab584cf642c336b882b2a9","modified":1710228368950},{"_id":"source/_posts/Data-Struct-1.md","hash":"d292c010a601b31f66a85cde3f758fc15dfbcce5","modified":1710235328185},{"_id":"source/_posts/Blockchain-wallet.md","hash":"053fc76b8763b0834b4531cd6f925553afc928d7","modified":1710230250607},{"_id":"source/_posts/Data-Struct-2.md","hash":"3366ef8efb0e1bc6203db68143ed9ebc6fe12344","modified":1710235252477},{"_id":"source/_posts/My-Desktop-tools.md","hash":"84d24c44ce7dfe0a4601e8f76c63d5feea27a7f2","modified":1710230519984},{"_id":"source/_posts/Markdown-Tutorial.md","hash":"122324cc345247c074637151e3fd0e5290b43a28","modified":1710211729491},{"_id":"source/_posts/OS-Develop-1.md","hash":"6dedd932e0899f040646c884f90e49f0d29b6107","modified":1710227929069},{"_id":"source/_posts/OS-Develop-2.md","hash":"9be358bdb791b484859aacef6224fe419fca84ad","modified":1710225925444},{"_id":"source/_posts/OS-Develop-3.md","hash":"559c84117d99e36ea7292f6e7088fb6677334da8","modified":1710227137800},{"_id":"source/_posts/OS-Develop-1/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1710141277323},{"_id":"source/_posts/OS-Develop-1/common_registor.png","hash":"f0622451de775f6ac80766b42c382f6deac44b63","modified":1710144008358},{"_id":"source/_posts/OS-Develop-1/control_registor.jpeg","hash":"679f23e35e852dc2aff262ca407971f4cacb6e45","modified":1710145509524},{"_id":"source/_posts/My-Desktop-tools/adb_tool.png","hash":"47966a9a4183226ff7fc5f1b9f6861617db0fa2b","modified":1710121327924},{"_id":"source/_posts/OS-Develop-1/gdt.png","hash":"487d6c2a4aac59c7b6b3b2d53ad21ad9d71f6c55","modified":1710145973377},{"_id":"source/_posts/Algorithm-1/radix_sort.gif","hash":"c1fb6b874f066ec2cf7fcd565051ec9d61896a79","modified":1710307152678},{"_id":"source/_posts/OS-Develop-1/cpu_workflow.png","hash":"24ba6e7afdca32c8bcaf0ac6f987f779751ecad8","modified":1710141328342},{"_id":"source/_posts/OS-Develop-1/flag_registor.png","hash":"d8654ce9ac80a2801385908660c1f5f923d7b137","modified":1710145186470},{"_id":"themes/hingle/.DS_Store","hash":"a6bf40617c61c88a7030c60cb36aafb7ac4e92b8","modified":1710222052478},{"_id":"themes/hingle/.gitignore","hash":"1e51bee1ec3527ff3e2d6818a5367b5d81c69038","modified":1707492820000},{"_id":"themes/hingle/LICENSE","hash":"4de1840f7346984f481500155ab438f0fdd12634","modified":1707492820000},{"_id":"themes/hingle/README.md","hash":"71d1762328de3b6eb7c0536c2d414e8221be0742","modified":1707492820000},{"_id":"themes/hingle/_config.example.yml","hash":"fc83bfd27d3ae19e908c04ea696583179e7cc25f","modified":1707492820000},{"_id":"themes/hingle/_config.yml","hash":"3b63495f728c434ecbae2c3d61d5d7852472e6d3","modified":1710148793737},{"_id":"themes/hingle/layout/archive.ejs","hash":"90eff02318b17c6eff80021d9a32c2a680415d29","modified":1707492820000},{"_id":"themes/hingle/layout/index.ejs","hash":"9bcb0ddbe47e19149c6b50b0dc669955d7804caa","modified":1707492820000},{"_id":"themes/hingle/layout/layout.ejs","hash":"6b51c9598139016d4a451cd32ca9076c3a9089d7","modified":1707492820000},{"_id":"themes/hingle/layout/page.ejs","hash":"c0cb64ef3215a041c077d91adc911b2f8380c6c1","modified":1707492820000},{"_id":"themes/hingle/layout/post.ejs","hash":"69cae3890cb41aef16b4bb80ac1b135afa6ca9e8","modified":1707492820000},{"_id":"themes/hingle/layout/_partial/archive-list.ejs","hash":"d0ff1db7c10c68230f4ee8f7052bf68aa1301f13","modified":1707492820000},{"_id":"themes/hingle/layout/_partial/footer.ejs","hash":"87fdf554945711875f547e6c086f055fcae1df72","modified":1710123306646},{"_id":"themes/hingle/layout/_partial/head.ejs","hash":"3e83286f7fdb7c321e17147b11f9cb04dc4f68f9","modified":1707492820000},{"_id":"themes/hingle/layout/_partial/header.ejs","hash":"2f13227159607016a577345c974c80fe397666e5","modified":1707492820000},{"_id":"themes/hingle/layout/_partial/social.ejs","hash":"482bf0adfb597d2a3f54a28adde9c9f7c4a93300","modified":1707492820000},{"_id":"themes/hingle/source/static/hingle.js","hash":"cb7c49db65b063d89bca03eee3e2e79af2ada0c1","modified":1707492820000},{"_id":"themes/hingle/source/static/kico.css","hash":"5cfb69fc5cb76f93d39a95ee571160262388659f","modified":1707492820000},{"_id":"themes/hingle/source/static/hingle.css","hash":"40faa7ef23ecd7e248bc16d1e73cdcb573ee03dc","modified":1707492820000},{"_id":"themes/hingle/source/static/kico.js","hash":"353d3ece9b5020bdac573c35fece1455e72b40ee","modified":1707492820000},{"_id":"themes/hingle/source/static/img/icon.png","hash":"2f02d8ad49d7efee4b49fa6287297dd53a112440","modified":1707492820000},{"_id":"source/_posts/Algorithm-1/count_sort.gif","hash":"f51b9cc8cf02c104e695753f50229c6d2ba4ab91","modified":1710307030930},{"_id":"source/_posts/Algorithm-1/sort_algorithm.png","hash":"cc78f5b8180a654e4ca3c1ee37938990f204579e","modified":1710248470446},{"_id":"source/_posts/OS-Develop-2/jmp_condition.png","hash":"64ca85a6fad8acbf29426e35871f4bfb3118336e","modified":1710224930246},{"_id":"source/_posts/Algorithm-1/merge_sort.gif","hash":"5f153792344405f72f8f04d1f62c61c54b09c58e","modified":1710306757962},{"_id":"source/_posts/Algorithm-1/quick_sort.gif","hash":"59872dea97baee80e4333917f80c48627f888ed2","modified":1710306825515},{"_id":"source/_posts/Algorithm-1/insertion_sort.gif","hash":"ca62c4dc80eac486ff5ab2807f76e825228b6951","modified":1710305018200},{"_id":"source/_posts/Algorithm-1/bubble_sort.gif","hash":"fd6590aecff7c33327ce82b348004d88d56c6a84","modified":1710248682364},{"_id":"source/images/real_time_mm.png","hash":"c28bb286a80699649eb67dbb24d422731792b2cb","modified":1710226645753},{"_id":"source/_posts/Algorithm-1/selection_sort.gif","hash":"a52157c0615c58066467795c4cd29b6b55a367dc","modified":1710306525866},{"_id":"source/_posts/Algorithm-1/shell_sort.gif","hash":"f48d889185d607a6c1337a674bd4045f40e675b5","modified":1710307786333},{"_id":"source/_posts/Algorithm-1/bucket_sort.gif","hash":"296368f251f92e52c985e19bbd710c82c7b046e0","modified":1710307439516},{"_id":"source/_posts/Algorithm-1/heap_sort.gif","hash":"ef85422ba616c31be79468551be2091f0fede721","modified":1710306909818},{"_id":"public/2022/04/05/Backend-Node/index.html","hash":"4a6ab4ba5772579c8c63ac1916c20feeb21ad3e0","modified":1710308955719},{"_id":"public/2022/03/28/OS-Develop-3/index.html","hash":"b0941ecc79ada80f1668f2f5979ba596f83716c2","modified":1710308955719},{"_id":"public/2022/03/22/OS-Develop-2/index.html","hash":"39a46d7920ed1ded6a719ddfe15274e2ccc6cab9","modified":1710308955719},{"_id":"public/2022/03/17/OS-Develop-1/index.html","hash":"0f05ef7e8960c0b448cc4d747b875c89255a92f1","modified":1710308955719},{"_id":"public/2022/03/11/My-Desktop-tools/index.html","hash":"309ad692752431cfe0d9426869cb7f44e465dcb2","modified":1710308955719},{"_id":"public/2022/02/03/Markdown-Tutorial/index.html","hash":"c6e7925a81d4be97bbec9d167d838fc9af814ec5","modified":1710308955719},{"_id":"public/2022/01/22/Algorithm-4/index.html","hash":"1010610c87553e02c6e2a07ca2447d898a0e3e7f","modified":1710308955719},{"_id":"public/2022/01/20/Algorithm-3/index.html","hash":"6347f1f70369c7ffcd81ff7453f81d3906268c8c","modified":1710308955719},{"_id":"public/2022/01/18/Algorithm-2/index.html","hash":"2fd5f4732b2425e43d5a2c80989e7af27ce8acd2","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/index.html","hash":"e7c019b62136e53c4421498655cd74199c275c66","modified":1710308955719},{"_id":"public/2022/01/08/Data-Struct-2/index.html","hash":"122b66f0d1bb1cf88c2d74c6708d8df55e014867","modified":1710308955719},{"_id":"public/2022/01/05/Data-Struct-1/index.html","hash":"584647a6283be9dc6b0162618dc2538986b4a575","modified":1710308955719},{"_id":"public/2019/07/18/Blockchain-wallet/index.html","hash":"7d83f78f1c0ace246fb834a1ed247d3df7c6d757","modified":1710308955719},{"_id":"public/archives/index.html","hash":"72818d3bcc93da846aa262c9e095dc0949a0377d","modified":1710308955719},{"_id":"public/archives/page/2/index.html","hash":"c4070f91874ada2960641757375089b00e23d26f","modified":1710308955719},{"_id":"public/archives/2019/index.html","hash":"6f31c5f27c6295370332d66c0276971b817e8a61","modified":1710308955719},{"_id":"public/archives/2019/07/index.html","hash":"0b80281352206ad97b9cdc18f422eae02947a525","modified":1710308955719},{"_id":"public/archives/2022/index.html","hash":"f7249c542e04fff50dfa0f3124e10d00e3c5a50e","modified":1710308955719},{"_id":"public/archives/2022/page/2/index.html","hash":"80372b59340402be7b6b3a932c24ad5824c48315","modified":1710308955719},{"_id":"public/archives/2022/01/index.html","hash":"dbfca0f3f86af8c4f464fe549326d95eae954112","modified":1710308955719},{"_id":"public/archives/2022/02/index.html","hash":"8177843b69d77a67693caa2791b1e984c8149fe9","modified":1710308955719},{"_id":"public/archives/2022/03/index.html","hash":"cd341c09ab992a9dd43c95326717fa2f1ff2fb80","modified":1710308955719},{"_id":"public/archives/2022/04/index.html","hash":"d1b07885dfb09cd36d06913b53af5f129ad6654a","modified":1710308955719},{"_id":"public/index.html","hash":"cec416fcaedb7fdd28a32e4a604ee94e75707d52","modified":1710308955719},{"_id":"public/page/2/index.html","hash":"25700be8d28b9f81d70361f575e1acab813385ed","modified":1710308955719},{"_id":"public/tags/IT-Basics/index.html","hash":"f3e91804681955548a328d3ed6a64f524186eeb9","modified":1710308955719},{"_id":"public/tags/Backend/index.html","hash":"c61e3fc5815fce0bf7935f610119a6f6c2f34f78","modified":1710308955719},{"_id":"public/tags/Blockchain/index.html","hash":"67bfbda821e33fd0647aa9ade531ae14e68d2e8d","modified":1710308955719},{"_id":"public/tags/Android/index.html","hash":"172ebd3239429645bca902ae081ed68e341414e4","modified":1710308955719},{"_id":"public/tags/Tool/index.html","hash":"aadd94876720ce7d36821488b83475722d07dbf7","modified":1710308955719},{"_id":"public/tags/OS/index.html","hash":"48ca851026cfddf68a23fbb4c240f50aa176726f","modified":1710308955719},{"_id":"public/static/img/icon.png","hash":"2f02d8ad49d7efee4b49fa6287297dd53a112440","modified":1710308955719},{"_id":"public/2022/03/17/OS-Develop-1/control_registor.jpeg","hash":"679f23e35e852dc2aff262ca407971f4cacb6e45","modified":1710308955719},{"_id":"public/2022/03/17/OS-Develop-1/common_registor.png","hash":"f0622451de775f6ac80766b42c382f6deac44b63","modified":1710308955719},{"_id":"public/static/hingle.css","hash":"40faa7ef23ecd7e248bc16d1e73cdcb573ee03dc","modified":1710308955719},{"_id":"public/static/hingle.js","hash":"cb7c49db65b063d89bca03eee3e2e79af2ada0c1","modified":1710308955719},{"_id":"public/static/kico.css","hash":"5cfb69fc5cb76f93d39a95ee571160262388659f","modified":1710308955719},{"_id":"public/static/kico.js","hash":"353d3ece9b5020bdac573c35fece1455e72b40ee","modified":1710308955719},{"_id":"public/2022/03/11/My-Desktop-tools/adb_tool.png","hash":"47966a9a4183226ff7fc5f1b9f6861617db0fa2b","modified":1710308955719},{"_id":"public/2022/03/17/OS-Develop-1/gdt.png","hash":"487d6c2a4aac59c7b6b3b2d53ad21ad9d71f6c55","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/radix_sort.gif","hash":"c1fb6b874f066ec2cf7fcd565051ec9d61896a79","modified":1710308955719},{"_id":"public/2022/03/17/OS-Develop-1/cpu_workflow.png","hash":"24ba6e7afdca32c8bcaf0ac6f987f779751ecad8","modified":1710308955719},{"_id":"public/2022/03/17/OS-Develop-1/flag_registor.png","hash":"d8654ce9ac80a2801385908660c1f5f923d7b137","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/count_sort.gif","hash":"f51b9cc8cf02c104e695753f50229c6d2ba4ab91","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/sort_algorithm.png","hash":"cc78f5b8180a654e4ca3c1ee37938990f204579e","modified":1710308955719},{"_id":"public/2022/03/22/OS-Develop-2/jmp_condition.png","hash":"64ca85a6fad8acbf29426e35871f4bfb3118336e","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/merge_sort.gif","hash":"5f153792344405f72f8f04d1f62c61c54b09c58e","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/quick_sort.gif","hash":"59872dea97baee80e4333917f80c48627f888ed2","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/insertion_sort.gif","hash":"ca62c4dc80eac486ff5ab2807f76e825228b6951","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/bubble_sort.gif","hash":"fd6590aecff7c33327ce82b348004d88d56c6a84","modified":1710308955719},{"_id":"public/images/real_time_mm.png","hash":"c28bb286a80699649eb67dbb24d422731792b2cb","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/selection_sort.gif","hash":"a52157c0615c58066467795c4cd29b6b55a367dc","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/shell_sort.gif","hash":"f48d889185d607a6c1337a674bd4045f40e675b5","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/bucket_sort.gif","hash":"296368f251f92e52c985e19bbd710c82c7b046e0","modified":1710308955719},{"_id":"public/2022/01/17/Algorithm-1/heap_sort.gif","hash":"ef85422ba616c31be79468551be2091f0fede721","modified":1710308955719}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Algorithm 1","date":"2022-01-17T11:22:54.000Z","_content":"\n### 简介\n算法第一章，讨论排序算法。\n{% asset_img sort_algorithm.png sort algorithm %}\n\n### 插入排序\n- 从第一个元素开始，该元素可以认为已经被排序；\n- 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n- 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n将新元素插入到该位置后；\n- 重复步骤2~5。\n{% asset_img insertion_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while (preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex + 1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex + 1] = current;\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n### 冒泡排序\n- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n- 针对所有的元素重复以上的步骤，除了最后一个；\n- 重复步骤1~3，直到排序完成。\n{% asset_img bubble_sort.gif bubble sort %}\n\n{% codeblock %}\n    function bubbleSort(arr) {\n        var len = arr.length;\n        for (var i = 0; i < len - 1; i++) {\n            for (var j = 0; j < len - 1 - i; j++) {\n                if (arr[j] > arr[j+1]) {        // 相邻元素两两对比\n                    var temp = arr[j+1];        // 元素交换\n                    arr[j+1] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n        return arr;\n    }\n{% endcodeblock %}\n\n### 选择排序\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n\n- 初始状态：无序区为R[1..n]，有序区为空；\n- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n- n-1趟结束，数组有序化了。\n{% asset_img selection_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     // 寻找最小的数\n                minIndex = j;                 // 将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n} \n{% endcodeblock %}\n\n### 希尔排序\n- 先选定一个整数gap，把待排序文件中所有元素分成gap组，即所有距离为gap的分在同一组内，并对每一组内的元素进行直接插入排序（本质是进行预排序，使数组更接近有序，目的是使最后一次直接插入排序提高效率）；\n- 取gap=gap/2或者gap=gap/3+1重复上述分组和排序的工作；\n- 当gap到达1时，数组是已经接近有序的，当gap=1，即以一个元素为一组，就相当于对整个数组进行直接插入排序了。\n{% asset_img shell_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction shellSort(arr) {\n    var len = arr.length;\n    for (var gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行\n        for (var i = gap; i < len; i++) {\n            var j = i;\n            var current = arr[i];\n            while (j - gap >= 0 && current < arr[j - gap]) {\n                 arr[j] = arr[j - gap];\n                 j = j - gap;\n            }\n            arr[j] = current;\n        }\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n### 归并排序\n- 把长度为n的输入序列分成两个长度为n/2的子序列；\n- 对这两个子序列分别采用归并排序；\n- 将两个排序好的子序列合并成一个最终的排序序列。\n{% asset_img merge_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction mergeSort(arr) {\n    var len = arr.length;\n    if (len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n \nfunction merge(left, right) {\n    var result = [];\n \n    while (left.length>0 && right.length>0) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n \n    while (left.length)\n        result.push(left.shift());\n \n    while (right.length)\n        result.push(right.shift());\n \n    return result;\n}\n{% endcodeblock %}\n\n### 快速排序\n- 从数列中挑出一个元素，称为 “基准”（pivot）；\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n{% asset_img quick_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction quickSort(arr, left, right) {\n    var len = arr.length,\n        partitionIndex,\n        left = typeof left != 'number' ? 0 : left,\n        right = typeof right != 'number' ? len - 1 : right;\n \n    if (left < right) {\n        partitionIndex = partition(arr, left, right);\n        quickSort(arr, left, partitionIndex-1);\n        quickSort(arr, partitionIndex+1, right);\n    }\n    return arr;\n}\n \nfunction partition(arr, left ,right) {     // 分区操作\n    var pivot = left,                      // 设定基准值（pivot）\n        index = pivot + 1;\n    for (var i = index; i <= right; i++) {\n        if (arr[i] < arr[pivot]) {\n            swap(arr, i, index);\n            index++;\n        }       \n    }\n    swap(arr, pivot, index - 1);\n    return index-1;\n}\n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n{% endcodeblock %}\n\n### 堆排序\n- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\n- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\n- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n{% asset_img heap_sort.gif bubble sort %}\n\n{% codeblock %}\nvar len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量\n \nfunction buildMaxHeap(arr) {   // 建立大顶堆\n    len = arr.length;\n    for (var i = Math.floor(len/2); i >= 0; i--) {\n        heapify(arr, i);\n    }\n}\n \nfunction heapify(arr, i) {     // 堆调整\n    var left = 2 * i + 1,\n        right = 2 * i + 2,\n        largest = i;\n \n    if (left < len && arr[left] > arr[largest]) {\n        largest = left;\n    }\n \n    if (right < len && arr[right] > arr[largest]) {\n        largest = right;\n    }\n \n    if (largest != i) {\n        swap(arr, i, largest);\n        heapify(arr, largest);\n    }\n}\n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n \nfunction heapSort(arr) {\n    buildMaxHeap(arr);\n \n    for (var i = arr.length - 1; i > 0; i--) {\n        swap(arr, 0, i);\n        len--;\n        heapify(arr, 0);\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n\n### 计数排序\n- 找出待排序的数组中最大和最小的元素；\n- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\n- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\n- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\n{% asset_img count_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction countingSort(arr, maxValue) {\n    var bucket = new Array(maxValue + 1),\n        sortedIndex = 0;\n        arrLen = arr.length,\n        bucketLen = maxValue + 1;\n \n    for (var i = 0; i < arrLen; i++) {\n        if (!bucket[arr[i]]) {\n            bucket[arr[i]] = 0;\n        }\n        bucket[arr[i]]++;\n    }\n \n    for (var j = 0; j < bucketLen; j++) {\n        while(bucket[j] > 0) {\n            arr[sortedIndex++] = j;\n            bucket[j]--;\n        }\n    }\n \n    return arr;\n}\n{% endcodeblock %}\n\n\n### 桶排序\n- 设置一个定量的数组当作空桶；\n- 遍历输入数据，并且把数据一个一个放到对应的桶里去；\n- 对每个不是空的桶进行排序；\n- 从不是空的桶里把排好序的数据拼接起来。\n{% asset_img bubble_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction bucketSort(arr, bucketSize) {\n    if (arr.length === 0) {\n      return arr;\n    }\n \n    var i;\n    var minValue = arr[0];\n    var maxValue = arr[0];\n    for (i = 1; i < arr.length; i++) {\n      if (arr[i] < minValue) {\n          minValue = arr[i];                // 输入数据的最小值\n      } else if (arr[i] > maxValue) {\n          maxValue = arr[i];                // 输入数据的最大值\n      }\n    }\n \n    // 桶的初始化\n    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5\n    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\n    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  \n    var buckets = new Array(bucketCount);\n    for (i = 0; i < buckets.length; i++) {\n        buckets[i] = [];\n    }\n \n    // 利用映射函数将数据分配到各个桶中\n    for (i = 0; i < arr.length; i++) {\n        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);\n    }\n \n    arr.length = 0;\n    for (i = 0; i < buckets.length; i++) {\n        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序\n        for (var j = 0; j < buckets[i].length; j++) {\n            arr.push(buckets[i][j]);                     \n        }\n    }\n \n    return arr;\n}\n{% endcodeblock %}\n\n\n### 基数排序\n- 取得数组中的最大数，并取得位数；\n- arr为原始数组，从最低位开始取每个位组成radix数组；\n- 对radix进行计数排序（利用计数排序适用于小范围数的特点）；\n{% asset_img radix_sort.gif bubble sort %}\n\n{% codeblock %}\nvar counter = [];\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]==null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Algorithm-1.md","raw":"---\ntitle: Algorithm 1\ndate: 2022-01-17 19:22:54\ntags: IT-Basics\n---\n\n### 简介\n算法第一章，讨论排序算法。\n{% asset_img sort_algorithm.png sort algorithm %}\n\n### 插入排序\n- 从第一个元素开始，该元素可以认为已经被排序；\n- 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n- 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n将新元素插入到该位置后；\n- 重复步骤2~5。\n{% asset_img insertion_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while (preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex + 1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex + 1] = current;\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n### 冒泡排序\n- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n- 针对所有的元素重复以上的步骤，除了最后一个；\n- 重复步骤1~3，直到排序完成。\n{% asset_img bubble_sort.gif bubble sort %}\n\n{% codeblock %}\n    function bubbleSort(arr) {\n        var len = arr.length;\n        for (var i = 0; i < len - 1; i++) {\n            for (var j = 0; j < len - 1 - i; j++) {\n                if (arr[j] > arr[j+1]) {        // 相邻元素两两对比\n                    var temp = arr[j+1];        // 元素交换\n                    arr[j+1] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n        return arr;\n    }\n{% endcodeblock %}\n\n### 选择排序\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n\n- 初始状态：无序区为R[1..n]，有序区为空；\n- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n- n-1趟结束，数组有序化了。\n{% asset_img selection_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     // 寻找最小的数\n                minIndex = j;                 // 将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n} \n{% endcodeblock %}\n\n### 希尔排序\n- 先选定一个整数gap，把待排序文件中所有元素分成gap组，即所有距离为gap的分在同一组内，并对每一组内的元素进行直接插入排序（本质是进行预排序，使数组更接近有序，目的是使最后一次直接插入排序提高效率）；\n- 取gap=gap/2或者gap=gap/3+1重复上述分组和排序的工作；\n- 当gap到达1时，数组是已经接近有序的，当gap=1，即以一个元素为一组，就相当于对整个数组进行直接插入排序了。\n{% asset_img shell_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction shellSort(arr) {\n    var len = arr.length;\n    for (var gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行\n        for (var i = gap; i < len; i++) {\n            var j = i;\n            var current = arr[i];\n            while (j - gap >= 0 && current < arr[j - gap]) {\n                 arr[j] = arr[j - gap];\n                 j = j - gap;\n            }\n            arr[j] = current;\n        }\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n### 归并排序\n- 把长度为n的输入序列分成两个长度为n/2的子序列；\n- 对这两个子序列分别采用归并排序；\n- 将两个排序好的子序列合并成一个最终的排序序列。\n{% asset_img merge_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction mergeSort(arr) {\n    var len = arr.length;\n    if (len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n \nfunction merge(left, right) {\n    var result = [];\n \n    while (left.length>0 && right.length>0) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n \n    while (left.length)\n        result.push(left.shift());\n \n    while (right.length)\n        result.push(right.shift());\n \n    return result;\n}\n{% endcodeblock %}\n\n### 快速排序\n- 从数列中挑出一个元素，称为 “基准”（pivot）；\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n{% asset_img quick_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction quickSort(arr, left, right) {\n    var len = arr.length,\n        partitionIndex,\n        left = typeof left != 'number' ? 0 : left,\n        right = typeof right != 'number' ? len - 1 : right;\n \n    if (left < right) {\n        partitionIndex = partition(arr, left, right);\n        quickSort(arr, left, partitionIndex-1);\n        quickSort(arr, partitionIndex+1, right);\n    }\n    return arr;\n}\n \nfunction partition(arr, left ,right) {     // 分区操作\n    var pivot = left,                      // 设定基准值（pivot）\n        index = pivot + 1;\n    for (var i = index; i <= right; i++) {\n        if (arr[i] < arr[pivot]) {\n            swap(arr, i, index);\n            index++;\n        }       \n    }\n    swap(arr, pivot, index - 1);\n    return index-1;\n}\n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n{% endcodeblock %}\n\n### 堆排序\n- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\n- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\n- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n{% asset_img heap_sort.gif bubble sort %}\n\n{% codeblock %}\nvar len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量\n \nfunction buildMaxHeap(arr) {   // 建立大顶堆\n    len = arr.length;\n    for (var i = Math.floor(len/2); i >= 0; i--) {\n        heapify(arr, i);\n    }\n}\n \nfunction heapify(arr, i) {     // 堆调整\n    var left = 2 * i + 1,\n        right = 2 * i + 2,\n        largest = i;\n \n    if (left < len && arr[left] > arr[largest]) {\n        largest = left;\n    }\n \n    if (right < len && arr[right] > arr[largest]) {\n        largest = right;\n    }\n \n    if (largest != i) {\n        swap(arr, i, largest);\n        heapify(arr, largest);\n    }\n}\n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n \nfunction heapSort(arr) {\n    buildMaxHeap(arr);\n \n    for (var i = arr.length - 1; i > 0; i--) {\n        swap(arr, 0, i);\n        len--;\n        heapify(arr, 0);\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n\n### 计数排序\n- 找出待排序的数组中最大和最小的元素；\n- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\n- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\n- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\n{% asset_img count_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction countingSort(arr, maxValue) {\n    var bucket = new Array(maxValue + 1),\n        sortedIndex = 0;\n        arrLen = arr.length,\n        bucketLen = maxValue + 1;\n \n    for (var i = 0; i < arrLen; i++) {\n        if (!bucket[arr[i]]) {\n            bucket[arr[i]] = 0;\n        }\n        bucket[arr[i]]++;\n    }\n \n    for (var j = 0; j < bucketLen; j++) {\n        while(bucket[j] > 0) {\n            arr[sortedIndex++] = j;\n            bucket[j]--;\n        }\n    }\n \n    return arr;\n}\n{% endcodeblock %}\n\n\n### 桶排序\n- 设置一个定量的数组当作空桶；\n- 遍历输入数据，并且把数据一个一个放到对应的桶里去；\n- 对每个不是空的桶进行排序；\n- 从不是空的桶里把排好序的数据拼接起来。\n{% asset_img bubble_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction bucketSort(arr, bucketSize) {\n    if (arr.length === 0) {\n      return arr;\n    }\n \n    var i;\n    var minValue = arr[0];\n    var maxValue = arr[0];\n    for (i = 1; i < arr.length; i++) {\n      if (arr[i] < minValue) {\n          minValue = arr[i];                // 输入数据的最小值\n      } else if (arr[i] > maxValue) {\n          maxValue = arr[i];                // 输入数据的最大值\n      }\n    }\n \n    // 桶的初始化\n    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5\n    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\n    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  \n    var buckets = new Array(bucketCount);\n    for (i = 0; i < buckets.length; i++) {\n        buckets[i] = [];\n    }\n \n    // 利用映射函数将数据分配到各个桶中\n    for (i = 0; i < arr.length; i++) {\n        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);\n    }\n \n    arr.length = 0;\n    for (i = 0; i < buckets.length; i++) {\n        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序\n        for (var j = 0; j < buckets[i].length; j++) {\n            arr.push(buckets[i][j]);                     \n        }\n    }\n \n    return arr;\n}\n{% endcodeblock %}\n\n\n### 基数排序\n- 取得数组中的最大数，并取得位数；\n- arr为原始数组，从最低位开始取每个位组成radix数组；\n- 对radix进行计数排序（利用计数排序适用于小范围数的特点）；\n{% asset_img radix_sort.gif bubble sort %}\n\n{% codeblock %}\nvar counter = [];\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]==null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Algorithm-1","published":1,"updated":"2024-03-13T05:44:45.116Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9k0000dk2d2xdpecd0","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第一章，讨论排序算法。</p>\n<img src=\"/2022/01/17/Algorithm-1/sort_algorithm.png\" class=\"\" title=\"sort algorithm\">\n\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；</li>\n<li>重复步骤2~5。<img src=\"/2022/01/17/Algorithm-1/insertion_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight nsis\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nsis\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">insertionSort</span>(arr) &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">len</span> = arr.length<span class=\"hljs-comment\">;</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">preIndex</span>, <span class=\"hljs-literal\">current</span><span class=\"hljs-comment\">;</span><br>    for (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> = <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">; i &lt; len; i++) &#123;</span><br>        preIndex = i - <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>        <span class=\"hljs-literal\">current</span> = arr[i]<span class=\"hljs-comment\">;</span><br>        while (preIndex &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[preIndex] &gt; <span class=\"hljs-literal\">current</span>) &#123;<br>            arr[preIndex + <span class=\"hljs-number\">1</span>] = arr[preIndex]<span class=\"hljs-comment\">;</span><br>            preIndex--<span class=\"hljs-comment\">;</span><br>        &#125;<br>        arr[preIndex + <span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">current</span><span class=\"hljs-comment\">;</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr<span class=\"hljs-comment\">;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。<img src=\"/2022/01/17/Algorithm-1/bubble_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bubbleSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; len - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; len - <span class=\"hljs-number\">1</span> - i; j++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"hljs-number\">1</span>]) &#123;        <span class=\"hljs-comment\">// 相邻元素两两对比</span><br>                <span class=\"hljs-keyword\">var</span> temp = arr[j+<span class=\"hljs-number\">1</span>];        <span class=\"hljs-comment\">// 元素交换</span><br>                arr[j+<span class=\"hljs-number\">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>\n<ul>\n<li>初始状态：无序区为R[1..n]，有序区为空；</li>\n<li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li>n-1趟结束，数组有序化了。<img src=\"/2022/01/17/Algorithm-1/selection_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">selectionSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">var</span> minIndex, temp;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; len - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        minIndex = i;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; len; j++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class=\"hljs-comment\">// 寻找最小的数</span><br>                minIndex = j;                 <span class=\"hljs-comment\">// 将最小数的索引保存</span><br>            &#125;<br>        &#125;<br>        temp = arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125; <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><ul>\n<li>先选定一个整数gap，把待排序文件中所有元素分成gap组，即所有距离为gap的分在同一组内，并对每一组内的元素进行直接插入排序（本质是进行预排序，使数组更接近有序，目的是使最后一次直接插入排序提高效率）；</li>\n<li>取gap&#x3D;gap&#x2F;2或者gap&#x3D;gap&#x2F;3+1重复上述分组和排序的工作；</li>\n<li>当gap到达1时，数组是已经接近有序的，当gap&#x3D;1，即以一个元素为一组，就相当于对整个数组进行直接插入排序了。<img src=\"/2022/01/17/Algorithm-1/shell_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">shellSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> gap = Math.<span class=\"hljs-built_in\">floor</span>(len / <span class=\"hljs-number\">2</span>); gap &gt; <span class=\"hljs-number\">0</span>; gap = Math.<span class=\"hljs-built_in\">floor</span>(gap / <span class=\"hljs-number\">2</span>)) &#123;<br>        <span class=\"hljs-comment\">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = gap; i &lt; len; i++) &#123;<br>            <span class=\"hljs-keyword\">var</span> j = i;<br>            <span class=\"hljs-keyword\">var</span> current = arr[i];<br>            <span class=\"hljs-keyword\">while</span> (j - gap &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;<br>                 arr[j] = arr[j - gap];<br>                 j = j - gap;<br>            &#125;<br>            arr[j] = current;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。<img src=\"/2022/01/17/Algorithm-1/merge_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mergeSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">if</span> (len &lt; <span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br>    <span class=\"hljs-keyword\">var</span> middle = Math.<span class=\"hljs-built_in\">floor</span>(len / <span class=\"hljs-number\">2</span>),<br>        <span class=\"hljs-built_in\">left</span> = arr.<span class=\"hljs-built_in\">slice</span>(<span class=\"hljs-number\">0</span>, middle),<br>        <span class=\"hljs-built_in\">right</span> = arr.<span class=\"hljs-built_in\">slice</span>(middle);<br>    <span class=\"hljs-keyword\">return</span> merge(mergeSort(<span class=\"hljs-built_in\">left</span>), mergeSort(<span class=\"hljs-built_in\">right</span>));<br>&#125;<br> <br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">left, right</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = [];<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">left</span>.<span class=\"hljs-built_in\">length</span>&gt;<span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-built_in\">right</span>.<span class=\"hljs-built_in\">length</span>&gt;<span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">left</span>[<span class=\"hljs-number\">0</span>] &lt;= <span class=\"hljs-built_in\">right</span>[<span class=\"hljs-number\">0</span>]) &#123;<br>            result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">left</span>.shift());<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">right</span>.shift());<br>        &#125;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">left</span>.<span class=\"hljs-built_in\">length</span>)<br>        result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">left</span>.shift());<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">right</span>.<span class=\"hljs-built_in\">length</span>)<br>        result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">right</span>.shift());<br> <br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ul>\n<img src=\"/2022/01/17/Algorithm-1/quick_sort.gif\" class=\"\" title=\"bubble sort\">\n\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">function quickSort(arr, <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">right</span>) &#123;<br>    <span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">len</span> = arr.length,<br>        partitionIndex,<br>        <span class=\"hljs-built_in\">left</span> = typeof <span class=\"hljs-built_in\">left</span> != &#x27;number&#x27; ? <span class=\"hljs-number\">0</span> <span class=\"hljs-symbol\">:</span> <span class=\"hljs-built_in\">left</span>,<br>        <span class=\"hljs-built_in\">right</span> = typeof <span class=\"hljs-built_in\">right</span> != &#x27;number&#x27; ? <span class=\"hljs-built_in\">len</span> - <span class=\"hljs-number\">1</span> <span class=\"hljs-symbol\">:</span> <span class=\"hljs-built_in\">right</span>;<br> <br>    <span class=\"hljs-built_in\">if</span> (<span class=\"hljs-built_in\">left</span> &lt; <span class=\"hljs-built_in\">right</span>) &#123;<br>        partitionIndex = partition(arr, <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">right</span>);<br>        quickSort(arr, <span class=\"hljs-built_in\">left</span>, partitionIndex-<span class=\"hljs-number\">1</span>);<br>        quickSort(arr, partitionIndex+<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">right</span>);<br>    &#125;<br>    return arr;<br>&#125;<br> <br>function partition(arr, <span class=\"hljs-built_in\">left</span> ,<span class=\"hljs-built_in\">right</span>) &#123;     // 分区操作<br>    <span class=\"hljs-built_in\">var</span> pivot = <span class=\"hljs-built_in\">left</span>,                      // 设定基准值（pivot）<br>        <span class=\"hljs-built_in\">index</span> = pivot + <span class=\"hljs-number\">1</span>;<br>    for (<span class=\"hljs-built_in\">var</span> i = <span class=\"hljs-built_in\">index</span>; i &lt;= <span class=\"hljs-built_in\">right</span>; i++) &#123;<br>        <span class=\"hljs-built_in\">if</span> (arr[i] &lt; arr[pivot]) &#123;<br>            swap(arr, i, <span class=\"hljs-built_in\">index</span>);<br>            <span class=\"hljs-built_in\">index</span>++;<br>        &#125;       <br>    &#125;<br>    swap(arr, pivot, <span class=\"hljs-built_in\">index</span> - <span class=\"hljs-number\">1</span>);<br>    return <span class=\"hljs-built_in\">index</span>-<span class=\"hljs-number\">1</span>;<br>&#125;<br> <br>function swap(arr, i, j) &#123;<br>    <span class=\"hljs-built_in\">var</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>\n<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<img src=\"/2022/01/17/Algorithm-1/heap_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight wren\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs wren\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">len</span>;    <span class=\"hljs-comment\">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">buildMaxHeap</span>(<span class=\"hljs-params\">arr</span>) &#123;   <span class=\"hljs-comment\">// 建立大顶堆</span><br>    <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>.<span class=\"hljs-property\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">floor</span>(<span class=\"hljs-variable\">len</span>/<span class=\"hljs-number\">2</span>); <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">i</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>) &#123;<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">i</span>);<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-params\">arr</span>, <span class=\"hljs-params\">i</span>) &#123;     <span class=\"hljs-comment\">// 堆调整</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span>,<br>        <span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">2</span>,<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">i</span>;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">&amp;&amp;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">left</span>] <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">largest</span>]) &#123;<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">left</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">&amp;&amp;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">right</span>] <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">largest</span>]) &#123;<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">right</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">!=</span> <span class=\"hljs-variable\">i</span>) &#123;<br>        <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">i</span>, <span class=\"hljs-variable\">largest</span>);<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">largest</span>);<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-params\">arr</span>, <span class=\"hljs-params\">i</span>, <span class=\"hljs-params\">j</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>];<br>    <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">j</span>];<br>    <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">j</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">temp</span>;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">heapSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-title function_\">buildMaxHeap</span>(<span class=\"hljs-variable\">arr</span>);<br> <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>.<span class=\"hljs-property\">length</span> <span class=\"hljs-operator\">-</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">i</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>) &#123;<br>        <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable\">i</span>);<br>        <span class=\"hljs-variable\">len</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>;<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-number\">0</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable\">arr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<img src=\"/2022/01/17/Algorithm-1/count_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">function countingSort(arr, maxValue) &#123;<br>    var <span class=\"hljs-keyword\">bucket </span>= new Array(maxValue + <span class=\"hljs-number\">1</span>),<br>        sortedIndex = <span class=\"hljs-number\">0</span>;<br>        arrLen = arr.length,<br>        <span class=\"hljs-keyword\">bucketLen </span>= maxValue + <span class=\"hljs-number\">1</span>;<br> <br>    for (var i = <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; i &lt; arrLen; i++) &#123;</span><br>        if (!<span class=\"hljs-keyword\">bucket[arr[i]]) </span>&#123;<br>            <span class=\"hljs-keyword\">bucket[arr[i]] </span>= <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">bucket[arr[i]]++;</span><br><span class=\"hljs-keyword\"></span>    &#125;<br> <br>    for (var <span class=\"hljs-keyword\">j </span>= <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; j &lt; bucketLen; j++) &#123;</span><br>        while(<span class=\"hljs-keyword\">bucket[j] </span>&gt; <span class=\"hljs-number\">0</span>) &#123;<br>            arr[sortedIndex++] = <span class=\"hljs-keyword\">j;</span><br><span class=\"hljs-keyword\"></span>            <span class=\"hljs-keyword\">bucket[j]--;</span><br><span class=\"hljs-keyword\"></span>        &#125;<br>    &#125;<br> <br>    return arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li>设置一个定量的数组当作空桶；</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>对每个不是空的桶进行排序；</li>\n<li>从不是空的桶里把排好序的数据拼接起来。<img src=\"/2022/01/17/Algorithm-1/bubble_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bucketSort</span>(<span class=\"hljs-params\">arr, bucketSize</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (arr.<span class=\"hljs-built_in\">length</span> === <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">var</span> i;<br>    <span class=\"hljs-keyword\">var</span> minValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">var</span> maxValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">1</span>; i &lt; arr.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; minValue) &#123;<br>          minValue = arr[i];                <span class=\"hljs-comment\">// 输入数据的最小值</span><br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[i] &gt; maxValue) &#123;<br>          maxValue = arr[i];                <span class=\"hljs-comment\">// 输入数据的最大值</span><br>      &#125;<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// 桶的初始化</span><br>    <span class=\"hljs-keyword\">var</span> DEFAULT_BUCKET_SIZE = <span class=\"hljs-number\">5</span>;            <span class=\"hljs-comment\">// 设置桶的默认数量为5</span><br>    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;<br>    <span class=\"hljs-keyword\">var</span> bucketCount = Math.<span class=\"hljs-built_in\">floor</span>((maxValue - minValue) / bucketSize) + <span class=\"hljs-number\">1</span>;  <br>    <span class=\"hljs-keyword\">var</span> buckets = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(bucketCount);<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; buckets.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        buckets[i] = [];<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// 利用映射函数将数据分配到各个桶中</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        buckets[Math.<span class=\"hljs-built_in\">floor</span>((arr[i] - minValue) / bucketSize)].<span class=\"hljs-built_in\">push</span>(arr[i]);<br>    &#125;<br> <br>    arr.<span class=\"hljs-built_in\">length</span> = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; buckets.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        insertionSort(buckets[i]);                      <span class=\"hljs-comment\">// 对每个桶进行排序，这里使用了插入排序</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; buckets[i].<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            arr.<span class=\"hljs-built_in\">push</span>(buckets[i][j]);                     <br>        &#125;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><ul>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>\n<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；<img src=\"/2022/01/17/Algorithm-1/radix_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">var</span> counter = [];<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">radixSort</span>(<span class=\"hljs-params\">arr, maxDigit</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> mod = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">var</span> dev = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; maxDigit; i++, dev *= <span class=\"hljs-number\">10</span>, mod *= <span class=\"hljs-number\">10</span>) &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; arr.<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            <span class=\"hljs-keyword\">var</span> bucket = parseInt((arr[j] % mod) / dev);<br>            <span class=\"hljs-keyword\">if</span>(counter[bucket]==<span class=\"hljs-literal\">null</span>) &#123;<br>                counter[bucket] = [];<br>            &#125;<br>            counter[bucket].<span class=\"hljs-built_in\">push</span>(arr[j]);<br>        &#125;<br>        <span class=\"hljs-keyword\">var</span> pos = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; counter.<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-literal\">null</span>;<br>            <span class=\"hljs-keyword\">if</span>(counter[j]!=<span class=\"hljs-literal\">null</span>) &#123;<br>                <span class=\"hljs-keyword\">while</span> ((value = counter[j].shift()) != <span class=\"hljs-literal\">null</span>) &#123;<br>                      arr[pos++] = value;<br>                &#125;<br>          &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第一章，讨论排序算法。</p>\n<img src=\"/2022/01/17/Algorithm-1/sort_algorithm.png\" class=\"\" title=\"sort algorithm\">\n\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；</li>\n<li>重复步骤2~5。<img src=\"/2022/01/17/Algorithm-1/insertion_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight nsis\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nsis\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">insertionSort</span>(arr) &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">len</span> = arr.length<span class=\"hljs-comment\">;</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">preIndex</span>, <span class=\"hljs-literal\">current</span><span class=\"hljs-comment\">;</span><br>    for (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> = <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">; i &lt; len; i++) &#123;</span><br>        preIndex = i - <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>        <span class=\"hljs-literal\">current</span> = arr[i]<span class=\"hljs-comment\">;</span><br>        while (preIndex &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[preIndex] &gt; <span class=\"hljs-literal\">current</span>) &#123;<br>            arr[preIndex + <span class=\"hljs-number\">1</span>] = arr[preIndex]<span class=\"hljs-comment\">;</span><br>            preIndex--<span class=\"hljs-comment\">;</span><br>        &#125;<br>        arr[preIndex + <span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">current</span><span class=\"hljs-comment\">;</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr<span class=\"hljs-comment\">;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。<img src=\"/2022/01/17/Algorithm-1/bubble_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bubbleSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; len - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; len - <span class=\"hljs-number\">1</span> - i; j++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"hljs-number\">1</span>]) &#123;        <span class=\"hljs-comment\">// 相邻元素两两对比</span><br>                <span class=\"hljs-keyword\">var</span> temp = arr[j+<span class=\"hljs-number\">1</span>];        <span class=\"hljs-comment\">// 元素交换</span><br>                arr[j+<span class=\"hljs-number\">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>\n<ul>\n<li>初始状态：无序区为R[1..n]，有序区为空；</li>\n<li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li>n-1趟结束，数组有序化了。<img src=\"/2022/01/17/Algorithm-1/selection_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">selectionSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">var</span> minIndex, temp;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; len - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        minIndex = i;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; len; j++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class=\"hljs-comment\">// 寻找最小的数</span><br>                minIndex = j;                 <span class=\"hljs-comment\">// 将最小数的索引保存</span><br>            &#125;<br>        &#125;<br>        temp = arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125; <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><ul>\n<li>先选定一个整数gap，把待排序文件中所有元素分成gap组，即所有距离为gap的分在同一组内，并对每一组内的元素进行直接插入排序（本质是进行预排序，使数组更接近有序，目的是使最后一次直接插入排序提高效率）；</li>\n<li>取gap&#x3D;gap&#x2F;2或者gap&#x3D;gap&#x2F;3+1重复上述分组和排序的工作；</li>\n<li>当gap到达1时，数组是已经接近有序的，当gap&#x3D;1，即以一个元素为一组，就相当于对整个数组进行直接插入排序了。<img src=\"/2022/01/17/Algorithm-1/shell_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">shellSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> gap = Math.<span class=\"hljs-built_in\">floor</span>(len / <span class=\"hljs-number\">2</span>); gap &gt; <span class=\"hljs-number\">0</span>; gap = Math.<span class=\"hljs-built_in\">floor</span>(gap / <span class=\"hljs-number\">2</span>)) &#123;<br>        <span class=\"hljs-comment\">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = gap; i &lt; len; i++) &#123;<br>            <span class=\"hljs-keyword\">var</span> j = i;<br>            <span class=\"hljs-keyword\">var</span> current = arr[i];<br>            <span class=\"hljs-keyword\">while</span> (j - gap &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;<br>                 arr[j] = arr[j - gap];<br>                 j = j - gap;<br>            &#125;<br>            arr[j] = current;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。<img src=\"/2022/01/17/Algorithm-1/merge_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mergeSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">if</span> (len &lt; <span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br>    <span class=\"hljs-keyword\">var</span> middle = Math.<span class=\"hljs-built_in\">floor</span>(len / <span class=\"hljs-number\">2</span>),<br>        <span class=\"hljs-built_in\">left</span> = arr.<span class=\"hljs-built_in\">slice</span>(<span class=\"hljs-number\">0</span>, middle),<br>        <span class=\"hljs-built_in\">right</span> = arr.<span class=\"hljs-built_in\">slice</span>(middle);<br>    <span class=\"hljs-keyword\">return</span> merge(mergeSort(<span class=\"hljs-built_in\">left</span>), mergeSort(<span class=\"hljs-built_in\">right</span>));<br>&#125;<br> <br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">left, right</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = [];<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">left</span>.<span class=\"hljs-built_in\">length</span>&gt;<span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-built_in\">right</span>.<span class=\"hljs-built_in\">length</span>&gt;<span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">left</span>[<span class=\"hljs-number\">0</span>] &lt;= <span class=\"hljs-built_in\">right</span>[<span class=\"hljs-number\">0</span>]) &#123;<br>            result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">left</span>.shift());<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">right</span>.shift());<br>        &#125;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">left</span>.<span class=\"hljs-built_in\">length</span>)<br>        result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">left</span>.shift());<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">right</span>.<span class=\"hljs-built_in\">length</span>)<br>        result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">right</span>.shift());<br> <br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ul>\n<img src=\"/2022/01/17/Algorithm-1/quick_sort.gif\" class=\"\" title=\"bubble sort\">\n\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">function quickSort(arr, <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">right</span>) &#123;<br>    <span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">len</span> = arr.length,<br>        partitionIndex,<br>        <span class=\"hljs-built_in\">left</span> = typeof <span class=\"hljs-built_in\">left</span> != &#x27;number&#x27; ? <span class=\"hljs-number\">0</span> <span class=\"hljs-symbol\">:</span> <span class=\"hljs-built_in\">left</span>,<br>        <span class=\"hljs-built_in\">right</span> = typeof <span class=\"hljs-built_in\">right</span> != &#x27;number&#x27; ? <span class=\"hljs-built_in\">len</span> - <span class=\"hljs-number\">1</span> <span class=\"hljs-symbol\">:</span> <span class=\"hljs-built_in\">right</span>;<br> <br>    <span class=\"hljs-built_in\">if</span> (<span class=\"hljs-built_in\">left</span> &lt; <span class=\"hljs-built_in\">right</span>) &#123;<br>        partitionIndex = partition(arr, <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">right</span>);<br>        quickSort(arr, <span class=\"hljs-built_in\">left</span>, partitionIndex-<span class=\"hljs-number\">1</span>);<br>        quickSort(arr, partitionIndex+<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">right</span>);<br>    &#125;<br>    return arr;<br>&#125;<br> <br>function partition(arr, <span class=\"hljs-built_in\">left</span> ,<span class=\"hljs-built_in\">right</span>) &#123;     // 分区操作<br>    <span class=\"hljs-built_in\">var</span> pivot = <span class=\"hljs-built_in\">left</span>,                      // 设定基准值（pivot）<br>        <span class=\"hljs-built_in\">index</span> = pivot + <span class=\"hljs-number\">1</span>;<br>    for (<span class=\"hljs-built_in\">var</span> i = <span class=\"hljs-built_in\">index</span>; i &lt;= <span class=\"hljs-built_in\">right</span>; i++) &#123;<br>        <span class=\"hljs-built_in\">if</span> (arr[i] &lt; arr[pivot]) &#123;<br>            swap(arr, i, <span class=\"hljs-built_in\">index</span>);<br>            <span class=\"hljs-built_in\">index</span>++;<br>        &#125;       <br>    &#125;<br>    swap(arr, pivot, <span class=\"hljs-built_in\">index</span> - <span class=\"hljs-number\">1</span>);<br>    return <span class=\"hljs-built_in\">index</span>-<span class=\"hljs-number\">1</span>;<br>&#125;<br> <br>function swap(arr, i, j) &#123;<br>    <span class=\"hljs-built_in\">var</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>\n<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<img src=\"/2022/01/17/Algorithm-1/heap_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight wren\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs wren\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">len</span>;    <span class=\"hljs-comment\">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">buildMaxHeap</span>(<span class=\"hljs-params\">arr</span>) &#123;   <span class=\"hljs-comment\">// 建立大顶堆</span><br>    <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>.<span class=\"hljs-property\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">floor</span>(<span class=\"hljs-variable\">len</span>/<span class=\"hljs-number\">2</span>); <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">i</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>) &#123;<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">i</span>);<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-params\">arr</span>, <span class=\"hljs-params\">i</span>) &#123;     <span class=\"hljs-comment\">// 堆调整</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span>,<br>        <span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">2</span>,<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">i</span>;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">&amp;&amp;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">left</span>] <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">largest</span>]) &#123;<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">left</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">&amp;&amp;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">right</span>] <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">largest</span>]) &#123;<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">right</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">!=</span> <span class=\"hljs-variable\">i</span>) &#123;<br>        <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">i</span>, <span class=\"hljs-variable\">largest</span>);<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">largest</span>);<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-params\">arr</span>, <span class=\"hljs-params\">i</span>, <span class=\"hljs-params\">j</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>];<br>    <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">j</span>];<br>    <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">j</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">temp</span>;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">heapSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-title function_\">buildMaxHeap</span>(<span class=\"hljs-variable\">arr</span>);<br> <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>.<span class=\"hljs-property\">length</span> <span class=\"hljs-operator\">-</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">i</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>) &#123;<br>        <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable\">i</span>);<br>        <span class=\"hljs-variable\">len</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>;<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-number\">0</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable\">arr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<img src=\"/2022/01/17/Algorithm-1/count_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\">function countingSort(arr, maxValue) &#123;<br>    var <span class=\"hljs-keyword\">bucket </span>= new Array(maxValue + <span class=\"hljs-number\">1</span>),<br>        sortedIndex = <span class=\"hljs-number\">0</span>;<br>        arrLen = arr.length,<br>        <span class=\"hljs-keyword\">bucketLen </span>= maxValue + <span class=\"hljs-number\">1</span>;<br> <br>    for (var i = <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; i &lt; arrLen; i++) &#123;</span><br>        if (!<span class=\"hljs-keyword\">bucket[arr[i]]) </span>&#123;<br>            <span class=\"hljs-keyword\">bucket[arr[i]] </span>= <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">bucket[arr[i]]++;</span><br><span class=\"hljs-keyword\"></span>    &#125;<br> <br>    for (var <span class=\"hljs-keyword\">j </span>= <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; j &lt; bucketLen; j++) &#123;</span><br>        while(<span class=\"hljs-keyword\">bucket[j] </span>&gt; <span class=\"hljs-number\">0</span>) &#123;<br>            arr[sortedIndex++] = <span class=\"hljs-keyword\">j;</span><br><span class=\"hljs-keyword\"></span>            <span class=\"hljs-keyword\">bucket[j]--;</span><br><span class=\"hljs-keyword\"></span>        &#125;<br>    &#125;<br> <br>    return arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li>设置一个定量的数组当作空桶；</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>对每个不是空的桶进行排序；</li>\n<li>从不是空的桶里把排好序的数据拼接起来。<img src=\"/2022/01/17/Algorithm-1/bubble_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bucketSort</span>(<span class=\"hljs-params\">arr, bucketSize</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (arr.<span class=\"hljs-built_in\">length</span> === <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">var</span> i;<br>    <span class=\"hljs-keyword\">var</span> minValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">var</span> maxValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">1</span>; i &lt; arr.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; minValue) &#123;<br>          minValue = arr[i];                <span class=\"hljs-comment\">// 输入数据的最小值</span><br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[i] &gt; maxValue) &#123;<br>          maxValue = arr[i];                <span class=\"hljs-comment\">// 输入数据的最大值</span><br>      &#125;<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// 桶的初始化</span><br>    <span class=\"hljs-keyword\">var</span> DEFAULT_BUCKET_SIZE = <span class=\"hljs-number\">5</span>;            <span class=\"hljs-comment\">// 设置桶的默认数量为5</span><br>    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;<br>    <span class=\"hljs-keyword\">var</span> bucketCount = Math.<span class=\"hljs-built_in\">floor</span>((maxValue - minValue) / bucketSize) + <span class=\"hljs-number\">1</span>;  <br>    <span class=\"hljs-keyword\">var</span> buckets = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(bucketCount);<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; buckets.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        buckets[i] = [];<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// 利用映射函数将数据分配到各个桶中</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        buckets[Math.<span class=\"hljs-built_in\">floor</span>((arr[i] - minValue) / bucketSize)].<span class=\"hljs-built_in\">push</span>(arr[i]);<br>    &#125;<br> <br>    arr.<span class=\"hljs-built_in\">length</span> = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; buckets.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        insertionSort(buckets[i]);                      <span class=\"hljs-comment\">// 对每个桶进行排序，这里使用了插入排序</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; buckets[i].<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            arr.<span class=\"hljs-built_in\">push</span>(buckets[i][j]);                     <br>        &#125;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><ul>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>\n<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；<img src=\"/2022/01/17/Algorithm-1/radix_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">var</span> counter = [];<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">radixSort</span>(<span class=\"hljs-params\">arr, maxDigit</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> mod = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">var</span> dev = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; maxDigit; i++, dev *= <span class=\"hljs-number\">10</span>, mod *= <span class=\"hljs-number\">10</span>) &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; arr.<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            <span class=\"hljs-keyword\">var</span> bucket = parseInt((arr[j] % mod) / dev);<br>            <span class=\"hljs-keyword\">if</span>(counter[bucket]==<span class=\"hljs-literal\">null</span>) &#123;<br>                counter[bucket] = [];<br>            &#125;<br>            counter[bucket].<span class=\"hljs-built_in\">push</span>(arr[j]);<br>        &#125;<br>        <span class=\"hljs-keyword\">var</span> pos = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; counter.<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-literal\">null</span>;<br>            <span class=\"hljs-keyword\">if</span>(counter[j]!=<span class=\"hljs-literal\">null</span>) &#123;<br>                <span class=\"hljs-keyword\">while</span> ((value = counter[j].shift()) != <span class=\"hljs-literal\">null</span>) &#123;<br>                      arr[pos++] = value;<br>                &#125;<br>          &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"Algorithm 2","date":"2022-01-18T05:29:34.000Z","_content":"\n\n### 简介\n算法第二章，讨论搜索算法。\n\n\n\n\n### 回溯算法\n\n\n\n### 深度优先算法\n\n\n\n### 广度优先算法\n\n\n### 剪枝算法\n\n\n### 枚举算法\n\n\n\n","source":"_posts/Algorithm-2.md","raw":"---\ntitle: Algorithm 2\ndate: 2022-01-18 13:29:34\ntags: IT-Basics\n---\n\n\n### 简介\n算法第二章，讨论搜索算法。\n\n\n\n\n### 回溯算法\n\n\n\n### 深度优先算法\n\n\n\n### 广度优先算法\n\n\n### 剪枝算法\n\n\n### 枚举算法\n\n\n\n","slug":"Algorithm-2","published":1,"updated":"2024-03-12T09:14:20.202Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9m0001dk2d8gtzc2m2","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第二章，讨论搜索算法。</p>\n<h3 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h3><h3 id=\"深度优先算法\"><a href=\"#深度优先算法\" class=\"headerlink\" title=\"深度优先算法\"></a>深度优先算法</h3><h3 id=\"广度优先算法\"><a href=\"#广度优先算法\" class=\"headerlink\" title=\"广度优先算法\"></a>广度优先算法</h3><h3 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h3><h3 id=\"枚举算法\"><a href=\"#枚举算法\" class=\"headerlink\" title=\"枚举算法\"></a>枚举算法</h3>","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第二章，讨论搜索算法。</p>\n<h3 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h3><h3 id=\"深度优先算法\"><a href=\"#深度优先算法\" class=\"headerlink\" title=\"深度优先算法\"></a>深度优先算法</h3><h3 id=\"广度优先算法\"><a href=\"#广度优先算法\" class=\"headerlink\" title=\"广度优先算法\"></a>广度优先算法</h3><h3 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h3><h3 id=\"枚举算法\"><a href=\"#枚举算法\" class=\"headerlink\" title=\"枚举算法\"></a>枚举算法</h3>"},{"title":"Algorithm 3","date":"2022-01-20T07:12:38.000Z","_content":"\n\n### 简介\n算法第三章，讨论动态规划。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Algorithm-3.md","raw":"---\ntitle: Algorithm 3\ndate: 2022-01-20 15:12:38\ntags: IT-Basics\n---\n\n\n### 简介\n算法第三章，讨论动态规划。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Algorithm-3","published":1,"updated":"2024-03-12T12:34:41.841Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9n0003dk2de5auhksg","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第三章，讨论动态规划。</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第三章，讨论动态规划。</p>\n"},{"title":"Algorithm 4","date":"2022-01-22T09:36:10.000Z","_content":"\n\n### 简介\n算法第四章，讨论算法思想和技巧。\n\n\n\n### 分治\n\n\n### 倍增\n\n\n### 二分法\n\n\n### 贪心算法\n\n\n\n","source":"_posts/Algorithm-4.md","raw":"---\ntitle: Algorithm 4\ndate: 2022-01-22 17:36:10\ntags: IT-Basics\n---\n\n\n### 简介\n算法第四章，讨论算法思想和技巧。\n\n\n\n### 分治\n\n\n### 倍增\n\n\n### 二分法\n\n\n### 贪心算法\n\n\n\n","slug":"Algorithm-4","published":1,"updated":"2024-03-12T09:19:22.553Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9n0004dk2d3bno95yl","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第四章，讨论算法思想和技巧。</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><h3 id=\"倍增\"><a href=\"#倍增\" class=\"headerlink\" title=\"倍增\"></a>倍增</h3><h3 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h3><h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3>","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第四章，讨论算法思想和技巧。</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><h3 id=\"倍增\"><a href=\"#倍增\" class=\"headerlink\" title=\"倍增\"></a>倍增</h3><h3 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h3><h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3>"},{"title":"Backend Node","date":"2022-04-05T09:22:00.000Z","_content":"\n### 1，简介\n一个后台服务项目，可以存储用户的文件和数据，并将文件同步到第三方云盘。\n\n### 2，功能\n- 手机号注册/手机号登录\n- OAuth授权\n- 账户登录\n- 密码修改\n\n- API鉴权\n- 数据管理\n- 文件管理\n- 个人云盘数据同步\n\n- 数字货币fee(TODO)\n\n\n### 3，部署\n3.1 clone\n{% blockquote %}\n$git clone https://github.com/xidaokun/Cary.Project.Python.Backend.git\n{% endblockquote %}\n\n3.2 run\n{% blockquote %}\n$./run.sh start\n{% endblockquote %}\n\n### 4，APIS\n##### 4.1 User manager\n1.register user\n{% blockquote %}\n$curl -d '{\"name\":\"cary\", \"password\":\"123456\", \"phone\":\"1234567890\", \"code\":1111}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/register\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\" }\n{% endblockquote %}\n\n2.user login\n{% blockquote %}\n$curl -d '{\"name\":\"cary\", \"password\":\"123456\"}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/login\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\", \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\\.  \neyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYs  \nImF1ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJj  \nYXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0\\.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8\", \"user_id\": \"608abd1c9f394f7d7f019f95\", \"user_name\": \"cary\" }\n{% endblockquote %}\n\n3.verification code\n{% blockquote %}\n$curl -d '{\"phone\":\"1234567890\"}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/verification_code\n{% endblockquote %}\n\n4.change password\n{% blockquote %}\n$curl -d '{\"password\":\"12345\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/change_pwd\n{% endblockquote %}\n\n##### 4.2 OAuth\n{% blockquote %}\n$curl http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&type=github&redirect_uri=http://example.com&state=xyz\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\", \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\\.  \neyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYsImF1  \nZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJjY  \nXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0\\.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8\", \"user_id\": \"608abd1c9f394f7d7f019f95\", \"user_name\": \"cary\" }\n{% endblockquote %}\n\n##### 4.3 File operation\n1.upload file\n{% blockquote %}\n$curl -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/upload/test.txt\n{% endblockquote %}\n\n2.download file\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/download?path=test.txt\n{% endblockquote %}\n\n3.list files\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/list\n{% endblockquote %}\n\n4.get file information\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/information\n{% endblockquote %}\n\n5.delete file\n{% blockquote %}\ncurl -d '{\"file\":\"test.txt\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/file/delete\n{% endblockquote %}\n\n##### 4.4 Database operation\n1.create collection\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/create_col\n{% endblockquote %}\n\n2.insert one/many document\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"document\":{\"worker\":\"cary\",\"title\":\"developer\"},\"options\":{\"bypass_document_validation\":false}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/insert_one\n{% endblockquote %}\n\n3.update one/many document\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",},\"update\":{\"$set\":{\"author\":\"cary\",\"title\":\"manger\"}},\"options\":{\"upsert\":true,\"bypass_document_validation\":false}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/update_one\n{% endblockquote %}\n\n4.count documents\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",},\"options\":{\"skip\":0,\"limit\":10,\"maxTimeMS\":1000000000}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/count_documents\n{% endblockquote %}\n\n5.delete one/many documents\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/delete_one\n{% endblockquote %}\n\n6.delete collection\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/delete_col\n{% endblockquote %}\n\n\n","source":"_posts/Backend-Node.md","raw":"---\ntitle: Backend Node\ndate: 2022-04-05 17:22:00\ntags: Backend\n---\n\n### 1，简介\n一个后台服务项目，可以存储用户的文件和数据，并将文件同步到第三方云盘。\n\n### 2，功能\n- 手机号注册/手机号登录\n- OAuth授权\n- 账户登录\n- 密码修改\n\n- API鉴权\n- 数据管理\n- 文件管理\n- 个人云盘数据同步\n\n- 数字货币fee(TODO)\n\n\n### 3，部署\n3.1 clone\n{% blockquote %}\n$git clone https://github.com/xidaokun/Cary.Project.Python.Backend.git\n{% endblockquote %}\n\n3.2 run\n{% blockquote %}\n$./run.sh start\n{% endblockquote %}\n\n### 4，APIS\n##### 4.1 User manager\n1.register user\n{% blockquote %}\n$curl -d '{\"name\":\"cary\", \"password\":\"123456\", \"phone\":\"1234567890\", \"code\":1111}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/register\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\" }\n{% endblockquote %}\n\n2.user login\n{% blockquote %}\n$curl -d '{\"name\":\"cary\", \"password\":\"123456\"}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/login\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\", \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\\.  \neyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYs  \nImF1ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJj  \nYXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0\\.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8\", \"user_id\": \"608abd1c9f394f7d7f019f95\", \"user_name\": \"cary\" }\n{% endblockquote %}\n\n3.verification code\n{% blockquote %}\n$curl -d '{\"phone\":\"1234567890\"}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/verification_code\n{% endblockquote %}\n\n4.change password\n{% blockquote %}\n$curl -d '{\"password\":\"12345\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/change_pwd\n{% endblockquote %}\n\n##### 4.2 OAuth\n{% blockquote %}\n$curl http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&type=github&redirect_uri=http://example.com&state=xyz\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\", \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\\.  \neyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYsImF1  \nZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJjY  \nXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0\\.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8\", \"user_id\": \"608abd1c9f394f7d7f019f95\", \"user_name\": \"cary\" }\n{% endblockquote %}\n\n##### 4.3 File operation\n1.upload file\n{% blockquote %}\n$curl -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/upload/test.txt\n{% endblockquote %}\n\n2.download file\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/download?path=test.txt\n{% endblockquote %}\n\n3.list files\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/list\n{% endblockquote %}\n\n4.get file information\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/information\n{% endblockquote %}\n\n5.delete file\n{% blockquote %}\ncurl -d '{\"file\":\"test.txt\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/file/delete\n{% endblockquote %}\n\n##### 4.4 Database operation\n1.create collection\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/create_col\n{% endblockquote %}\n\n2.insert one/many document\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"document\":{\"worker\":\"cary\",\"title\":\"developer\"},\"options\":{\"bypass_document_validation\":false}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/insert_one\n{% endblockquote %}\n\n3.update one/many document\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",},\"update\":{\"$set\":{\"author\":\"cary\",\"title\":\"manger\"}},\"options\":{\"upsert\":true,\"bypass_document_validation\":false}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/update_one\n{% endblockquote %}\n\n4.count documents\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",},\"options\":{\"skip\":0,\"limit\":10,\"maxTimeMS\":1000000000}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/count_documents\n{% endblockquote %}\n\n5.delete one/many documents\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/delete_one\n{% endblockquote %}\n\n6.delete collection\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/delete_col\n{% endblockquote %}\n\n\n","slug":"Backend-Node","published":1,"updated":"2024-03-12T07:26:08.950Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9n0005dk2dfl6ihnw7","content":"<h3 id=\"1，简介\"><a href=\"#1，简介\" class=\"headerlink\" title=\"1，简介\"></a>1，简介</h3><p>一个后台服务项目，可以存储用户的文件和数据，并将文件同步到第三方云盘。</p>\n<h3 id=\"2，功能\"><a href=\"#2，功能\" class=\"headerlink\" title=\"2，功能\"></a>2，功能</h3><ul>\n<li><p>手机号注册&#x2F;手机号登录</p>\n</li>\n<li><p>OAuth授权</p>\n</li>\n<li><p>账户登录</p>\n</li>\n<li><p>密码修改</p>\n</li>\n<li><p>API鉴权</p>\n</li>\n<li><p>数据管理</p>\n</li>\n<li><p>文件管理</p>\n</li>\n<li><p>个人云盘数据同步</p>\n</li>\n<li><p>数字货币fee(TODO)</p>\n</li>\n</ul>\n<h3 id=\"3，部署\"><a href=\"#3，部署\" class=\"headerlink\" title=\"3，部署\"></a>3，部署</h3><p>3.1 clone</p>\n<blockquote><p>$git clone <a href=\"https://github.com/xidaokun/Cary.Project.Python.Backend.git\">https://github.com/xidaokun/Cary.Project.Python.Backend.git</a></p>\n</blockquote>\n\n<p>3.2 run</p>\n<blockquote><p>$.&#x2F;run.sh start</p>\n</blockquote>\n\n<h3 id=\"4，APIS\"><a href=\"#4，APIS\" class=\"headerlink\" title=\"4，APIS\"></a>4，APIS</h3><h5 id=\"4-1-User-manager\"><a href=\"#4-1-User-manager\" class=\"headerlink\" title=\"4.1 User manager\"></a>4.1 User manager</h5><p>1.register user</p>\n<blockquote><p>$curl -d ‘{“name”:”cary”, “password”:”123456”, “phone”:”1234567890”, “code”:1111}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/register\">http://127.0.0.1:5000/api/v1/user/register</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK” }</p>\n</blockquote>\n\n<p>2.user login</p>\n<blockquote><p>$curl -d ‘{“name”:”cary”, “password”:”123456”}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/login\">http://127.0.0.1:5000/api/v1/user/login</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK”, “access_token”: “eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<br>eyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYs<br>ImF1ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJj<br>YXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8”, “user_id”: “608abd1c9f394f7d7f019f95”, “user_name”: “cary” }</p>\n</blockquote>\n\n<p>3.verification code</p>\n<blockquote><p>$curl -d ‘{“phone”:”1234567890”}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/verification_code\">http://127.0.0.1:5000/api/v1/user/verification_code</a></p>\n</blockquote>\n\n<p>4.change password</p>\n<blockquote><p>$curl -d ‘{“password”:”12345”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/change_pwd\">http://127.0.0.1:5000/api/v1/user/change_pwd</a></p>\n</blockquote>\n\n<h5 id=\"4-2-OAuth\"><a href=\"#4-2-OAuth\" class=\"headerlink\" title=\"4.2 OAuth\"></a>4.2 OAuth</h5><blockquote><p>$curl <a href=\"http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&type=github&redirect_uri=http://example.com&state=xyz\">http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&amp;type=github&amp;redirect_uri=http://example.com&amp;state=xyz</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK”, “access_token”: “eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<br>eyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYsImF1<br>ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJjY<br>XJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8”, “user_id”: “608abd1c9f394f7d7f019f95”, “user_name”: “cary” }</p>\n</blockquote>\n\n<h5 id=\"4-3-File-operation\"><a href=\"#4-3-File-operation\" class=\"headerlink\" title=\"4.3 File operation\"></a>4.3 File operation</h5><p>1.upload file</p>\n<blockquote><p>$curl -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/upload/test.txt\">http://127.0.0.1:5000/api/v1/file/upload/test.txt</a></p>\n</blockquote>\n\n<p>2.download file</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/download?path=test.txt\">http://127.0.0.1:5000/api/v1/file/download?path=test.txt</a></p>\n</blockquote>\n\n<p>3.list files</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/list\">http://127.0.0.1:5000/api/v1/file/list</a></p>\n</blockquote>\n\n<p>4.get file information</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/information\">http://127.0.0.1:5000/api/v1/file/information</a></p>\n</blockquote>\n\n<p>5.delete file</p>\n<blockquote><p>curl -d ‘{“file”:”test.txt”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/file/delete\">http://127.0.0.1:5000/api/v1/file/delete</a></p>\n</blockquote>\n\n<h5 id=\"4-4-Database-operation\"><a href=\"#4-4-Database-operation\" class=\"headerlink\" title=\"4.4 Database operation\"></a>4.4 Database operation</h5><p>1.create collection</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/create_col\">http://127.0.0.1:5000/api/v1/db/create_col</a></p>\n</blockquote>\n\n<p>2.insert one&#x2F;many document</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”document”:{“worker”:”cary”,”title”:”developer”},”options”:{“bypass_document_validation”:false}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/insert_one\">http://127.0.0.1:5000/api/v1/db/insert_one</a></p>\n</blockquote>\n\n<p>3.update one&#x2F;many document</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,},”update”:{“$set”:{“author”:”cary”,”title”:”manger”}},”options”:{“upsert”:true,”bypass_document_validation”:false}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/update_one\">http://127.0.0.1:5000/api/v1/db/update_one</a></p>\n</blockquote>\n\n<p>4.count documents</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,},”options”:{“skip”:0,”limit”:10,”maxTimeMS”:1000000000}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/count_documents\">http://127.0.0.1:5000/api/v1/db/count_documents</a></p>\n</blockquote>\n\n<p>5.delete one&#x2F;many documents</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/delete_one\">http://127.0.0.1:5000/api/v1/db/delete_one</a></p>\n</blockquote>\n\n<p>6.delete collection</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/delete_col\">http://127.0.0.1:5000/api/v1/db/delete_col</a></p>\n</blockquote>\n\n\n","excerpt":"","more":"<h3 id=\"1，简介\"><a href=\"#1，简介\" class=\"headerlink\" title=\"1，简介\"></a>1，简介</h3><p>一个后台服务项目，可以存储用户的文件和数据，并将文件同步到第三方云盘。</p>\n<h3 id=\"2，功能\"><a href=\"#2，功能\" class=\"headerlink\" title=\"2，功能\"></a>2，功能</h3><ul>\n<li><p>手机号注册&#x2F;手机号登录</p>\n</li>\n<li><p>OAuth授权</p>\n</li>\n<li><p>账户登录</p>\n</li>\n<li><p>密码修改</p>\n</li>\n<li><p>API鉴权</p>\n</li>\n<li><p>数据管理</p>\n</li>\n<li><p>文件管理</p>\n</li>\n<li><p>个人云盘数据同步</p>\n</li>\n<li><p>数字货币fee(TODO)</p>\n</li>\n</ul>\n<h3 id=\"3，部署\"><a href=\"#3，部署\" class=\"headerlink\" title=\"3，部署\"></a>3，部署</h3><p>3.1 clone</p>\n<blockquote><p>$git clone <a href=\"https://github.com/xidaokun/Cary.Project.Python.Backend.git\">https://github.com/xidaokun/Cary.Project.Python.Backend.git</a></p>\n</blockquote>\n\n<p>3.2 run</p>\n<blockquote><p>$.&#x2F;run.sh start</p>\n</blockquote>\n\n<h3 id=\"4，APIS\"><a href=\"#4，APIS\" class=\"headerlink\" title=\"4，APIS\"></a>4，APIS</h3><h5 id=\"4-1-User-manager\"><a href=\"#4-1-User-manager\" class=\"headerlink\" title=\"4.1 User manager\"></a>4.1 User manager</h5><p>1.register user</p>\n<blockquote><p>$curl -d ‘{“name”:”cary”, “password”:”123456”, “phone”:”1234567890”, “code”:1111}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/register\">http://127.0.0.1:5000/api/v1/user/register</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK” }</p>\n</blockquote>\n\n<p>2.user login</p>\n<blockquote><p>$curl -d ‘{“name”:”cary”, “password”:”123456”}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/login\">http://127.0.0.1:5000/api/v1/user/login</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK”, “access_token”: “eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<br>eyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYs<br>ImF1ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJj<br>YXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8”, “user_id”: “608abd1c9f394f7d7f019f95”, “user_name”: “cary” }</p>\n</blockquote>\n\n<p>3.verification code</p>\n<blockquote><p>$curl -d ‘{“phone”:”1234567890”}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/verification_code\">http://127.0.0.1:5000/api/v1/user/verification_code</a></p>\n</blockquote>\n\n<p>4.change password</p>\n<blockquote><p>$curl -d ‘{“password”:”12345”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/change_pwd\">http://127.0.0.1:5000/api/v1/user/change_pwd</a></p>\n</blockquote>\n\n<h5 id=\"4-2-OAuth\"><a href=\"#4-2-OAuth\" class=\"headerlink\" title=\"4.2 OAuth\"></a>4.2 OAuth</h5><blockquote><p>$curl <a href=\"http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&type=github&redirect_uri=http://example.com&state=xyz\">http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&amp;type=github&amp;redirect_uri=http://example.com&amp;state=xyz</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK”, “access_token”: “eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<br>eyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYsImF1<br>ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJjY<br>XJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8”, “user_id”: “608abd1c9f394f7d7f019f95”, “user_name”: “cary” }</p>\n</blockquote>\n\n<h5 id=\"4-3-File-operation\"><a href=\"#4-3-File-operation\" class=\"headerlink\" title=\"4.3 File operation\"></a>4.3 File operation</h5><p>1.upload file</p>\n<blockquote><p>$curl -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/upload/test.txt\">http://127.0.0.1:5000/api/v1/file/upload/test.txt</a></p>\n</blockquote>\n\n<p>2.download file</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/download?path=test.txt\">http://127.0.0.1:5000/api/v1/file/download?path=test.txt</a></p>\n</blockquote>\n\n<p>3.list files</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/list\">http://127.0.0.1:5000/api/v1/file/list</a></p>\n</blockquote>\n\n<p>4.get file information</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/information\">http://127.0.0.1:5000/api/v1/file/information</a></p>\n</blockquote>\n\n<p>5.delete file</p>\n<blockquote><p>curl -d ‘{“file”:”test.txt”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/file/delete\">http://127.0.0.1:5000/api/v1/file/delete</a></p>\n</blockquote>\n\n<h5 id=\"4-4-Database-operation\"><a href=\"#4-4-Database-operation\" class=\"headerlink\" title=\"4.4 Database operation\"></a>4.4 Database operation</h5><p>1.create collection</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/create_col\">http://127.0.0.1:5000/api/v1/db/create_col</a></p>\n</blockquote>\n\n<p>2.insert one&#x2F;many document</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”document”:{“worker”:”cary”,”title”:”developer”},”options”:{“bypass_document_validation”:false}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/insert_one\">http://127.0.0.1:5000/api/v1/db/insert_one</a></p>\n</blockquote>\n\n<p>3.update one&#x2F;many document</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,},”update”:{“$set”:{“author”:”cary”,”title”:”manger”}},”options”:{“upsert”:true,”bypass_document_validation”:false}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/update_one\">http://127.0.0.1:5000/api/v1/db/update_one</a></p>\n</blockquote>\n\n<p>4.count documents</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,},”options”:{“skip”:0,”limit”:10,”maxTimeMS”:1000000000}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/count_documents\">http://127.0.0.1:5000/api/v1/db/count_documents</a></p>\n</blockquote>\n\n<p>5.delete one&#x2F;many documents</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/delete_one\">http://127.0.0.1:5000/api/v1/db/delete_one</a></p>\n</blockquote>\n\n<p>6.delete collection</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/delete_col\">http://127.0.0.1:5000/api/v1/db/delete_col</a></p>\n</blockquote>\n\n\n"},{"title":"Blockchain wallet","date":"2019-07-18T07:27:45.000Z","_content":"\n### 简介\n一款支持多币种，多账户的区块链HD钱包，项目开源。\n\n\n### 特点\n1，简捷的支付方式\n2，支持BTC, BCH, ETH和所有ERC-20 tokens\n3，简捷的密钥备份\n4，安全的密钥存储\n5，支持众多Dapp\n\n\n### 开发&部署\n1，Download and install Java 7 or up\n2，Download and Install the latest Android studio\n3，Download and install the latest NDK https://developer.android.com/ndk/downloads/index.html or download it in android studio by \"choosing the NDK\" and press \"download\"(Ndk Version must be 16)\n4，Go to https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android\n5，Open the project with Android Studio and let the project sync\n6，Go to SDK Manager and download all the SDK Platforms and SDK Tools\n7，Build -> Rebuild Project","source":"_posts/Blockchain-wallet.md","raw":"---\ntitle: Blockchain wallet\ndate: 2019-07-18 15:27:45\ntags: \n    - Blockchain\n    - Android\n---\n\n### 简介\n一款支持多币种，多账户的区块链HD钱包，项目开源。\n\n\n### 特点\n1，简捷的支付方式\n2，支持BTC, BCH, ETH和所有ERC-20 tokens\n3，简捷的密钥备份\n4，安全的密钥存储\n5，支持众多Dapp\n\n\n### 开发&部署\n1，Download and install Java 7 or up\n2，Download and Install the latest Android studio\n3，Download and install the latest NDK https://developer.android.com/ndk/downloads/index.html or download it in android studio by \"choosing the NDK\" and press \"download\"(Ndk Version must be 16)\n4，Go to https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android\n5，Open the project with Android Studio and let the project sync\n6，Go to SDK Manager and download all the SDK Platforms and SDK Tools\n7，Build -> Rebuild Project","slug":"Blockchain-wallet","published":1,"updated":"2024-03-12T07:57:30.607Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9o0008dk2d0dm97xgd","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>一款支持多币种，多账户的区块链HD钱包，项目开源。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>1，简捷的支付方式<br>2，支持BTC, BCH, ETH和所有ERC-20 tokens<br>3，简捷的密钥备份<br>4，安全的密钥存储<br>5，支持众多Dapp</p>\n<h3 id=\"开发-部署\"><a href=\"#开发-部署\" class=\"headerlink\" title=\"开发&amp;部署\"></a>开发&amp;部署</h3><p>1，Download and install Java 7 or up<br>2，Download and Install the latest Android studio<br>3，Download and install the latest NDK <a href=\"https://developer.android.com/ndk/downloads/index.html\">https://developer.android.com/ndk/downloads/index.html</a> or download it in android studio by “choosing the NDK” and press “download”(Ndk Version must be 16)<br>4，Go to <a href=\"https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android\">https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android</a><br>5，Open the project with Android Studio and let the project sync<br>6，Go to SDK Manager and download all the SDK Platforms and SDK Tools<br>7，Build -&gt; Rebuild Project</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>一款支持多币种，多账户的区块链HD钱包，项目开源。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>1，简捷的支付方式<br>2，支持BTC, BCH, ETH和所有ERC-20 tokens<br>3，简捷的密钥备份<br>4，安全的密钥存储<br>5，支持众多Dapp</p>\n<h3 id=\"开发-部署\"><a href=\"#开发-部署\" class=\"headerlink\" title=\"开发&amp;部署\"></a>开发&amp;部署</h3><p>1，Download and install Java 7 or up<br>2，Download and Install the latest Android studio<br>3，Download and install the latest NDK <a href=\"https://developer.android.com/ndk/downloads/index.html\">https://developer.android.com/ndk/downloads/index.html</a> or download it in android studio by “choosing the NDK” and press “download”(Ndk Version must be 16)<br>4，Go to <a href=\"https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android\">https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android</a><br>5，Open the project with Android Studio and let the project sync<br>6，Go to SDK Manager and download all the SDK Platforms and SDK Tools<br>7，Build -&gt; Rebuild Project</p>\n"},{"title":"Data Struct 1","date":"2022-01-05T10:10:23.000Z","_content":"\n### 简介\n数据结构讨论第一章，包括：\n数组，链表，栈，队列，散列表。\n\n\n### 数组\n\n\n### 链表\n\n### 栈\n\n\n### 队列\n\n\n### 散列表\n\n\n\n\n\n\n","source":"_posts/Data-Struct-1.md","raw":"---\ntitle: Data Struct 1\ndate: 2022-01-05 18:10:23\ntags: IT-Basics\n---\n\n### 简介\n数据结构讨论第一章，包括：\n数组，链表，栈，队列，散列表。\n\n\n### 数组\n\n\n### 链表\n\n### 栈\n\n\n### 队列\n\n\n### 散列表\n\n\n\n\n\n\n","slug":"Data-Struct-1","published":1,"updated":"2024-03-12T09:22:08.185Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9o000adk2d6uylgcca","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构讨论第一章，包括：<br>数组，链表，栈，队列，散列表。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><h3 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h3>","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构讨论第一章，包括：<br>数组，链表，栈，队列，散列表。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><h3 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h3>"},{"title":"Markdown Tutorial","date":"2022-02-03T14:04:15.000Z","_content":"\n### 标题语法\n要创建标题，在单词或短语前面添加井号 (\\#)，后面一个空格，然后加上标题。\\#的数量代表了标题的级别。(例如：\\#\\#\\# My Header)。\n\n### 段落\n要创建段落，请使用空白行将一行或多行文本进行分隔。\n\n### 换行\n在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。\n\n### 粗体\n要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。\n\n### 斜体\n要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。\n\n### 粗体和斜体\n要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。\n\n### 引用\n要创建块引用，请在段落前添加一个 \\>符号。\n块引用可以包含多个段落。为段落之间的空白行添加一个 \\> 符号。\n\n块引用可以嵌套。在要嵌套的段落前添加一个 \\>\\> 符号。\n\n\n### 列表\n1，有序列表\n要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n2，无序列表\n要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n3，嵌套\n要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。\n\n### 代码\n要将单词或短语表示为代码，请将其包裹在反引号 (\\`) 中。\n\n\n### 分割线\n要创建分隔线，请在单独一行上使用三个或多个星号 (\\*\\*\\*)、破折号 (\\-\\-\\-) 或下划线 (\\_\\_\\_) ，并且不能包含其他内容。\n\n\n### 链接\n链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：\\[超链接显示名\\](超链接地址 \"超链接title\")\n\n\n### 图片\n插入图片Markdown语法代码：\\!\\[图片alt\\](图片链接 \"图片title\")。\n\n\n### 转义字符\n显示原本用于格式化Markdown文档的字符（比如\\*等），可以在字符前面添加反斜杠字符 \\ 。\n\n\n### 内嵌html标签\n对于Markdown涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是HTML或是Markdown，只需将HTML标签添加到Markdown文本中即可。\n出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Markdown-Tutorial.md","raw":"---\ntitle: Markdown Tutorial\ndate: 2022-02-3 22:04:15\ntags: Tool\n---\n\n### 标题语法\n要创建标题，在单词或短语前面添加井号 (\\#)，后面一个空格，然后加上标题。\\#的数量代表了标题的级别。(例如：\\#\\#\\# My Header)。\n\n### 段落\n要创建段落，请使用空白行将一行或多行文本进行分隔。\n\n### 换行\n在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。\n\n### 粗体\n要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。\n\n### 斜体\n要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。\n\n### 粗体和斜体\n要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。\n\n### 引用\n要创建块引用，请在段落前添加一个 \\>符号。\n块引用可以包含多个段落。为段落之间的空白行添加一个 \\> 符号。\n\n块引用可以嵌套。在要嵌套的段落前添加一个 \\>\\> 符号。\n\n\n### 列表\n1，有序列表\n要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n2，无序列表\n要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n3，嵌套\n要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。\n\n### 代码\n要将单词或短语表示为代码，请将其包裹在反引号 (\\`) 中。\n\n\n### 分割线\n要创建分隔线，请在单独一行上使用三个或多个星号 (\\*\\*\\*)、破折号 (\\-\\-\\-) 或下划线 (\\_\\_\\_) ，并且不能包含其他内容。\n\n\n### 链接\n链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：\\[超链接显示名\\](超链接地址 \"超链接title\")\n\n\n### 图片\n插入图片Markdown语法代码：\\!\\[图片alt\\](图片链接 \"图片title\")。\n\n\n### 转义字符\n显示原本用于格式化Markdown文档的字符（比如\\*等），可以在字符前面添加反斜杠字符 \\ 。\n\n\n### 内嵌html标签\n对于Markdown涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是HTML或是Markdown，只需将HTML标签添加到Markdown文本中即可。\n出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Markdown-Tutorial","published":1,"updated":"2024-03-12T02:48:49.491Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9p000ddk2d7nl61xzz","content":"<h3 id=\"标题语法\"><a href=\"#标题语法\" class=\"headerlink\" title=\"标题语法\"></a>标题语法</h3><p>要创建标题，在单词或短语前面添加井号 (#)，后面一个空格，然后加上标题。#的数量代表了标题的级别。(例如：### My Header)。</p>\n<h3 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h3><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p>\n<h3 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h3><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。</p>\n<h3 id=\"粗体\"><a href=\"#粗体\" class=\"headerlink\" title=\"粗体\"></a>粗体</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。</p>\n<h3 id=\"斜体\"><a href=\"#斜体\" class=\"headerlink\" title=\"斜体\"></a>斜体</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。</p>\n<h3 id=\"粗体和斜体\"><a href=\"#粗体和斜体\" class=\"headerlink\" title=\"粗体和斜体\"></a>粗体和斜体</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>要创建块引用，请在段落前添加一个 &gt;符号。<br>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。</p>\n<p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>1，有序列表<br>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。<br>2，无序列表<br>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。<br>3，嵌套<br>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。</p>\n<h3 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h3><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。</p>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。<br>超链接Markdown语法代码：[超链接显示名](超链接地址 “超链接title”)</p>\n<h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p>插入图片Markdown语法代码：![图片alt](图片链接 “图片title”)。</p>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>显示原本用于格式化Markdown文档的字符（比如*等），可以在字符前面添加反斜杠字符 \\ 。</p>\n<h3 id=\"内嵌html标签\"><a href=\"#内嵌html标签\" class=\"headerlink\" title=\"内嵌html标签\"></a>内嵌html标签</h3><p>对于Markdown涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是HTML或是Markdown，只需将HTML标签添加到Markdown文本中即可。<br>出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。</p>\n","excerpt":"","more":"<h3 id=\"标题语法\"><a href=\"#标题语法\" class=\"headerlink\" title=\"标题语法\"></a>标题语法</h3><p>要创建标题，在单词或短语前面添加井号 (#)，后面一个空格，然后加上标题。#的数量代表了标题的级别。(例如：### My Header)。</p>\n<h3 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h3><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p>\n<h3 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h3><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。</p>\n<h3 id=\"粗体\"><a href=\"#粗体\" class=\"headerlink\" title=\"粗体\"></a>粗体</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。</p>\n<h3 id=\"斜体\"><a href=\"#斜体\" class=\"headerlink\" title=\"斜体\"></a>斜体</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。</p>\n<h3 id=\"粗体和斜体\"><a href=\"#粗体和斜体\" class=\"headerlink\" title=\"粗体和斜体\"></a>粗体和斜体</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>要创建块引用，请在段落前添加一个 &gt;符号。<br>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。</p>\n<p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>1，有序列表<br>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。<br>2，无序列表<br>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。<br>3，嵌套<br>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。</p>\n<h3 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h3><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。</p>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。<br>超链接Markdown语法代码：[超链接显示名](超链接地址 “超链接title”)</p>\n<h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p>插入图片Markdown语法代码：![图片alt](图片链接 “图片title”)。</p>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>显示原本用于格式化Markdown文档的字符（比如*等），可以在字符前面添加反斜杠字符 \\ 。</p>\n<h3 id=\"内嵌html标签\"><a href=\"#内嵌html标签\" class=\"headerlink\" title=\"内嵌html标签\"></a>内嵌html标签</h3><p>对于Markdown涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是HTML或是Markdown，只需将HTML标签添加到Markdown文本中即可。<br>出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。</p>\n"},{"title":"Data Struct 2","date":"2022-01-08T09:03:53.000Z","_content":"\n### 简介\n数据结构第二章，讨论树和图。\n\n\n### 树\n\n\n### 图\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Data-Struct-2.md","raw":"---\ntitle: Data Struct 2\ndate: 2022-01-08 17:03:53\ntags: IT-Basics\n---\n\n### 简介\n数据结构第二章，讨论树和图。\n\n\n### 树\n\n\n### 图\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Data-Struct-2","published":1,"updated":"2024-03-12T09:20:52.477Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9p000fdk2dflf99u6l","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构第二章，讨论树和图。</p>\n<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3>","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构第二章，讨论树和图。</p>\n<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3>"},{"title":"My Desktop tools","date":"2022-03-11T05:33:14.000Z","_content":"\n### 1，简介\n为方便开发，搞一个PC桌面版工具套装，功能不断更新中，目前开发的功能如下：\n1，adb：adb命令大全示例和执行环境。\n2，Database：数据库管理软件。\n3，Git：adb命令大全示例和执行环境。\n4，Color：取色器。\n5，Screen：可获取屏幕信息，可以对屏幕信息截图(全屏或区域截图)。\n6，Casting：投屏助手\n7，MD：md示例和简单的编辑能力。\n8，TODO\n\n### 2，展示\n{% asset_img adb_tool.png tools shwo %}\n\n### 3，发布\n\n\n\n\n","source":"_posts/My-Desktop-tools.md","raw":"---\ntitle: My Desktop tools\ndate: 2022-03-11 13:33:14\ntags: Tool\n---\n\n### 1，简介\n为方便开发，搞一个PC桌面版工具套装，功能不断更新中，目前开发的功能如下：\n1，adb：adb命令大全示例和执行环境。\n2，Database：数据库管理软件。\n3，Git：adb命令大全示例和执行环境。\n4，Color：取色器。\n5，Screen：可获取屏幕信息，可以对屏幕信息截图(全屏或区域截图)。\n6，Casting：投屏助手\n7，MD：md示例和简单的编辑能力。\n8，TODO\n\n### 2，展示\n{% asset_img adb_tool.png tools shwo %}\n\n### 3，发布\n\n\n\n\n","slug":"My-Desktop-tools","published":1,"updated":"2024-03-12T08:01:59.984Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9p000idk2d0g9464sc","content":"<h3 id=\"1，简介\"><a href=\"#1，简介\" class=\"headerlink\" title=\"1，简介\"></a>1，简介</h3><p>为方便开发，搞一个PC桌面版工具套装，功能不断更新中，目前开发的功能如下：<br>1，adb：adb命令大全示例和执行环境。<br>2，Database：数据库管理软件。<br>3，Git：adb命令大全示例和执行环境。<br>4，Color：取色器。<br>5，Screen：可获取屏幕信息，可以对屏幕信息截图(全屏或区域截图)。<br>6，Casting：投屏助手<br>7，MD：md示例和简单的编辑能力。<br>8，TODO</p>\n<h3 id=\"2，展示\"><a href=\"#2，展示\" class=\"headerlink\" title=\"2，展示\"></a>2，展示</h3><img src=\"/2022/03/11/My-Desktop-tools/adb_tool.png\" class=\"\" title=\"tools shwo\">\n\n<h3 id=\"3，发布\"><a href=\"#3，发布\" class=\"headerlink\" title=\"3，发布\"></a>3，发布</h3>","excerpt":"","more":"<h3 id=\"1，简介\"><a href=\"#1，简介\" class=\"headerlink\" title=\"1，简介\"></a>1，简介</h3><p>为方便开发，搞一个PC桌面版工具套装，功能不断更新中，目前开发的功能如下：<br>1，adb：adb命令大全示例和执行环境。<br>2，Database：数据库管理软件。<br>3，Git：adb命令大全示例和执行环境。<br>4，Color：取色器。<br>5，Screen：可获取屏幕信息，可以对屏幕信息截图(全屏或区域截图)。<br>6，Casting：投屏助手<br>7，MD：md示例和简单的编辑能力。<br>8，TODO</p>\n<h3 id=\"2，展示\"><a href=\"#2，展示\" class=\"headerlink\" title=\"2，展示\"></a>2，展示</h3><img src=\"/2022/03/11/My-Desktop-tools/adb_tool.png\" class=\"\" title=\"tools shwo\">\n\n<h3 id=\"3，发布\"><a href=\"#3，发布\" class=\"headerlink\" title=\"3，发布\"></a>3，发布</h3>"},{"title":"OS Develop 1","date":"2022-03-17T05:23:10.000Z","_content":"\n#### 简介\n本章对操作系统开发，涉及的概念做简单讨论，更深入的见后续。\n\n\n### CPU工作方式\nCPU大体分为3部分：控制单元、运算单元和存储单元。\n{% asset_img cpu_workflow.png cpu workflow %}\n\n\n### X86、X64、X86-64、IA-32和IA-64\n- **X86**：这是一种指令集架构家族，最初由英特尔开发。它基于英特尔8086微处理器及其8088变体。8086于1978年推出，作为英特尔8位8080微处理器的完全16位扩展。\n\n- **X64**：这是一个通用术语，指的是x86指令集的64位扩展。它最初由AMD使用，名为AMD64，后来由英特尔实施，名为Intel64。\n\n- **X86-64**：这是x64和AMD64的另一个名称，表示x86指令集的64位扩展。它支持比其前身可能的虚拟内存和物理内存的大量增加，使程序能够在内存中存储更大量的数据。\n\n- **IA-32**：这是x86指令集的一个版本，支持32位计算。它于1985年由英特尔引入，尽管基于30多年前的设计，但它仍然是今天销售的大多数台式机和笔记本电脑的基础。\n\n- **IA-64**：这是一种64位指令集架构，由英特尔开发并于2001年引入，配备了用于企业和高性能计算的Itanium处理器。它与x86架构不向后兼容。\n\n\n### x86寄存器简介\n1，通用寄存器\n通用寄存器可以有多种用途，可以同来保存任何数据；虽说通用，但还是约定了它们的惯用法，比如一般情况下，将cx寄存器用作循环的次数控制，bx用于存储起始地址，这是约定俗成的东西。\n{% asset_img common_registor.png tools shwo %}\n\n2，段寄存器\nx86的段寄存器有6个----CS/DS/ES/SS/FS/GS，均为16位。\nCS：存储代码段的段选择子，代码段保存正在执行的指令。处理器从代码段读取指令时，CS中的段选择子与EIP的值(要执行的下一条指令在代码段中的偏移量)组成逻辑地址。\nDS：数据段寄存器。\nSS：堆栈段寄存器。\nES，FS和GS：给操作系统用的，不用操作系统，用途不一样。\n\n3，状态寄存器\n16位模式下，标志寄存器名称为FLAG，寄存器大小16位。\n32位模式下，标志寄存器的名称为EFLAG，寄存器大小32位。\n64位模式下，为RFLAG，寄存器大小64位。\n\n它的主要作用包括：\n- 存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位\n- 执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。\n- 控制CPU的工作方式，例如IF、VM、TF等标志位。\n\n状态寄存器的各位作用：\n{% asset_img flag_registor.png flag registor %}\n\n\n4，控制寄存器\n控制寄存器决定处理器的操作模式当前执行任务的特性，比如实时模式和保护模式。\n{% asset_img control_registor.jpeg flag registor %}\n\n\n### 内存寻址方式\n分为三大类：\n- 寄存器寻址\n- 立即数寻址\n- 内存寻址\n\n内存寻址用分为：\n- 直接寻址\n- 基址寻址\n- 变址寻址\n- 机址变址寻址\n\n\n### 段寄存器和总线\n数据总线，它的宽度决定数据交换速度。\n控制总线，它的宽度决定可以控制的外设数量。\n地址总线，它决定了内存寻址范围。\n\n段寄存器产生是由于数据总线和地址总线宽度不一致；数据总线宽度，也就是ALU宽度，也是我们常说的16位和32位CPU（也是寄存器的宽度），比如32位的CPU地址总线可以是32位，也可以是36位。\n\n早期，Intel决定让8086访问地址空间为1M，也就是地址总线为20位，但此时数据总线是16位，地址总线宽度大于数据总线，Intel想了一个办法，它加了4个16位的段寄存器(CS,DS,ES,SS)，它们存储的是地址总线高16位的段基址，原来的16地址就变成了段内的偏移量，这样就可以访问到1M内存了。\n\n\n### MMIO和PMIO\n- MMIO\n内存映射方式（并不是映射到主板插的内存条上，是总线访问的内存地址）。\n\n- PMIO\n通过寄存器端口访问。\n\n### 实时模式和保护模式\n- 8086 具有 16 位的段寄存器、指令指针寄存器和通用寄存器（CS、SS、DS、ES、IP、AX、BX、CX、DX、SI、DI、BP、SP），因此，我们称它为 16 位的处理器。尽管它可以访问 1MB 的内存，但是只能分段进行，而且由于只能使用 16 位的段内偏移量，故段的长度最大只能是 64KB。8086 只有一种工作模式，即实模式；当然，这个名称是后来才提出来的。\n\n- 80286 也是一款 16 位的处理器，大部分的寄存器都和 8086 处理器一样。因此，80286 和 8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段；尽管它有 24 根地址线，理论上可以访问 2^24，即 16MB 的内存,但依然只能分成多个段来进行。但是，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16 位保护模式很少为人所知的原因。\n\n- 1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。和 8086/80286 不同，80386 处理器的寄存器是 32 位的，而且拥有 32 根地址线，可以访问 2^32，即 4GB 的内存。80386以及所有后续的 32 位处理器，都兼容实模式，可以运行实模式下的 8086 程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相当于一个非常快速的 8086 处理器。只有在进行一番设置之后，才能运行在保护模式下。在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。32 位保护模式兼容 80286 的 16 位保护模式。\n\n### 实时模式内存布局\n![](/images/real_time_mm.png)\n\n### 虚拟地址空间\n1，虚拟地址空间的大小是怎么决定的\nX86_64体系结构的CPU工作在Long Mode（64位模式）时，虚拟地址的宽度是64位，但是当前的实现都不允许使用2^64字节（16EB）的整个地址空间。在可预见的未来，大多数操作系统和应用程序不需要这么大的地址空间，因此实现如此宽的虚拟地址只会增加地址转换的复杂性和成本，而没有真正的好处。因此，AMD决定在该体系结构的第一个实现中，实际只将虚拟地址的最低有效48位用于地址转换（页表查找）中。\n\n2，小内存如何应对大虚拟地址空间\n物理内存的大小和虚拟地址空间的大小是完全没关系的，虚拟地址空间虽大，但虚拟地址空间的虚拟地址主要用于页表转换，页表能顺利转换的前提是要完成页表填充，页表填充又发生在缺页异常处理中，缺页异常填充页表时首先要向伙伴系统申请内存，而伙伴系统分配的内存都是从物理内存中划分出来的，物理内存的大小决定了它能分配的page数。所以物理内存的大小和虚拟地址空间的大小是没有直接对应关系的。\n\n\n### 全局描述符表（GDT）\n它是由段描述符构成的表。\n段描述符用来描述内存段的属性，它占连续的8个字节。\n{% asset_img gdt.png gdt %}\n\n- G-为0表示“段界限”的单位是字节，为1表示单位为4K。\n- D/B-用来指定段内偏移地址和操作数的大小；对于代码段来说，此位是D，为0表示是16位，为1表示32为；对于栈段来说，此为使B，若为0则使用的是16位的sp寄存器，若为1则使用的32位的esp寄存器。\n- L-为1表示64代码段，为0表示32位代码段。\n- AVL-操作系统可以随意使用，没有具体功能。\n- P-为1表示段存在于内存中（如内存不足时，置换到磁盘），0表示在内存中。\n- DPL-Descriptor Privilege Level，用来表示段的特权级；分别是 0、1、2、3 级特权，数字越小，特权级越大。\n- S和TYPE-S为0表示系统段，为1表示内存段，在S不同值下，用通过TYPE来区分具体的段类型。\n\n\n### 选择子(selector)\n在保护模式下，段寄存器中保存的不再是段基址了，里面保存的内容叫“选择子(selector)”；选择子就像数组下标一样用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组。\n\n\n### A20\n实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以16后再加上段内偏移地址。 实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”访问策略继续可用，CPU采取的做法是将超过1MB的部分自动回绕到0地址。超过1MB多余出来的内存被称为高端内存区HMA。对于只有20位地址线的CPU，不需要任何额外操作便能自动实现地址回绕。\n\nCPU发展到了80286后，虽然地址总线从原来的20位发展到了24位，从而能够访问的内存范围可达到2的24次方，即16MB。但任何时候，Intel都会把兼容放在第一位。80286是第一款具有保护模式的CPU，它在实模式下时，其表现也应该和8086/8088一模一样。按照兼容的要求，80286及后续CPU的实模式应该与8086/8088完全一样，即仍然只使用其中的20条地址线。\n\n在保护模式下，我们要使用80286的24条地址线，如果访问0x100000～0x10FFEF之间的内存，系统将直接访问这块物理内存，并不会像8086/8088那样回绕到 0。 IBM设计了A20Gate来控制是否20位回环。 \n\n如果A20Gate被打开，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存。如果A20 Gate被禁止，当访问0x100000～0x10FFEF之间的地址时，CPU 将采用8086/8088的地址回绕。\n\n### 开启保护模式\n- 配置GDT\n- 打开A20\n- 将CR0的pe置为1\n\n\n### 流水线\n为了提高CPU执行效率，将每一步操作就绪划分成粒度更细的微的操作，然后将这些微操作放到多级流水线上同时去执行。\n\n\n### 开启分页机制\n- 准备好页目录表和页表\n- 将页表地址写入控制寄存器cr3\n- 寄存器cr0的PG位置1\n\n\n### 为啥要多级分页\n每当进程创建时，操作系统都会为进程分配页表，整个操作系统并非只有一个页表。\n在32操作系统中，每个页为4K，每个页表项为4B，虚拟地址空间为4G（2的32次方），那么页表的大小就为4M，当进程创建时，如果单级页表的话，那就要将页表内容全部创建出来，那么每个进程都要4M的页表内存空间，那内存消耗时巨大的。如果是多级页表就可以按需分配。\n\n\n### 操作系统和用户进程\n用户进程必须运行在低特权级，当用户进程访问资源时，需要向操作系统申请，操作系统去操作，然后将结果返回给用户进程，进程可以有无限多个，而操作系统是所有用户进程共享的。可以把操作系统看作服务端，用户进程看作客户端。\n\n\n\n","source":"_posts/OS-Develop-1.md","raw":"---\ntitle: OS Develop 1\ndate: 2022-03-17 13:23:10\ntags: OS\n---\n\n#### 简介\n本章对操作系统开发，涉及的概念做简单讨论，更深入的见后续。\n\n\n### CPU工作方式\nCPU大体分为3部分：控制单元、运算单元和存储单元。\n{% asset_img cpu_workflow.png cpu workflow %}\n\n\n### X86、X64、X86-64、IA-32和IA-64\n- **X86**：这是一种指令集架构家族，最初由英特尔开发。它基于英特尔8086微处理器及其8088变体。8086于1978年推出，作为英特尔8位8080微处理器的完全16位扩展。\n\n- **X64**：这是一个通用术语，指的是x86指令集的64位扩展。它最初由AMD使用，名为AMD64，后来由英特尔实施，名为Intel64。\n\n- **X86-64**：这是x64和AMD64的另一个名称，表示x86指令集的64位扩展。它支持比其前身可能的虚拟内存和物理内存的大量增加，使程序能够在内存中存储更大量的数据。\n\n- **IA-32**：这是x86指令集的一个版本，支持32位计算。它于1985年由英特尔引入，尽管基于30多年前的设计，但它仍然是今天销售的大多数台式机和笔记本电脑的基础。\n\n- **IA-64**：这是一种64位指令集架构，由英特尔开发并于2001年引入，配备了用于企业和高性能计算的Itanium处理器。它与x86架构不向后兼容。\n\n\n### x86寄存器简介\n1，通用寄存器\n通用寄存器可以有多种用途，可以同来保存任何数据；虽说通用，但还是约定了它们的惯用法，比如一般情况下，将cx寄存器用作循环的次数控制，bx用于存储起始地址，这是约定俗成的东西。\n{% asset_img common_registor.png tools shwo %}\n\n2，段寄存器\nx86的段寄存器有6个----CS/DS/ES/SS/FS/GS，均为16位。\nCS：存储代码段的段选择子，代码段保存正在执行的指令。处理器从代码段读取指令时，CS中的段选择子与EIP的值(要执行的下一条指令在代码段中的偏移量)组成逻辑地址。\nDS：数据段寄存器。\nSS：堆栈段寄存器。\nES，FS和GS：给操作系统用的，不用操作系统，用途不一样。\n\n3，状态寄存器\n16位模式下，标志寄存器名称为FLAG，寄存器大小16位。\n32位模式下，标志寄存器的名称为EFLAG，寄存器大小32位。\n64位模式下，为RFLAG，寄存器大小64位。\n\n它的主要作用包括：\n- 存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位\n- 执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。\n- 控制CPU的工作方式，例如IF、VM、TF等标志位。\n\n状态寄存器的各位作用：\n{% asset_img flag_registor.png flag registor %}\n\n\n4，控制寄存器\n控制寄存器决定处理器的操作模式当前执行任务的特性，比如实时模式和保护模式。\n{% asset_img control_registor.jpeg flag registor %}\n\n\n### 内存寻址方式\n分为三大类：\n- 寄存器寻址\n- 立即数寻址\n- 内存寻址\n\n内存寻址用分为：\n- 直接寻址\n- 基址寻址\n- 变址寻址\n- 机址变址寻址\n\n\n### 段寄存器和总线\n数据总线，它的宽度决定数据交换速度。\n控制总线，它的宽度决定可以控制的外设数量。\n地址总线，它决定了内存寻址范围。\n\n段寄存器产生是由于数据总线和地址总线宽度不一致；数据总线宽度，也就是ALU宽度，也是我们常说的16位和32位CPU（也是寄存器的宽度），比如32位的CPU地址总线可以是32位，也可以是36位。\n\n早期，Intel决定让8086访问地址空间为1M，也就是地址总线为20位，但此时数据总线是16位，地址总线宽度大于数据总线，Intel想了一个办法，它加了4个16位的段寄存器(CS,DS,ES,SS)，它们存储的是地址总线高16位的段基址，原来的16地址就变成了段内的偏移量，这样就可以访问到1M内存了。\n\n\n### MMIO和PMIO\n- MMIO\n内存映射方式（并不是映射到主板插的内存条上，是总线访问的内存地址）。\n\n- PMIO\n通过寄存器端口访问。\n\n### 实时模式和保护模式\n- 8086 具有 16 位的段寄存器、指令指针寄存器和通用寄存器（CS、SS、DS、ES、IP、AX、BX、CX、DX、SI、DI、BP、SP），因此，我们称它为 16 位的处理器。尽管它可以访问 1MB 的内存，但是只能分段进行，而且由于只能使用 16 位的段内偏移量，故段的长度最大只能是 64KB。8086 只有一种工作模式，即实模式；当然，这个名称是后来才提出来的。\n\n- 80286 也是一款 16 位的处理器，大部分的寄存器都和 8086 处理器一样。因此，80286 和 8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段；尽管它有 24 根地址线，理论上可以访问 2^24，即 16MB 的内存,但依然只能分成多个段来进行。但是，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16 位保护模式很少为人所知的原因。\n\n- 1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。和 8086/80286 不同，80386 处理器的寄存器是 32 位的，而且拥有 32 根地址线，可以访问 2^32，即 4GB 的内存。80386以及所有后续的 32 位处理器，都兼容实模式，可以运行实模式下的 8086 程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相当于一个非常快速的 8086 处理器。只有在进行一番设置之后，才能运行在保护模式下。在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。32 位保护模式兼容 80286 的 16 位保护模式。\n\n### 实时模式内存布局\n![](/images/real_time_mm.png)\n\n### 虚拟地址空间\n1，虚拟地址空间的大小是怎么决定的\nX86_64体系结构的CPU工作在Long Mode（64位模式）时，虚拟地址的宽度是64位，但是当前的实现都不允许使用2^64字节（16EB）的整个地址空间。在可预见的未来，大多数操作系统和应用程序不需要这么大的地址空间，因此实现如此宽的虚拟地址只会增加地址转换的复杂性和成本，而没有真正的好处。因此，AMD决定在该体系结构的第一个实现中，实际只将虚拟地址的最低有效48位用于地址转换（页表查找）中。\n\n2，小内存如何应对大虚拟地址空间\n物理内存的大小和虚拟地址空间的大小是完全没关系的，虚拟地址空间虽大，但虚拟地址空间的虚拟地址主要用于页表转换，页表能顺利转换的前提是要完成页表填充，页表填充又发生在缺页异常处理中，缺页异常填充页表时首先要向伙伴系统申请内存，而伙伴系统分配的内存都是从物理内存中划分出来的，物理内存的大小决定了它能分配的page数。所以物理内存的大小和虚拟地址空间的大小是没有直接对应关系的。\n\n\n### 全局描述符表（GDT）\n它是由段描述符构成的表。\n段描述符用来描述内存段的属性，它占连续的8个字节。\n{% asset_img gdt.png gdt %}\n\n- G-为0表示“段界限”的单位是字节，为1表示单位为4K。\n- D/B-用来指定段内偏移地址和操作数的大小；对于代码段来说，此位是D，为0表示是16位，为1表示32为；对于栈段来说，此为使B，若为0则使用的是16位的sp寄存器，若为1则使用的32位的esp寄存器。\n- L-为1表示64代码段，为0表示32位代码段。\n- AVL-操作系统可以随意使用，没有具体功能。\n- P-为1表示段存在于内存中（如内存不足时，置换到磁盘），0表示在内存中。\n- DPL-Descriptor Privilege Level，用来表示段的特权级；分别是 0、1、2、3 级特权，数字越小，特权级越大。\n- S和TYPE-S为0表示系统段，为1表示内存段，在S不同值下，用通过TYPE来区分具体的段类型。\n\n\n### 选择子(selector)\n在保护模式下，段寄存器中保存的不再是段基址了，里面保存的内容叫“选择子(selector)”；选择子就像数组下标一样用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组。\n\n\n### A20\n实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以16后再加上段内偏移地址。 实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”访问策略继续可用，CPU采取的做法是将超过1MB的部分自动回绕到0地址。超过1MB多余出来的内存被称为高端内存区HMA。对于只有20位地址线的CPU，不需要任何额外操作便能自动实现地址回绕。\n\nCPU发展到了80286后，虽然地址总线从原来的20位发展到了24位，从而能够访问的内存范围可达到2的24次方，即16MB。但任何时候，Intel都会把兼容放在第一位。80286是第一款具有保护模式的CPU，它在实模式下时，其表现也应该和8086/8088一模一样。按照兼容的要求，80286及后续CPU的实模式应该与8086/8088完全一样，即仍然只使用其中的20条地址线。\n\n在保护模式下，我们要使用80286的24条地址线，如果访问0x100000～0x10FFEF之间的内存，系统将直接访问这块物理内存，并不会像8086/8088那样回绕到 0。 IBM设计了A20Gate来控制是否20位回环。 \n\n如果A20Gate被打开，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存。如果A20 Gate被禁止，当访问0x100000～0x10FFEF之间的地址时，CPU 将采用8086/8088的地址回绕。\n\n### 开启保护模式\n- 配置GDT\n- 打开A20\n- 将CR0的pe置为1\n\n\n### 流水线\n为了提高CPU执行效率，将每一步操作就绪划分成粒度更细的微的操作，然后将这些微操作放到多级流水线上同时去执行。\n\n\n### 开启分页机制\n- 准备好页目录表和页表\n- 将页表地址写入控制寄存器cr3\n- 寄存器cr0的PG位置1\n\n\n### 为啥要多级分页\n每当进程创建时，操作系统都会为进程分配页表，整个操作系统并非只有一个页表。\n在32操作系统中，每个页为4K，每个页表项为4B，虚拟地址空间为4G（2的32次方），那么页表的大小就为4M，当进程创建时，如果单级页表的话，那就要将页表内容全部创建出来，那么每个进程都要4M的页表内存空间，那内存消耗时巨大的。如果是多级页表就可以按需分配。\n\n\n### 操作系统和用户进程\n用户进程必须运行在低特权级，当用户进程访问资源时，需要向操作系统申请，操作系统去操作，然后将结果返回给用户进程，进程可以有无限多个，而操作系统是所有用户进程共享的。可以把操作系统看作服务端，用户进程看作客户端。\n\n\n\n","slug":"OS-Develop-1","published":1,"updated":"2024-03-12T07:18:49.069Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9r000tdk2d4tg502a4","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>本章对操作系统开发，涉及的概念做简单讨论，更深入的见后续。</p>\n<h3 id=\"CPU工作方式\"><a href=\"#CPU工作方式\" class=\"headerlink\" title=\"CPU工作方式\"></a>CPU工作方式</h3><p>CPU大体分为3部分：控制单元、运算单元和存储单元。</p>\n<img src=\"/2022/03/17/OS-Develop-1/cpu_workflow.png\" class=\"\" title=\"cpu workflow\">\n\n\n<h3 id=\"X86、X64、X86-64、IA-32和IA-64\"><a href=\"#X86、X64、X86-64、IA-32和IA-64\" class=\"headerlink\" title=\"X86、X64、X86-64、IA-32和IA-64\"></a>X86、X64、X86-64、IA-32和IA-64</h3><ul>\n<li><p><strong>X86</strong>：这是一种指令集架构家族，最初由英特尔开发。它基于英特尔8086微处理器及其8088变体。8086于1978年推出，作为英特尔8位8080微处理器的完全16位扩展。</p>\n</li>\n<li><p><strong>X64</strong>：这是一个通用术语，指的是x86指令集的64位扩展。它最初由AMD使用，名为AMD64，后来由英特尔实施，名为Intel64。</p>\n</li>\n<li><p><strong>X86-64</strong>：这是x64和AMD64的另一个名称，表示x86指令集的64位扩展。它支持比其前身可能的虚拟内存和物理内存的大量增加，使程序能够在内存中存储更大量的数据。</p>\n</li>\n<li><p><strong>IA-32</strong>：这是x86指令集的一个版本，支持32位计算。它于1985年由英特尔引入，尽管基于30多年前的设计，但它仍然是今天销售的大多数台式机和笔记本电脑的基础。</p>\n</li>\n<li><p><strong>IA-64</strong>：这是一种64位指令集架构，由英特尔开发并于2001年引入，配备了用于企业和高性能计算的Itanium处理器。它与x86架构不向后兼容。</p>\n</li>\n</ul>\n<h3 id=\"x86寄存器简介\"><a href=\"#x86寄存器简介\" class=\"headerlink\" title=\"x86寄存器简介\"></a>x86寄存器简介</h3><p>1，通用寄存器<br>通用寄存器可以有多种用途，可以同来保存任何数据；虽说通用，但还是约定了它们的惯用法，比如一般情况下，将cx寄存器用作循环的次数控制，bx用于存储起始地址，这是约定俗成的东西。</p>\n<img src=\"/2022/03/17/OS-Develop-1/common_registor.png\" class=\"\" title=\"tools shwo\">\n\n<p>2，段寄存器<br>x86的段寄存器有6个—-CS&#x2F;DS&#x2F;ES&#x2F;SS&#x2F;FS&#x2F;GS，均为16位。<br>CS：存储代码段的段选择子，代码段保存正在执行的指令。处理器从代码段读取指令时，CS中的段选择子与EIP的值(要执行的下一条指令在代码段中的偏移量)组成逻辑地址。<br>DS：数据段寄存器。<br>SS：堆栈段寄存器。<br>ES，FS和GS：给操作系统用的，不用操作系统，用途不一样。</p>\n<p>3，状态寄存器<br>16位模式下，标志寄存器名称为FLAG，寄存器大小16位。<br>32位模式下，标志寄存器的名称为EFLAG，寄存器大小32位。<br>64位模式下，为RFLAG，寄存器大小64位。</p>\n<p>它的主要作用包括：</p>\n<ul>\n<li>存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位</li>\n<li>执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。</li>\n<li>控制CPU的工作方式，例如IF、VM、TF等标志位。</li>\n</ul>\n<p>状态寄存器的各位作用：</p>\n<img src=\"/2022/03/17/OS-Develop-1/flag_registor.png\" class=\"\" title=\"flag registor\">\n\n\n<p>4，控制寄存器<br>控制寄存器决定处理器的操作模式当前执行任务的特性，比如实时模式和保护模式。</p>\n<img src=\"/2022/03/17/OS-Develop-1/control_registor.jpeg\" class=\"\" title=\"flag registor\">\n\n\n<h3 id=\"内存寻址方式\"><a href=\"#内存寻址方式\" class=\"headerlink\" title=\"内存寻址方式\"></a>内存寻址方式</h3><p>分为三大类：</p>\n<ul>\n<li>寄存器寻址</li>\n<li>立即数寻址</li>\n<li>内存寻址</li>\n</ul>\n<p>内存寻址用分为：</p>\n<ul>\n<li>直接寻址</li>\n<li>基址寻址</li>\n<li>变址寻址</li>\n<li>机址变址寻址</li>\n</ul>\n<h3 id=\"段寄存器和总线\"><a href=\"#段寄存器和总线\" class=\"headerlink\" title=\"段寄存器和总线\"></a>段寄存器和总线</h3><p>数据总线，它的宽度决定数据交换速度。<br>控制总线，它的宽度决定可以控制的外设数量。<br>地址总线，它决定了内存寻址范围。</p>\n<p>段寄存器产生是由于数据总线和地址总线宽度不一致；数据总线宽度，也就是ALU宽度，也是我们常说的16位和32位CPU（也是寄存器的宽度），比如32位的CPU地址总线可以是32位，也可以是36位。</p>\n<p>早期，Intel决定让8086访问地址空间为1M，也就是地址总线为20位，但此时数据总线是16位，地址总线宽度大于数据总线，Intel想了一个办法，它加了4个16位的段寄存器(CS,DS,ES,SS)，它们存储的是地址总线高16位的段基址，原来的16地址就变成了段内的偏移量，这样就可以访问到1M内存了。</p>\n<h3 id=\"MMIO和PMIO\"><a href=\"#MMIO和PMIO\" class=\"headerlink\" title=\"MMIO和PMIO\"></a>MMIO和PMIO</h3><ul>\n<li><p>MMIO<br>内存映射方式（并不是映射到主板插的内存条上，是总线访问的内存地址）。</p>\n</li>\n<li><p>PMIO<br>通过寄存器端口访问。</p>\n</li>\n</ul>\n<h3 id=\"实时模式和保护模式\"><a href=\"#实时模式和保护模式\" class=\"headerlink\" title=\"实时模式和保护模式\"></a>实时模式和保护模式</h3><ul>\n<li><p>8086 具有 16 位的段寄存器、指令指针寄存器和通用寄存器（CS、SS、DS、ES、IP、AX、BX、CX、DX、SI、DI、BP、SP），因此，我们称它为 16 位的处理器。尽管它可以访问 1MB 的内存，但是只能分段进行，而且由于只能使用 16 位的段内偏移量，故段的长度最大只能是 64KB。8086 只有一种工作模式，即实模式；当然，这个名称是后来才提出来的。</p>\n</li>\n<li><p>80286 也是一款 16 位的处理器，大部分的寄存器都和 8086 处理器一样。因此，80286 和 8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段；尽管它有 24 根地址线，理论上可以访问 2^24，即 16MB 的内存,但依然只能分成多个段来进行。但是，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16 位保护模式很少为人所知的原因。</p>\n</li>\n<li><p>1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。和 8086&#x2F;80286 不同，80386 处理器的寄存器是 32 位的，而且拥有 32 根地址线，可以访问 2^32，即 4GB 的内存。80386以及所有后续的 32 位处理器，都兼容实模式，可以运行实模式下的 8086 程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相当于一个非常快速的 8086 处理器。只有在进行一番设置之后，才能运行在保护模式下。在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。32 位保护模式兼容 80286 的 16 位保护模式。</p>\n</li>\n</ul>\n<h3 id=\"实时模式内存布局\"><a href=\"#实时模式内存布局\" class=\"headerlink\" title=\"实时模式内存布局\"></a>实时模式内存布局</h3><p><img src=\"/images/real_time_mm.png\"></p>\n<h3 id=\"虚拟地址空间\"><a href=\"#虚拟地址空间\" class=\"headerlink\" title=\"虚拟地址空间\"></a>虚拟地址空间</h3><p>1，虚拟地址空间的大小是怎么决定的<br>X86_64体系结构的CPU工作在Long Mode（64位模式）时，虚拟地址的宽度是64位，但是当前的实现都不允许使用2^64字节（16EB）的整个地址空间。在可预见的未来，大多数操作系统和应用程序不需要这么大的地址空间，因此实现如此宽的虚拟地址只会增加地址转换的复杂性和成本，而没有真正的好处。因此，AMD决定在该体系结构的第一个实现中，实际只将虚拟地址的最低有效48位用于地址转换（页表查找）中。</p>\n<p>2，小内存如何应对大虚拟地址空间<br>物理内存的大小和虚拟地址空间的大小是完全没关系的，虚拟地址空间虽大，但虚拟地址空间的虚拟地址主要用于页表转换，页表能顺利转换的前提是要完成页表填充，页表填充又发生在缺页异常处理中，缺页异常填充页表时首先要向伙伴系统申请内存，而伙伴系统分配的内存都是从物理内存中划分出来的，物理内存的大小决定了它能分配的page数。所以物理内存的大小和虚拟地址空间的大小是没有直接对应关系的。</p>\n<h3 id=\"全局描述符表（GDT）\"><a href=\"#全局描述符表（GDT）\" class=\"headerlink\" title=\"全局描述符表（GDT）\"></a>全局描述符表（GDT）</h3><p>它是由段描述符构成的表。<br>段描述符用来描述内存段的属性，它占连续的8个字节。</p>\n<img src=\"/2022/03/17/OS-Develop-1/gdt.png\" class=\"\" title=\"gdt\">\n\n<ul>\n<li>G-为0表示“段界限”的单位是字节，为1表示单位为4K。</li>\n<li>D&#x2F;B-用来指定段内偏移地址和操作数的大小；对于代码段来说，此位是D，为0表示是16位，为1表示32为；对于栈段来说，此为使B，若为0则使用的是16位的sp寄存器，若为1则使用的32位的esp寄存器。</li>\n<li>L-为1表示64代码段，为0表示32位代码段。</li>\n<li>AVL-操作系统可以随意使用，没有具体功能。</li>\n<li>P-为1表示段存在于内存中（如内存不足时，置换到磁盘），0表示在内存中。</li>\n<li>DPL-Descriptor Privilege Level，用来表示段的特权级；分别是 0、1、2、3 级特权，数字越小，特权级越大。</li>\n<li>S和TYPE-S为0表示系统段，为1表示内存段，在S不同值下，用通过TYPE来区分具体的段类型。</li>\n</ul>\n<h3 id=\"选择子-selector\"><a href=\"#选择子-selector\" class=\"headerlink\" title=\"选择子(selector)\"></a>选择子(selector)</h3><p>在保护模式下，段寄存器中保存的不再是段基址了，里面保存的内容叫“选择子(selector)”；选择子就像数组下标一样用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组。</p>\n<h3 id=\"A20\"><a href=\"#A20\" class=\"headerlink\" title=\"A20\"></a>A20</h3><p>实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以16后再加上段内偏移地址。 实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”访问策略继续可用，CPU采取的做法是将超过1MB的部分自动回绕到0地址。超过1MB多余出来的内存被称为高端内存区HMA。对于只有20位地址线的CPU，不需要任何额外操作便能自动实现地址回绕。</p>\n<p>CPU发展到了80286后，虽然地址总线从原来的20位发展到了24位，从而能够访问的内存范围可达到2的24次方，即16MB。但任何时候，Intel都会把兼容放在第一位。80286是第一款具有保护模式的CPU，它在实模式下时，其表现也应该和8086&#x2F;8088一模一样。按照兼容的要求，80286及后续CPU的实模式应该与8086&#x2F;8088完全一样，即仍然只使用其中的20条地址线。</p>\n<p>在保护模式下，我们要使用80286的24条地址线，如果访问0x100000～0x10FFEF之间的内存，系统将直接访问这块物理内存，并不会像8086&#x2F;8088那样回绕到 0。 IBM设计了A20Gate来控制是否20位回环。 </p>\n<p>如果A20Gate被打开，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存。如果A20 Gate被禁止，当访问0x100000～0x10FFEF之间的地址时，CPU 将采用8086&#x2F;8088的地址回绕。</p>\n<h3 id=\"开启保护模式\"><a href=\"#开启保护模式\" class=\"headerlink\" title=\"开启保护模式\"></a>开启保护模式</h3><ul>\n<li>配置GDT</li>\n<li>打开A20</li>\n<li>将CR0的pe置为1</li>\n</ul>\n<h3 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h3><p>为了提高CPU执行效率，将每一步操作就绪划分成粒度更细的微的操作，然后将这些微操作放到多级流水线上同时去执行。</p>\n<h3 id=\"开启分页机制\"><a href=\"#开启分页机制\" class=\"headerlink\" title=\"开启分页机制\"></a>开启分页机制</h3><ul>\n<li>准备好页目录表和页表</li>\n<li>将页表地址写入控制寄存器cr3</li>\n<li>寄存器cr0的PG位置1</li>\n</ul>\n<h3 id=\"为啥要多级分页\"><a href=\"#为啥要多级分页\" class=\"headerlink\" title=\"为啥要多级分页\"></a>为啥要多级分页</h3><p>每当进程创建时，操作系统都会为进程分配页表，整个操作系统并非只有一个页表。<br>在32操作系统中，每个页为4K，每个页表项为4B，虚拟地址空间为4G（2的32次方），那么页表的大小就为4M，当进程创建时，如果单级页表的话，那就要将页表内容全部创建出来，那么每个进程都要4M的页表内存空间，那内存消耗时巨大的。如果是多级页表就可以按需分配。</p>\n<h3 id=\"操作系统和用户进程\"><a href=\"#操作系统和用户进程\" class=\"headerlink\" title=\"操作系统和用户进程\"></a>操作系统和用户进程</h3><p>用户进程必须运行在低特权级，当用户进程访问资源时，需要向操作系统申请，操作系统去操作，然后将结果返回给用户进程，进程可以有无限多个，而操作系统是所有用户进程共享的。可以把操作系统看作服务端，用户进程看作客户端。</p>\n","excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>本章对操作系统开发，涉及的概念做简单讨论，更深入的见后续。</p>\n<h3 id=\"CPU工作方式\"><a href=\"#CPU工作方式\" class=\"headerlink\" title=\"CPU工作方式\"></a>CPU工作方式</h3><p>CPU大体分为3部分：控制单元、运算单元和存储单元。</p>\n<img src=\"/2022/03/17/OS-Develop-1/cpu_workflow.png\" class=\"\" title=\"cpu workflow\">\n\n\n<h3 id=\"X86、X64、X86-64、IA-32和IA-64\"><a href=\"#X86、X64、X86-64、IA-32和IA-64\" class=\"headerlink\" title=\"X86、X64、X86-64、IA-32和IA-64\"></a>X86、X64、X86-64、IA-32和IA-64</h3><ul>\n<li><p><strong>X86</strong>：这是一种指令集架构家族，最初由英特尔开发。它基于英特尔8086微处理器及其8088变体。8086于1978年推出，作为英特尔8位8080微处理器的完全16位扩展。</p>\n</li>\n<li><p><strong>X64</strong>：这是一个通用术语，指的是x86指令集的64位扩展。它最初由AMD使用，名为AMD64，后来由英特尔实施，名为Intel64。</p>\n</li>\n<li><p><strong>X86-64</strong>：这是x64和AMD64的另一个名称，表示x86指令集的64位扩展。它支持比其前身可能的虚拟内存和物理内存的大量增加，使程序能够在内存中存储更大量的数据。</p>\n</li>\n<li><p><strong>IA-32</strong>：这是x86指令集的一个版本，支持32位计算。它于1985年由英特尔引入，尽管基于30多年前的设计，但它仍然是今天销售的大多数台式机和笔记本电脑的基础。</p>\n</li>\n<li><p><strong>IA-64</strong>：这是一种64位指令集架构，由英特尔开发并于2001年引入，配备了用于企业和高性能计算的Itanium处理器。它与x86架构不向后兼容。</p>\n</li>\n</ul>\n<h3 id=\"x86寄存器简介\"><a href=\"#x86寄存器简介\" class=\"headerlink\" title=\"x86寄存器简介\"></a>x86寄存器简介</h3><p>1，通用寄存器<br>通用寄存器可以有多种用途，可以同来保存任何数据；虽说通用，但还是约定了它们的惯用法，比如一般情况下，将cx寄存器用作循环的次数控制，bx用于存储起始地址，这是约定俗成的东西。</p>\n<img src=\"/2022/03/17/OS-Develop-1/common_registor.png\" class=\"\" title=\"tools shwo\">\n\n<p>2，段寄存器<br>x86的段寄存器有6个—-CS&#x2F;DS&#x2F;ES&#x2F;SS&#x2F;FS&#x2F;GS，均为16位。<br>CS：存储代码段的段选择子，代码段保存正在执行的指令。处理器从代码段读取指令时，CS中的段选择子与EIP的值(要执行的下一条指令在代码段中的偏移量)组成逻辑地址。<br>DS：数据段寄存器。<br>SS：堆栈段寄存器。<br>ES，FS和GS：给操作系统用的，不用操作系统，用途不一样。</p>\n<p>3，状态寄存器<br>16位模式下，标志寄存器名称为FLAG，寄存器大小16位。<br>32位模式下，标志寄存器的名称为EFLAG，寄存器大小32位。<br>64位模式下，为RFLAG，寄存器大小64位。</p>\n<p>它的主要作用包括：</p>\n<ul>\n<li>存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位</li>\n<li>执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。</li>\n<li>控制CPU的工作方式，例如IF、VM、TF等标志位。</li>\n</ul>\n<p>状态寄存器的各位作用：</p>\n<img src=\"/2022/03/17/OS-Develop-1/flag_registor.png\" class=\"\" title=\"flag registor\">\n\n\n<p>4，控制寄存器<br>控制寄存器决定处理器的操作模式当前执行任务的特性，比如实时模式和保护模式。</p>\n<img src=\"/2022/03/17/OS-Develop-1/control_registor.jpeg\" class=\"\" title=\"flag registor\">\n\n\n<h3 id=\"内存寻址方式\"><a href=\"#内存寻址方式\" class=\"headerlink\" title=\"内存寻址方式\"></a>内存寻址方式</h3><p>分为三大类：</p>\n<ul>\n<li>寄存器寻址</li>\n<li>立即数寻址</li>\n<li>内存寻址</li>\n</ul>\n<p>内存寻址用分为：</p>\n<ul>\n<li>直接寻址</li>\n<li>基址寻址</li>\n<li>变址寻址</li>\n<li>机址变址寻址</li>\n</ul>\n<h3 id=\"段寄存器和总线\"><a href=\"#段寄存器和总线\" class=\"headerlink\" title=\"段寄存器和总线\"></a>段寄存器和总线</h3><p>数据总线，它的宽度决定数据交换速度。<br>控制总线，它的宽度决定可以控制的外设数量。<br>地址总线，它决定了内存寻址范围。</p>\n<p>段寄存器产生是由于数据总线和地址总线宽度不一致；数据总线宽度，也就是ALU宽度，也是我们常说的16位和32位CPU（也是寄存器的宽度），比如32位的CPU地址总线可以是32位，也可以是36位。</p>\n<p>早期，Intel决定让8086访问地址空间为1M，也就是地址总线为20位，但此时数据总线是16位，地址总线宽度大于数据总线，Intel想了一个办法，它加了4个16位的段寄存器(CS,DS,ES,SS)，它们存储的是地址总线高16位的段基址，原来的16地址就变成了段内的偏移量，这样就可以访问到1M内存了。</p>\n<h3 id=\"MMIO和PMIO\"><a href=\"#MMIO和PMIO\" class=\"headerlink\" title=\"MMIO和PMIO\"></a>MMIO和PMIO</h3><ul>\n<li><p>MMIO<br>内存映射方式（并不是映射到主板插的内存条上，是总线访问的内存地址）。</p>\n</li>\n<li><p>PMIO<br>通过寄存器端口访问。</p>\n</li>\n</ul>\n<h3 id=\"实时模式和保护模式\"><a href=\"#实时模式和保护模式\" class=\"headerlink\" title=\"实时模式和保护模式\"></a>实时模式和保护模式</h3><ul>\n<li><p>8086 具有 16 位的段寄存器、指令指针寄存器和通用寄存器（CS、SS、DS、ES、IP、AX、BX、CX、DX、SI、DI、BP、SP），因此，我们称它为 16 位的处理器。尽管它可以访问 1MB 的内存，但是只能分段进行，而且由于只能使用 16 位的段内偏移量，故段的长度最大只能是 64KB。8086 只有一种工作模式，即实模式；当然，这个名称是后来才提出来的。</p>\n</li>\n<li><p>80286 也是一款 16 位的处理器，大部分的寄存器都和 8086 处理器一样。因此，80286 和 8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段；尽管它有 24 根地址线，理论上可以访问 2^24，即 16MB 的内存,但依然只能分成多个段来进行。但是，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16 位保护模式很少为人所知的原因。</p>\n</li>\n<li><p>1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。和 8086&#x2F;80286 不同，80386 处理器的寄存器是 32 位的，而且拥有 32 根地址线，可以访问 2^32，即 4GB 的内存。80386以及所有后续的 32 位处理器，都兼容实模式，可以运行实模式下的 8086 程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相当于一个非常快速的 8086 处理器。只有在进行一番设置之后，才能运行在保护模式下。在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。32 位保护模式兼容 80286 的 16 位保护模式。</p>\n</li>\n</ul>\n<h3 id=\"实时模式内存布局\"><a href=\"#实时模式内存布局\" class=\"headerlink\" title=\"实时模式内存布局\"></a>实时模式内存布局</h3><p><img src=\"/images/real_time_mm.png\"></p>\n<h3 id=\"虚拟地址空间\"><a href=\"#虚拟地址空间\" class=\"headerlink\" title=\"虚拟地址空间\"></a>虚拟地址空间</h3><p>1，虚拟地址空间的大小是怎么决定的<br>X86_64体系结构的CPU工作在Long Mode（64位模式）时，虚拟地址的宽度是64位，但是当前的实现都不允许使用2^64字节（16EB）的整个地址空间。在可预见的未来，大多数操作系统和应用程序不需要这么大的地址空间，因此实现如此宽的虚拟地址只会增加地址转换的复杂性和成本，而没有真正的好处。因此，AMD决定在该体系结构的第一个实现中，实际只将虚拟地址的最低有效48位用于地址转换（页表查找）中。</p>\n<p>2，小内存如何应对大虚拟地址空间<br>物理内存的大小和虚拟地址空间的大小是完全没关系的，虚拟地址空间虽大，但虚拟地址空间的虚拟地址主要用于页表转换，页表能顺利转换的前提是要完成页表填充，页表填充又发生在缺页异常处理中，缺页异常填充页表时首先要向伙伴系统申请内存，而伙伴系统分配的内存都是从物理内存中划分出来的，物理内存的大小决定了它能分配的page数。所以物理内存的大小和虚拟地址空间的大小是没有直接对应关系的。</p>\n<h3 id=\"全局描述符表（GDT）\"><a href=\"#全局描述符表（GDT）\" class=\"headerlink\" title=\"全局描述符表（GDT）\"></a>全局描述符表（GDT）</h3><p>它是由段描述符构成的表。<br>段描述符用来描述内存段的属性，它占连续的8个字节。</p>\n<img src=\"/2022/03/17/OS-Develop-1/gdt.png\" class=\"\" title=\"gdt\">\n\n<ul>\n<li>G-为0表示“段界限”的单位是字节，为1表示单位为4K。</li>\n<li>D&#x2F;B-用来指定段内偏移地址和操作数的大小；对于代码段来说，此位是D，为0表示是16位，为1表示32为；对于栈段来说，此为使B，若为0则使用的是16位的sp寄存器，若为1则使用的32位的esp寄存器。</li>\n<li>L-为1表示64代码段，为0表示32位代码段。</li>\n<li>AVL-操作系统可以随意使用，没有具体功能。</li>\n<li>P-为1表示段存在于内存中（如内存不足时，置换到磁盘），0表示在内存中。</li>\n<li>DPL-Descriptor Privilege Level，用来表示段的特权级；分别是 0、1、2、3 级特权，数字越小，特权级越大。</li>\n<li>S和TYPE-S为0表示系统段，为1表示内存段，在S不同值下，用通过TYPE来区分具体的段类型。</li>\n</ul>\n<h3 id=\"选择子-selector\"><a href=\"#选择子-selector\" class=\"headerlink\" title=\"选择子(selector)\"></a>选择子(selector)</h3><p>在保护模式下，段寄存器中保存的不再是段基址了，里面保存的内容叫“选择子(selector)”；选择子就像数组下标一样用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组。</p>\n<h3 id=\"A20\"><a href=\"#A20\" class=\"headerlink\" title=\"A20\"></a>A20</h3><p>实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以16后再加上段内偏移地址。 实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”访问策略继续可用，CPU采取的做法是将超过1MB的部分自动回绕到0地址。超过1MB多余出来的内存被称为高端内存区HMA。对于只有20位地址线的CPU，不需要任何额外操作便能自动实现地址回绕。</p>\n<p>CPU发展到了80286后，虽然地址总线从原来的20位发展到了24位，从而能够访问的内存范围可达到2的24次方，即16MB。但任何时候，Intel都会把兼容放在第一位。80286是第一款具有保护模式的CPU，它在实模式下时，其表现也应该和8086&#x2F;8088一模一样。按照兼容的要求，80286及后续CPU的实模式应该与8086&#x2F;8088完全一样，即仍然只使用其中的20条地址线。</p>\n<p>在保护模式下，我们要使用80286的24条地址线，如果访问0x100000～0x10FFEF之间的内存，系统将直接访问这块物理内存，并不会像8086&#x2F;8088那样回绕到 0。 IBM设计了A20Gate来控制是否20位回环。 </p>\n<p>如果A20Gate被打开，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存。如果A20 Gate被禁止，当访问0x100000～0x10FFEF之间的地址时，CPU 将采用8086&#x2F;8088的地址回绕。</p>\n<h3 id=\"开启保护模式\"><a href=\"#开启保护模式\" class=\"headerlink\" title=\"开启保护模式\"></a>开启保护模式</h3><ul>\n<li>配置GDT</li>\n<li>打开A20</li>\n<li>将CR0的pe置为1</li>\n</ul>\n<h3 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h3><p>为了提高CPU执行效率，将每一步操作就绪划分成粒度更细的微的操作，然后将这些微操作放到多级流水线上同时去执行。</p>\n<h3 id=\"开启分页机制\"><a href=\"#开启分页机制\" class=\"headerlink\" title=\"开启分页机制\"></a>开启分页机制</h3><ul>\n<li>准备好页目录表和页表</li>\n<li>将页表地址写入控制寄存器cr3</li>\n<li>寄存器cr0的PG位置1</li>\n</ul>\n<h3 id=\"为啥要多级分页\"><a href=\"#为啥要多级分页\" class=\"headerlink\" title=\"为啥要多级分页\"></a>为啥要多级分页</h3><p>每当进程创建时，操作系统都会为进程分配页表，整个操作系统并非只有一个页表。<br>在32操作系统中，每个页为4K，每个页表项为4B，虚拟地址空间为4G（2的32次方），那么页表的大小就为4M，当进程创建时，如果单级页表的话，那就要将页表内容全部创建出来，那么每个进程都要4M的页表内存空间，那内存消耗时巨大的。如果是多级页表就可以按需分配。</p>\n<h3 id=\"操作系统和用户进程\"><a href=\"#操作系统和用户进程\" class=\"headerlink\" title=\"操作系统和用户进程\"></a>操作系统和用户进程</h3><p>用户进程必须运行在低特权级，当用户进程访问资源时，需要向操作系统申请，操作系统去操作，然后将结果返回给用户进程，进程可以有无限多个，而操作系统是所有用户进程共享的。可以把操作系统看作服务端，用户进程看作客户端。</p>\n"},{"title":"OS Develop 2","date":"2022-03-22T12:10:06.000Z","_content":"\n### 简介\n本章介绍汇编语言。\n\n\n### 标号\n标号是充当指令或数据位置标记的标识符。\n- 数据标号\n{% blockquote %}\ncount DW 100 ;定义一个名为count的变量a\n{% endblockquote %}\n\n- 代码标号\n  以冒号结尾，表示一个位置，可以用于跳转。\n{% blockquote %}\nloop:\n\tjmp loop\n{% endblockquote %}\n\n### 伪指令\n伪指令不是真正的指令，它是由NASM的编译器提供支持，伪指令在编译的时候执行。\n- Dx族\n- Resx族\n- equ\n- times\n- vstar & org\n- incbin\n\n### 7种数据Size\n- byte ： 8 位\n- word ： 16 位\n- dword ： 32 位\n- qword ： 64 位\n- tword ： 80 位\n- oword ： 128 位\n- yword ： 256 位\n\n### Dx族\nDx族用来在内存中，顺序定义初始化数据。\nnasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。\n- db : define byte\n- dw ：define word\n- dd ：define doubleword\n- dq ：define quadword\n- dt ：define tword\n- do ：define oword\n- dy ：define yword\n\n例如：\n{% blockquote %}\ndb    0x55                ; just the byte 0x55\ndb    0x55,0x56,0x57      ; three bytes in succession\ndb    'a',0x55            ; character constants are OK\ndb    'hello',13,10,'$'   ; so are string constants\ndw    0x1234              ; 0x34 0x12\ndw    'a'                 ; 0x61 0x00 (it's just a number)\ndw    'ab'                ; 0x61 0x62 (character constant)\ndw    'abc'               ; 0x61 0x62 0x63 0x00 (string)\ndd    0x12345678          ; 0x78 0x56 0x34 0x12\ndd    1.234567e20         ; floating-point constant\ndq    0x123456789abcdef0  ; eight byte constant\ndq    1.234567e20         ; double-precision float\ndt    1.234567e20         ; extended-precision float\n{% endblockquote %}\n\n### Resx族\n这类伪指令，用来定义非初始化数据，非初始化数据存放在bass section中。\n- resb ：reserve byte\n- resw ：reserve word\n- resd ：reserve doubword\n- resq ：reserve quadword\n- rest ：reserve tword\n- reso ：reserve oword\n- resy ：reserve yword\n\n例如：\n{% blockquote %}\nbuffer:         resb    64              ; reserve 64 bytes\nwordvar:        resw    1               ; reserve a word\nrealarray       resq    10              ; array of ten reals\nymmval:         resy    1               ; one YMM register\n{% endblockquote %}\n\n\n### 变量定义\n【变量名】 变量类型  表达式\n例如：\n{% blockquote %}\na db 1,2,3,4,5\ndb 7,8,9,10 ;非变量定义，只定义数据\nb dw 123,123,123\nc db 'hello, world!'\n{% endblockquote %}\n\n上面定义的数据都是顺序存放在内存中的，所以虽然第二行的数据没有定义名字，但是因为他紧跟在a 数组之后 b数组之前，所以使用a+5,或者 b-1 也是可以访问的，只是需要注意的是数据类型和 大端小端的问题。\n声明的变量代表后面数据的地址，例如c是后面字符串的首地址，如果要使用，需要用中括号：\n\n{% blockquote %}\nmov ax, [c]\n{% endblockquote %}\n\n### equ\n它的作用和#define相同，它并不占用内存，在编译之后，它将替换被调用的地方，例如：\n{% blockquote %}\nnum equ 110\nmov ax, num\nmov bx, num\nmov cx, num\n{% endblockquote %}\n\n编译后：\n{% blockquote %}\nmov ax, 110\nmov bx, 110\nmov cx, 110\n{% endblockquote %}\n\n### \\$和\\$$\n\\$表示当前行的汇编地址。\n\\$$表示当前程序的起始汇编地址。\n\n### times\n后面指令重复次数。\n{% blockquote %}\nbuffer: db 'hello, world'\ntimes 64-$+buffer db '' ;补齐64字节\n{% endblockquote %}\n\n### incbin\n包含binary文件。例如\n{% blockquote %}\nncbin “file.dat” ; include the whole file  \nincbin “file.dat”,1024 ; skip the first 1024 bytes  \nincbin “file.dat”,1024,512 ; skip the first 1024, and  \n; actually include at most 512\n{% endblockquote %}\n\n### vstart & org\n程序的加载位置是由加载它的一方来决定的(因为加载后，加载方需要去访问被加载方，去哪里访问，这个是加载方来确定的)。vstart和org是告诉编译器，将后面的所有数据(指令和变量)的地址，加上一个偏移量。\n编译器以相对于文件开头偏移来编址的好处是利于重定位。程序内的地址是从0开始算的，当程序被加载到内存的某个地址(不一定是0)后，就需要用vstart或org来指定偏移量，这个偏移量也就是加载到内存的地址。\n\n\n### mov\n格式：\n{% blockquote %}\nmov 位宽 目的操作数，源操作数\n{% endblockquote %}\n\n目的操作数必需是一个容器，如内存单元、寄存器；源操作数可以是一个立即数，也可以是一个容器。\n\n举例：\n{% blockquote %}\nmov byte [0x00],'2'\n{% endblockquote %}\n\n### loop\nLoop指令需要和cx寄存器配合使用, 用于循环操作, 类似于高级语言中的for, while等。\ncx存放的是循环次数，循环一次，cx中的值减1，当cx中的值大于0时，执行loop循环。\n\n{% blockquote %}\n  mov cx, 11\ns:  \n  add ax, ax\n  loop s\n{% endblockquote %}\n\n### jmp\njmp 是无条件转移指令，无条件转移指令可转到内存中任何程序段，它可以只修改IP，也可以同时修改CS和IP。\n1，短程转移\n指令格式：JMP SHORT OPRD\n语法格式：JMP 地址标号 ；（IP）=（IP）+8位位移量\n指令功能：OPRD为转移地址的标号，指令中的SHORT规定了OPRD为有符号的8位二进制数，OPRD为转移地址的偏移量。该指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，从而实现程序的转移。转移的目标地址OPRD在指令中可以直接使用标号地址，但要求转移的目标地址的范围只能在JMP指令所处地址的－128～+127字节范围之内，如超出该范围，汇编时出错。\n\n2，近程转移\n指令格式：JMP NEAR PTR OPRD\n语法格式：JMP 地址标号 ；（IP）=（IP）+16位位移量\n指令功能：与短程转移的功能和要求相同，不同之处是近程转移的OPRD为有符号的16位二进制数，指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，转移的目标地址的范围只能在JMP指令所处地址的－32768～+32767字节范围之内，如超出该范围，汇编时出错。使用该指令时NEAR可省略。\n\n3，段间转移\n指令格式：JMP FAR PTR OPRD\n语法格式：JMP 地址标号 ；（IP）= 新的偏移地址, ；（CS）= 新的代码段地址\n指令功能：指令中用FAR PTR规定了该指令为段间的转移，OPRD为目的地址的标号，目的地址与JMP指令所在地址不在同一段内。执行该指令时要修改CS和IP的内容，将OPRD所在段的段地址送CS中，OPRD的段内偏移地址送IP中。\n\n4，段内间转移\n指令格式：JMP WORD PTR OPRD\n语法格式：JMP reg16/mem ；（IP）= 新的偏移地址\n指令功能：与短程转移的功能和要求相同，不同之处是段内间接转移的OPRD 可以是除立即数外的任何寄存或存储器寻址方式，转移的目标地址由OPRD的内容确定。\n\n5，段间间接转移\n指令格式：JMP DWORD PTR OPRD\n语法格式：JMP mem32\n指令功能：指令中用DWORD PTR规定了该指令为段间间接转移，OPRD只能是存储器寻址方式。执行该指令时将寻址到的内存单元的第一个字送入IP中，第二个字送入CS中。\n\n### 条件转移\n{% asset_img jmp_condition.png flag registor %}\n\n### call & ret\n在高级语言中，常有主程序调用其他子程序，子程序还可以调用子程序。\ncall指令可以实现调用一个子程序，在子程序里使用ret指令结束子程序的执行并返回主程序（类比C语言中的main函数调用cube函数进行理解），主程序继续往下执行。\n\n{% blockquote %}\nmov ax,0\ncall s     ;s是标号，执行call后，执行s标号所在的子程序\nmov ax,4c00h\nint 21h\n\ns:add ax,1   ;标号所在子程序\n  mov bx,10\n  ret        ;子程序执行完后，返回主程序\n{% endblockquote %}\n\n### push & pop\npush和pop是用来操作栈的2个指令；push将一个寄存器中的数据入栈，pop出栈用一个寄存器接收数据；相关的寄存器`SS:SP`。\n举例：\nmov ax 123H\npush ax 的执行，由以下两步完成。\n(1) SP = SP - 2, SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；\n(2) 将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。\n\n\n### int\nint指令是X86汇编语言中最重要的指令之一。它的作用是引发中断，调用“中断例程”（interrupt routine）\n\n指令格式：\n{% blockquote %}\nint n ;n是中端号\n{% endblockquote %}\n\n指令执行过程：\n{% blockquote %}\n1，取中断类型码n；\n2，标志寄存器入栈（pushf），IF=0，TF=0（重置中断标志位）；\n3，CS、IP入栈；\n4，查中断向量表， (IP)=(n\\*4)，(CS)=(n\\*4+2)。\n{% endblockquote %}\n\n","source":"_posts/OS-Develop-2.md","raw":"---\ntitle: OS Develop 2\ndate: 2022-03-22 20:10:06\ntags: OS\n---\n\n### 简介\n本章介绍汇编语言。\n\n\n### 标号\n标号是充当指令或数据位置标记的标识符。\n- 数据标号\n{% blockquote %}\ncount DW 100 ;定义一个名为count的变量a\n{% endblockquote %}\n\n- 代码标号\n  以冒号结尾，表示一个位置，可以用于跳转。\n{% blockquote %}\nloop:\n\tjmp loop\n{% endblockquote %}\n\n### 伪指令\n伪指令不是真正的指令，它是由NASM的编译器提供支持，伪指令在编译的时候执行。\n- Dx族\n- Resx族\n- equ\n- times\n- vstar & org\n- incbin\n\n### 7种数据Size\n- byte ： 8 位\n- word ： 16 位\n- dword ： 32 位\n- qword ： 64 位\n- tword ： 80 位\n- oword ： 128 位\n- yword ： 256 位\n\n### Dx族\nDx族用来在内存中，顺序定义初始化数据。\nnasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。\n- db : define byte\n- dw ：define word\n- dd ：define doubleword\n- dq ：define quadword\n- dt ：define tword\n- do ：define oword\n- dy ：define yword\n\n例如：\n{% blockquote %}\ndb    0x55                ; just the byte 0x55\ndb    0x55,0x56,0x57      ; three bytes in succession\ndb    'a',0x55            ; character constants are OK\ndb    'hello',13,10,'$'   ; so are string constants\ndw    0x1234              ; 0x34 0x12\ndw    'a'                 ; 0x61 0x00 (it's just a number)\ndw    'ab'                ; 0x61 0x62 (character constant)\ndw    'abc'               ; 0x61 0x62 0x63 0x00 (string)\ndd    0x12345678          ; 0x78 0x56 0x34 0x12\ndd    1.234567e20         ; floating-point constant\ndq    0x123456789abcdef0  ; eight byte constant\ndq    1.234567e20         ; double-precision float\ndt    1.234567e20         ; extended-precision float\n{% endblockquote %}\n\n### Resx族\n这类伪指令，用来定义非初始化数据，非初始化数据存放在bass section中。\n- resb ：reserve byte\n- resw ：reserve word\n- resd ：reserve doubword\n- resq ：reserve quadword\n- rest ：reserve tword\n- reso ：reserve oword\n- resy ：reserve yword\n\n例如：\n{% blockquote %}\nbuffer:         resb    64              ; reserve 64 bytes\nwordvar:        resw    1               ; reserve a word\nrealarray       resq    10              ; array of ten reals\nymmval:         resy    1               ; one YMM register\n{% endblockquote %}\n\n\n### 变量定义\n【变量名】 变量类型  表达式\n例如：\n{% blockquote %}\na db 1,2,3,4,5\ndb 7,8,9,10 ;非变量定义，只定义数据\nb dw 123,123,123\nc db 'hello, world!'\n{% endblockquote %}\n\n上面定义的数据都是顺序存放在内存中的，所以虽然第二行的数据没有定义名字，但是因为他紧跟在a 数组之后 b数组之前，所以使用a+5,或者 b-1 也是可以访问的，只是需要注意的是数据类型和 大端小端的问题。\n声明的变量代表后面数据的地址，例如c是后面字符串的首地址，如果要使用，需要用中括号：\n\n{% blockquote %}\nmov ax, [c]\n{% endblockquote %}\n\n### equ\n它的作用和#define相同，它并不占用内存，在编译之后，它将替换被调用的地方，例如：\n{% blockquote %}\nnum equ 110\nmov ax, num\nmov bx, num\nmov cx, num\n{% endblockquote %}\n\n编译后：\n{% blockquote %}\nmov ax, 110\nmov bx, 110\nmov cx, 110\n{% endblockquote %}\n\n### \\$和\\$$\n\\$表示当前行的汇编地址。\n\\$$表示当前程序的起始汇编地址。\n\n### times\n后面指令重复次数。\n{% blockquote %}\nbuffer: db 'hello, world'\ntimes 64-$+buffer db '' ;补齐64字节\n{% endblockquote %}\n\n### incbin\n包含binary文件。例如\n{% blockquote %}\nncbin “file.dat” ; include the whole file  \nincbin “file.dat”,1024 ; skip the first 1024 bytes  \nincbin “file.dat”,1024,512 ; skip the first 1024, and  \n; actually include at most 512\n{% endblockquote %}\n\n### vstart & org\n程序的加载位置是由加载它的一方来决定的(因为加载后，加载方需要去访问被加载方，去哪里访问，这个是加载方来确定的)。vstart和org是告诉编译器，将后面的所有数据(指令和变量)的地址，加上一个偏移量。\n编译器以相对于文件开头偏移来编址的好处是利于重定位。程序内的地址是从0开始算的，当程序被加载到内存的某个地址(不一定是0)后，就需要用vstart或org来指定偏移量，这个偏移量也就是加载到内存的地址。\n\n\n### mov\n格式：\n{% blockquote %}\nmov 位宽 目的操作数，源操作数\n{% endblockquote %}\n\n目的操作数必需是一个容器，如内存单元、寄存器；源操作数可以是一个立即数，也可以是一个容器。\n\n举例：\n{% blockquote %}\nmov byte [0x00],'2'\n{% endblockquote %}\n\n### loop\nLoop指令需要和cx寄存器配合使用, 用于循环操作, 类似于高级语言中的for, while等。\ncx存放的是循环次数，循环一次，cx中的值减1，当cx中的值大于0时，执行loop循环。\n\n{% blockquote %}\n  mov cx, 11\ns:  \n  add ax, ax\n  loop s\n{% endblockquote %}\n\n### jmp\njmp 是无条件转移指令，无条件转移指令可转到内存中任何程序段，它可以只修改IP，也可以同时修改CS和IP。\n1，短程转移\n指令格式：JMP SHORT OPRD\n语法格式：JMP 地址标号 ；（IP）=（IP）+8位位移量\n指令功能：OPRD为转移地址的标号，指令中的SHORT规定了OPRD为有符号的8位二进制数，OPRD为转移地址的偏移量。该指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，从而实现程序的转移。转移的目标地址OPRD在指令中可以直接使用标号地址，但要求转移的目标地址的范围只能在JMP指令所处地址的－128～+127字节范围之内，如超出该范围，汇编时出错。\n\n2，近程转移\n指令格式：JMP NEAR PTR OPRD\n语法格式：JMP 地址标号 ；（IP）=（IP）+16位位移量\n指令功能：与短程转移的功能和要求相同，不同之处是近程转移的OPRD为有符号的16位二进制数，指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，转移的目标地址的范围只能在JMP指令所处地址的－32768～+32767字节范围之内，如超出该范围，汇编时出错。使用该指令时NEAR可省略。\n\n3，段间转移\n指令格式：JMP FAR PTR OPRD\n语法格式：JMP 地址标号 ；（IP）= 新的偏移地址, ；（CS）= 新的代码段地址\n指令功能：指令中用FAR PTR规定了该指令为段间的转移，OPRD为目的地址的标号，目的地址与JMP指令所在地址不在同一段内。执行该指令时要修改CS和IP的内容，将OPRD所在段的段地址送CS中，OPRD的段内偏移地址送IP中。\n\n4，段内间转移\n指令格式：JMP WORD PTR OPRD\n语法格式：JMP reg16/mem ；（IP）= 新的偏移地址\n指令功能：与短程转移的功能和要求相同，不同之处是段内间接转移的OPRD 可以是除立即数外的任何寄存或存储器寻址方式，转移的目标地址由OPRD的内容确定。\n\n5，段间间接转移\n指令格式：JMP DWORD PTR OPRD\n语法格式：JMP mem32\n指令功能：指令中用DWORD PTR规定了该指令为段间间接转移，OPRD只能是存储器寻址方式。执行该指令时将寻址到的内存单元的第一个字送入IP中，第二个字送入CS中。\n\n### 条件转移\n{% asset_img jmp_condition.png flag registor %}\n\n### call & ret\n在高级语言中，常有主程序调用其他子程序，子程序还可以调用子程序。\ncall指令可以实现调用一个子程序，在子程序里使用ret指令结束子程序的执行并返回主程序（类比C语言中的main函数调用cube函数进行理解），主程序继续往下执行。\n\n{% blockquote %}\nmov ax,0\ncall s     ;s是标号，执行call后，执行s标号所在的子程序\nmov ax,4c00h\nint 21h\n\ns:add ax,1   ;标号所在子程序\n  mov bx,10\n  ret        ;子程序执行完后，返回主程序\n{% endblockquote %}\n\n### push & pop\npush和pop是用来操作栈的2个指令；push将一个寄存器中的数据入栈，pop出栈用一个寄存器接收数据；相关的寄存器`SS:SP`。\n举例：\nmov ax 123H\npush ax 的执行，由以下两步完成。\n(1) SP = SP - 2, SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；\n(2) 将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。\n\n\n### int\nint指令是X86汇编语言中最重要的指令之一。它的作用是引发中断，调用“中断例程”（interrupt routine）\n\n指令格式：\n{% blockquote %}\nint n ;n是中端号\n{% endblockquote %}\n\n指令执行过程：\n{% blockquote %}\n1，取中断类型码n；\n2，标志寄存器入栈（pushf），IF=0，TF=0（重置中断标志位）；\n3，CS、IP入栈；\n4，查中断向量表， (IP)=(n\\*4)，(CS)=(n\\*4+2)。\n{% endblockquote %}\n\n","slug":"OS-Develop-2","published":1,"updated":"2024-03-12T06:45:25.444Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9r000udk2d9adn42f8","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本章介绍汇编语言。</p>\n<h3 id=\"标号\"><a href=\"#标号\" class=\"headerlink\" title=\"标号\"></a>标号</h3><p>标号是充当指令或数据位置标记的标识符。</p>\n<ul>\n<li><p>数据标号</p>\n<blockquote><p>count DW 100 ;定义一个名为count的变量a</p>\n</blockquote>\n</li>\n<li><p>代码标号<br>以冒号结尾，表示一个位置，可以用于跳转。</p>\n<blockquote><p>loop:<br>    jmp loop</p>\n</blockquote></li>\n</ul>\n<h3 id=\"伪指令\"><a href=\"#伪指令\" class=\"headerlink\" title=\"伪指令\"></a>伪指令</h3><p>伪指令不是真正的指令，它是由NASM的编译器提供支持，伪指令在编译的时候执行。</p>\n<ul>\n<li>Dx族</li>\n<li>Resx族</li>\n<li>equ</li>\n<li>times</li>\n<li>vstar &amp; org</li>\n<li>incbin</li>\n</ul>\n<h3 id=\"7种数据Size\"><a href=\"#7种数据Size\" class=\"headerlink\" title=\"7种数据Size\"></a>7种数据Size</h3><ul>\n<li>byte ： 8 位</li>\n<li>word ： 16 位</li>\n<li>dword ： 32 位</li>\n<li>qword ： 64 位</li>\n<li>tword ： 80 位</li>\n<li>oword ： 128 位</li>\n<li>yword ： 256 位</li>\n</ul>\n<h3 id=\"Dx族\"><a href=\"#Dx族\" class=\"headerlink\" title=\"Dx族\"></a>Dx族</h3><p>Dx族用来在内存中，顺序定义初始化数据。<br>nasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。</p>\n<ul>\n<li>db : define byte</li>\n<li>dw ：define word</li>\n<li>dd ：define doubleword</li>\n<li>dq ：define quadword</li>\n<li>dt ：define tword</li>\n<li>do ：define oword</li>\n<li>dy ：define yword</li>\n</ul>\n<p>例如：</p>\n<blockquote><p>db    0x55                ; just the byte 0x55<br>db    0x55,0x56,0x57      ; three bytes in succession<br>db    ‘a’,0x55            ; character constants are OK<br>db    ‘hello’,13,10,’$’   ; so are string constants<br>dw    0x1234              ; 0x34 0x12<br>dw    ‘a’                 ; 0x61 0x00 (it’s just a number)<br>dw    ‘ab’                ; 0x61 0x62 (character constant)<br>dw    ‘abc’               ; 0x61 0x62 0x63 0x00 (string)<br>dd    0x12345678          ; 0x78 0x56 0x34 0x12<br>dd    1.234567e20         ; floating-point constant<br>dq    0x123456789abcdef0  ; eight byte constant<br>dq    1.234567e20         ; double-precision float<br>dt    1.234567e20         ; extended-precision float</p>\n</blockquote>\n\n<h3 id=\"Resx族\"><a href=\"#Resx族\" class=\"headerlink\" title=\"Resx族\"></a>Resx族</h3><p>这类伪指令，用来定义非初始化数据，非初始化数据存放在bass section中。</p>\n<ul>\n<li>resb ：reserve byte</li>\n<li>resw ：reserve word</li>\n<li>resd ：reserve doubword</li>\n<li>resq ：reserve quadword</li>\n<li>rest ：reserve tword</li>\n<li>reso ：reserve oword</li>\n<li>resy ：reserve yword</li>\n</ul>\n<p>例如：</p>\n<blockquote><p>buffer:         resb    64              ; reserve 64 bytes<br>wordvar:        resw    1               ; reserve a word<br>realarray       resq    10              ; array of ten reals<br>ymmval:         resy    1               ; one YMM register</p>\n</blockquote>\n\n\n<h3 id=\"变量定义\"><a href=\"#变量定义\" class=\"headerlink\" title=\"变量定义\"></a>变量定义</h3><p>【变量名】 变量类型  表达式<br>例如：</p>\n<blockquote><p>a db 1,2,3,4,5<br>db 7,8,9,10 ;非变量定义，只定义数据<br>b dw 123,123,123<br>c db ‘hello, world!’</p>\n</blockquote>\n\n<p>上面定义的数据都是顺序存放在内存中的，所以虽然第二行的数据没有定义名字，但是因为他紧跟在a 数组之后 b数组之前，所以使用a+5,或者 b-1 也是可以访问的，只是需要注意的是数据类型和 大端小端的问题。<br>声明的变量代表后面数据的地址，例如c是后面字符串的首地址，如果要使用，需要用中括号：</p>\n<blockquote><p>mov ax, [c]</p>\n</blockquote>\n\n<h3 id=\"equ\"><a href=\"#equ\" class=\"headerlink\" title=\"equ\"></a>equ</h3><p>它的作用和#define相同，它并不占用内存，在编译之后，它将替换被调用的地方，例如：</p>\n<blockquote><p>num equ 110<br>mov ax, num<br>mov bx, num<br>mov cx, num</p>\n</blockquote>\n\n<p>编译后：</p>\n<blockquote><p>mov ax, 110<br>mov bx, 110<br>mov cx, 110</p>\n</blockquote>\n\n<h3 id=\"和\"><a href=\"#和\" class=\"headerlink\" title=\"$和$$\"></a>$和$$</h3><p>$表示当前行的汇编地址。<br>$$表示当前程序的起始汇编地址。</p>\n<h3 id=\"times\"><a href=\"#times\" class=\"headerlink\" title=\"times\"></a>times</h3><p>后面指令重复次数。</p>\n<blockquote><p>buffer: db ‘hello, world’<br>times 64-$+buffer db ‘’ ;补齐64字节</p>\n</blockquote>\n\n<h3 id=\"incbin\"><a href=\"#incbin\" class=\"headerlink\" title=\"incbin\"></a>incbin</h3><p>包含binary文件。例如</p>\n<blockquote><p>ncbin “file.dat” ; include the whole file<br>incbin “file.dat”,1024 ; skip the first 1024 bytes<br>incbin “file.dat”,1024,512 ; skip the first 1024, and<br>; actually include at most 512</p>\n</blockquote>\n\n<h3 id=\"vstart-org\"><a href=\"#vstart-org\" class=\"headerlink\" title=\"vstart &amp; org\"></a>vstart &amp; org</h3><p>程序的加载位置是由加载它的一方来决定的(因为加载后，加载方需要去访问被加载方，去哪里访问，这个是加载方来确定的)。vstart和org是告诉编译器，将后面的所有数据(指令和变量)的地址，加上一个偏移量。<br>编译器以相对于文件开头偏移来编址的好处是利于重定位。程序内的地址是从0开始算的，当程序被加载到内存的某个地址(不一定是0)后，就需要用vstart或org来指定偏移量，这个偏移量也就是加载到内存的地址。</p>\n<h3 id=\"mov\"><a href=\"#mov\" class=\"headerlink\" title=\"mov\"></a>mov</h3><p>格式：</p>\n<blockquote><p>mov 位宽 目的操作数，源操作数</p>\n</blockquote>\n\n<p>目的操作数必需是一个容器，如内存单元、寄存器；源操作数可以是一个立即数，也可以是一个容器。</p>\n<p>举例：</p>\n<blockquote><p>mov byte [0x00],’2’</p>\n</blockquote>\n\n<h3 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h3><p>Loop指令需要和cx寄存器配合使用, 用于循环操作, 类似于高级语言中的for, while等。<br>cx存放的是循环次数，循环一次，cx中的值减1，当cx中的值大于0时，执行loop循环。</p>\n<blockquote><p>  mov cx, 11<br>s:<br>  add ax, ax<br>  loop s</p>\n</blockquote>\n\n<h3 id=\"jmp\"><a href=\"#jmp\" class=\"headerlink\" title=\"jmp\"></a>jmp</h3><p>jmp 是无条件转移指令，无条件转移指令可转到内存中任何程序段，它可以只修改IP，也可以同时修改CS和IP。<br>1，短程转移<br>指令格式：JMP SHORT OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D;（IP）+8位位移量<br>指令功能：OPRD为转移地址的标号，指令中的SHORT规定了OPRD为有符号的8位二进制数，OPRD为转移地址的偏移量。该指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，从而实现程序的转移。转移的目标地址OPRD在指令中可以直接使用标号地址，但要求转移的目标地址的范围只能在JMP指令所处地址的－128～+127字节范围之内，如超出该范围，汇编时出错。</p>\n<p>2，近程转移<br>指令格式：JMP NEAR PTR OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D;（IP）+16位位移量<br>指令功能：与短程转移的功能和要求相同，不同之处是近程转移的OPRD为有符号的16位二进制数，指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，转移的目标地址的范围只能在JMP指令所处地址的－32768～+32767字节范围之内，如超出该范围，汇编时出错。使用该指令时NEAR可省略。</p>\n<p>3，段间转移<br>指令格式：JMP FAR PTR OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D; 新的偏移地址, ；（CS）&#x3D; 新的代码段地址<br>指令功能：指令中用FAR PTR规定了该指令为段间的转移，OPRD为目的地址的标号，目的地址与JMP指令所在地址不在同一段内。执行该指令时要修改CS和IP的内容，将OPRD所在段的段地址送CS中，OPRD的段内偏移地址送IP中。</p>\n<p>4，段内间转移<br>指令格式：JMP WORD PTR OPRD<br>语法格式：JMP reg16&#x2F;mem ；（IP）&#x3D; 新的偏移地址<br>指令功能：与短程转移的功能和要求相同，不同之处是段内间接转移的OPRD 可以是除立即数外的任何寄存或存储器寻址方式，转移的目标地址由OPRD的内容确定。</p>\n<p>5，段间间接转移<br>指令格式：JMP DWORD PTR OPRD<br>语法格式：JMP mem32<br>指令功能：指令中用DWORD PTR规定了该指令为段间间接转移，OPRD只能是存储器寻址方式。执行该指令时将寻址到的内存单元的第一个字送入IP中，第二个字送入CS中。</p>\n<h3 id=\"条件转移\"><a href=\"#条件转移\" class=\"headerlink\" title=\"条件转移\"></a>条件转移</h3><img src=\"/2022/03/22/OS-Develop-2/jmp_condition.png\" class=\"\" title=\"flag registor\">\n\n<h3 id=\"call-ret\"><a href=\"#call-ret\" class=\"headerlink\" title=\"call &amp; ret\"></a>call &amp; ret</h3><p>在高级语言中，常有主程序调用其他子程序，子程序还可以调用子程序。<br>call指令可以实现调用一个子程序，在子程序里使用ret指令结束子程序的执行并返回主程序（类比C语言中的main函数调用cube函数进行理解），主程序继续往下执行。</p>\n<blockquote><p>mov ax,0<br>call s     ;s是标号，执行call后，执行s标号所在的子程序<br>mov ax,4c00h<br>int 21h</p>\n<p>s:add ax,1   ;标号所在子程序<br>  mov bx,10<br>  ret        ;子程序执行完后，返回主程序</p>\n</blockquote>\n\n<h3 id=\"push-pop\"><a href=\"#push-pop\" class=\"headerlink\" title=\"push &amp; pop\"></a>push &amp; pop</h3><p>push和pop是用来操作栈的2个指令；push将一个寄存器中的数据入栈，pop出栈用一个寄存器接收数据；相关的寄存器<code>SS:SP</code>。<br>举例：<br>mov ax 123H<br>push ax 的执行，由以下两步完成。<br>(1) SP &#x3D; SP - 2, SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；<br>(2) 将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。</p>\n<h3 id=\"int\"><a href=\"#int\" class=\"headerlink\" title=\"int\"></a>int</h3><p>int指令是X86汇编语言中最重要的指令之一。它的作用是引发中断，调用“中断例程”（interrupt routine）</p>\n<p>指令格式：</p>\n<blockquote><p>int n ;n是中端号</p>\n</blockquote>\n\n<p>指令执行过程：</p>\n<blockquote><p>1，取中断类型码n；<br>2，标志寄存器入栈（pushf），IF&#x3D;0，TF&#x3D;0（重置中断标志位）；<br>3，CS、IP入栈；<br>4，查中断向量表， (IP)&#x3D;(n*4)，(CS)&#x3D;(n*4+2)。</p>\n</blockquote>\n\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本章介绍汇编语言。</p>\n<h3 id=\"标号\"><a href=\"#标号\" class=\"headerlink\" title=\"标号\"></a>标号</h3><p>标号是充当指令或数据位置标记的标识符。</p>\n<ul>\n<li><p>数据标号</p>\n<blockquote><p>count DW 100 ;定义一个名为count的变量a</p>\n</blockquote>\n</li>\n<li><p>代码标号<br>以冒号结尾，表示一个位置，可以用于跳转。</p>\n<blockquote><p>loop:<br>    jmp loop</p>\n</blockquote></li>\n</ul>\n<h3 id=\"伪指令\"><a href=\"#伪指令\" class=\"headerlink\" title=\"伪指令\"></a>伪指令</h3><p>伪指令不是真正的指令，它是由NASM的编译器提供支持，伪指令在编译的时候执行。</p>\n<ul>\n<li>Dx族</li>\n<li>Resx族</li>\n<li>equ</li>\n<li>times</li>\n<li>vstar &amp; org</li>\n<li>incbin</li>\n</ul>\n<h3 id=\"7种数据Size\"><a href=\"#7种数据Size\" class=\"headerlink\" title=\"7种数据Size\"></a>7种数据Size</h3><ul>\n<li>byte ： 8 位</li>\n<li>word ： 16 位</li>\n<li>dword ： 32 位</li>\n<li>qword ： 64 位</li>\n<li>tword ： 80 位</li>\n<li>oword ： 128 位</li>\n<li>yword ： 256 位</li>\n</ul>\n<h3 id=\"Dx族\"><a href=\"#Dx族\" class=\"headerlink\" title=\"Dx族\"></a>Dx族</h3><p>Dx族用来在内存中，顺序定义初始化数据。<br>nasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。</p>\n<ul>\n<li>db : define byte</li>\n<li>dw ：define word</li>\n<li>dd ：define doubleword</li>\n<li>dq ：define quadword</li>\n<li>dt ：define tword</li>\n<li>do ：define oword</li>\n<li>dy ：define yword</li>\n</ul>\n<p>例如：</p>\n<blockquote><p>db    0x55                ; just the byte 0x55<br>db    0x55,0x56,0x57      ; three bytes in succession<br>db    ‘a’,0x55            ; character constants are OK<br>db    ‘hello’,13,10,’$’   ; so are string constants<br>dw    0x1234              ; 0x34 0x12<br>dw    ‘a’                 ; 0x61 0x00 (it’s just a number)<br>dw    ‘ab’                ; 0x61 0x62 (character constant)<br>dw    ‘abc’               ; 0x61 0x62 0x63 0x00 (string)<br>dd    0x12345678          ; 0x78 0x56 0x34 0x12<br>dd    1.234567e20         ; floating-point constant<br>dq    0x123456789abcdef0  ; eight byte constant<br>dq    1.234567e20         ; double-precision float<br>dt    1.234567e20         ; extended-precision float</p>\n</blockquote>\n\n<h3 id=\"Resx族\"><a href=\"#Resx族\" class=\"headerlink\" title=\"Resx族\"></a>Resx族</h3><p>这类伪指令，用来定义非初始化数据，非初始化数据存放在bass section中。</p>\n<ul>\n<li>resb ：reserve byte</li>\n<li>resw ：reserve word</li>\n<li>resd ：reserve doubword</li>\n<li>resq ：reserve quadword</li>\n<li>rest ：reserve tword</li>\n<li>reso ：reserve oword</li>\n<li>resy ：reserve yword</li>\n</ul>\n<p>例如：</p>\n<blockquote><p>buffer:         resb    64              ; reserve 64 bytes<br>wordvar:        resw    1               ; reserve a word<br>realarray       resq    10              ; array of ten reals<br>ymmval:         resy    1               ; one YMM register</p>\n</blockquote>\n\n\n<h3 id=\"变量定义\"><a href=\"#变量定义\" class=\"headerlink\" title=\"变量定义\"></a>变量定义</h3><p>【变量名】 变量类型  表达式<br>例如：</p>\n<blockquote><p>a db 1,2,3,4,5<br>db 7,8,9,10 ;非变量定义，只定义数据<br>b dw 123,123,123<br>c db ‘hello, world!’</p>\n</blockquote>\n\n<p>上面定义的数据都是顺序存放在内存中的，所以虽然第二行的数据没有定义名字，但是因为他紧跟在a 数组之后 b数组之前，所以使用a+5,或者 b-1 也是可以访问的，只是需要注意的是数据类型和 大端小端的问题。<br>声明的变量代表后面数据的地址，例如c是后面字符串的首地址，如果要使用，需要用中括号：</p>\n<blockquote><p>mov ax, [c]</p>\n</blockquote>\n\n<h3 id=\"equ\"><a href=\"#equ\" class=\"headerlink\" title=\"equ\"></a>equ</h3><p>它的作用和#define相同，它并不占用内存，在编译之后，它将替换被调用的地方，例如：</p>\n<blockquote><p>num equ 110<br>mov ax, num<br>mov bx, num<br>mov cx, num</p>\n</blockquote>\n\n<p>编译后：</p>\n<blockquote><p>mov ax, 110<br>mov bx, 110<br>mov cx, 110</p>\n</blockquote>\n\n<h3 id=\"和\"><a href=\"#和\" class=\"headerlink\" title=\"$和$$\"></a>$和$$</h3><p>$表示当前行的汇编地址。<br>$$表示当前程序的起始汇编地址。</p>\n<h3 id=\"times\"><a href=\"#times\" class=\"headerlink\" title=\"times\"></a>times</h3><p>后面指令重复次数。</p>\n<blockquote><p>buffer: db ‘hello, world’<br>times 64-$+buffer db ‘’ ;补齐64字节</p>\n</blockquote>\n\n<h3 id=\"incbin\"><a href=\"#incbin\" class=\"headerlink\" title=\"incbin\"></a>incbin</h3><p>包含binary文件。例如</p>\n<blockquote><p>ncbin “file.dat” ; include the whole file<br>incbin “file.dat”,1024 ; skip the first 1024 bytes<br>incbin “file.dat”,1024,512 ; skip the first 1024, and<br>; actually include at most 512</p>\n</blockquote>\n\n<h3 id=\"vstart-org\"><a href=\"#vstart-org\" class=\"headerlink\" title=\"vstart &amp; org\"></a>vstart &amp; org</h3><p>程序的加载位置是由加载它的一方来决定的(因为加载后，加载方需要去访问被加载方，去哪里访问，这个是加载方来确定的)。vstart和org是告诉编译器，将后面的所有数据(指令和变量)的地址，加上一个偏移量。<br>编译器以相对于文件开头偏移来编址的好处是利于重定位。程序内的地址是从0开始算的，当程序被加载到内存的某个地址(不一定是0)后，就需要用vstart或org来指定偏移量，这个偏移量也就是加载到内存的地址。</p>\n<h3 id=\"mov\"><a href=\"#mov\" class=\"headerlink\" title=\"mov\"></a>mov</h3><p>格式：</p>\n<blockquote><p>mov 位宽 目的操作数，源操作数</p>\n</blockquote>\n\n<p>目的操作数必需是一个容器，如内存单元、寄存器；源操作数可以是一个立即数，也可以是一个容器。</p>\n<p>举例：</p>\n<blockquote><p>mov byte [0x00],’2’</p>\n</blockquote>\n\n<h3 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h3><p>Loop指令需要和cx寄存器配合使用, 用于循环操作, 类似于高级语言中的for, while等。<br>cx存放的是循环次数，循环一次，cx中的值减1，当cx中的值大于0时，执行loop循环。</p>\n<blockquote><p>  mov cx, 11<br>s:<br>  add ax, ax<br>  loop s</p>\n</blockquote>\n\n<h3 id=\"jmp\"><a href=\"#jmp\" class=\"headerlink\" title=\"jmp\"></a>jmp</h3><p>jmp 是无条件转移指令，无条件转移指令可转到内存中任何程序段，它可以只修改IP，也可以同时修改CS和IP。<br>1，短程转移<br>指令格式：JMP SHORT OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D;（IP）+8位位移量<br>指令功能：OPRD为转移地址的标号，指令中的SHORT规定了OPRD为有符号的8位二进制数，OPRD为转移地址的偏移量。该指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，从而实现程序的转移。转移的目标地址OPRD在指令中可以直接使用标号地址，但要求转移的目标地址的范围只能在JMP指令所处地址的－128～+127字节范围之内，如超出该范围，汇编时出错。</p>\n<p>2，近程转移<br>指令格式：JMP NEAR PTR OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D;（IP）+16位位移量<br>指令功能：与短程转移的功能和要求相同，不同之处是近程转移的OPRD为有符号的16位二进制数，指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，转移的目标地址的范围只能在JMP指令所处地址的－32768～+32767字节范围之内，如超出该范围，汇编时出错。使用该指令时NEAR可省略。</p>\n<p>3，段间转移<br>指令格式：JMP FAR PTR OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D; 新的偏移地址, ；（CS）&#x3D; 新的代码段地址<br>指令功能：指令中用FAR PTR规定了该指令为段间的转移，OPRD为目的地址的标号，目的地址与JMP指令所在地址不在同一段内。执行该指令时要修改CS和IP的内容，将OPRD所在段的段地址送CS中，OPRD的段内偏移地址送IP中。</p>\n<p>4，段内间转移<br>指令格式：JMP WORD PTR OPRD<br>语法格式：JMP reg16&#x2F;mem ；（IP）&#x3D; 新的偏移地址<br>指令功能：与短程转移的功能和要求相同，不同之处是段内间接转移的OPRD 可以是除立即数外的任何寄存或存储器寻址方式，转移的目标地址由OPRD的内容确定。</p>\n<p>5，段间间接转移<br>指令格式：JMP DWORD PTR OPRD<br>语法格式：JMP mem32<br>指令功能：指令中用DWORD PTR规定了该指令为段间间接转移，OPRD只能是存储器寻址方式。执行该指令时将寻址到的内存单元的第一个字送入IP中，第二个字送入CS中。</p>\n<h3 id=\"条件转移\"><a href=\"#条件转移\" class=\"headerlink\" title=\"条件转移\"></a>条件转移</h3><img src=\"/2022/03/22/OS-Develop-2/jmp_condition.png\" class=\"\" title=\"flag registor\">\n\n<h3 id=\"call-ret\"><a href=\"#call-ret\" class=\"headerlink\" title=\"call &amp; ret\"></a>call &amp; ret</h3><p>在高级语言中，常有主程序调用其他子程序，子程序还可以调用子程序。<br>call指令可以实现调用一个子程序，在子程序里使用ret指令结束子程序的执行并返回主程序（类比C语言中的main函数调用cube函数进行理解），主程序继续往下执行。</p>\n<blockquote><p>mov ax,0<br>call s     ;s是标号，执行call后，执行s标号所在的子程序<br>mov ax,4c00h<br>int 21h</p>\n<p>s:add ax,1   ;标号所在子程序<br>  mov bx,10<br>  ret        ;子程序执行完后，返回主程序</p>\n</blockquote>\n\n<h3 id=\"push-pop\"><a href=\"#push-pop\" class=\"headerlink\" title=\"push &amp; pop\"></a>push &amp; pop</h3><p>push和pop是用来操作栈的2个指令；push将一个寄存器中的数据入栈，pop出栈用一个寄存器接收数据；相关的寄存器<code>SS:SP</code>。<br>举例：<br>mov ax 123H<br>push ax 的执行，由以下两步完成。<br>(1) SP &#x3D; SP - 2, SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；<br>(2) 将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。</p>\n<h3 id=\"int\"><a href=\"#int\" class=\"headerlink\" title=\"int\"></a>int</h3><p>int指令是X86汇编语言中最重要的指令之一。它的作用是引发中断，调用“中断例程”（interrupt routine）</p>\n<p>指令格式：</p>\n<blockquote><p>int n ;n是中端号</p>\n</blockquote>\n\n<p>指令执行过程：</p>\n<blockquote><p>1，取中断类型码n；<br>2，标志寄存器入栈（pushf），IF&#x3D;0，TF&#x3D;0（重置中断标志位）；<br>3，CS、IP入栈；<br>4，查中断向量表， (IP)&#x3D;(n*4)，(CS)&#x3D;(n*4+2)。</p>\n</blockquote>\n\n"},{"title":"OS Develop 3","date":"2022-03-28T10:20:09.000Z","_content":"\n### 简介\n本章讨论BIOS：Base Input & Output System，基本输入输出系统。(顺带点DOS)\n\n### 开始\nBIOS是计算机上第一个运行的软件，它存放在只读存储器ROM上。开机后，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0，此地址便是BIOS的入口地址，BIOS是在实模式下运行的。\n\n### BIOS和DOS\n\n系统板的ROM中存放着一套程序，称为BIOS基本输入输出系统。BIOS最主要功能是基于中断向量表，创建中断例程，中断例程提供了对硬件访问的方法。BIOS中主要包含几下部分内容：\n- 硬件系统的检测和初始化程序；  \n- 外部中断(后面讲解)和内部中断的中断例程；  \n- 用于对硬件设备进行 I/O操作的中断例程；  \n- 其他和硬件系统相关的中断例程.\n- 交接给MBR\n\n操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供了中断例程中包含了许多子程序，这些子程序实现了程序员在编程时经常需要用到的功能。程序员在编程时，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。\n\n### BIOS和外设\nBIOS中断例程访问外设，依赖外设ROM上的初始化代码和功能调用接口。访问方式有两种：\n- MMIO\n在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种IO方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存。因此，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。\n\n- PMIO\n在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节(例如：outb, outw, outl)从/到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。\n\n\n### 中断\n中断指令(in)，中断号，中断向量表，中断例程(处理程序)。\n中断向量表是CPU硬件原生支持的；中断例程是BIOS，DOS等创建的。\n\n\n### BIOS内存位置\n![](/images/real_time_mm.png)\n\n### 结束\nBIOS最后一项工作是校验启动盘中0盘0道1扇区的内容，如果扇区最后分别是0x55和0xaa，BIOS则认为此扇区中存在MBR可执行程序，然后会将此扇区中的内容加载到物理地址0x7c00处，大小为512字节，随后跳转到给地址，执行该处的程序。","source":"_posts/OS-Develop-3.md","raw":"---\ntitle: OS Develop 3\ndate: 2022-03-28 18:20:09\ntags: OS\n---\n\n### 简介\n本章讨论BIOS：Base Input & Output System，基本输入输出系统。(顺带点DOS)\n\n### 开始\nBIOS是计算机上第一个运行的软件，它存放在只读存储器ROM上。开机后，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0，此地址便是BIOS的入口地址，BIOS是在实模式下运行的。\n\n### BIOS和DOS\n\n系统板的ROM中存放着一套程序，称为BIOS基本输入输出系统。BIOS最主要功能是基于中断向量表，创建中断例程，中断例程提供了对硬件访问的方法。BIOS中主要包含几下部分内容：\n- 硬件系统的检测和初始化程序；  \n- 外部中断(后面讲解)和内部中断的中断例程；  \n- 用于对硬件设备进行 I/O操作的中断例程；  \n- 其他和硬件系统相关的中断例程.\n- 交接给MBR\n\n操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供了中断例程中包含了许多子程序，这些子程序实现了程序员在编程时经常需要用到的功能。程序员在编程时，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。\n\n### BIOS和外设\nBIOS中断例程访问外设，依赖外设ROM上的初始化代码和功能调用接口。访问方式有两种：\n- MMIO\n在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种IO方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存。因此，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。\n\n- PMIO\n在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节(例如：outb, outw, outl)从/到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。\n\n\n### 中断\n中断指令(in)，中断号，中断向量表，中断例程(处理程序)。\n中断向量表是CPU硬件原生支持的；中断例程是BIOS，DOS等创建的。\n\n\n### BIOS内存位置\n![](/images/real_time_mm.png)\n\n### 结束\nBIOS最后一项工作是校验启动盘中0盘0道1扇区的内容，如果扇区最后分别是0x55和0xaa，BIOS则认为此扇区中存在MBR可执行程序，然后会将此扇区中的内容加载到物理地址0x7c00处，大小为512字节，随后跳转到给地址，执行该处的程序。","slug":"OS-Develop-3","published":1,"updated":"2024-03-12T07:05:37.800Z","comments":1,"layout":"post","photos":[],"_id":"cltpdsk9r000wdk2d9jtxhomk","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本章讨论BIOS：Base Input &amp; Output System，基本输入输出系统。(顺带点DOS)</p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>BIOS是计算机上第一个运行的软件，它存放在只读存储器ROM上。开机后，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0，此地址便是BIOS的入口地址，BIOS是在实模式下运行的。</p>\n<h3 id=\"BIOS和DOS\"><a href=\"#BIOS和DOS\" class=\"headerlink\" title=\"BIOS和DOS\"></a>BIOS和DOS</h3><p>系统板的ROM中存放着一套程序，称为BIOS基本输入输出系统。BIOS最主要功能是基于中断向量表，创建中断例程，中断例程提供了对硬件访问的方法。BIOS中主要包含几下部分内容：</p>\n<ul>\n<li>硬件系统的检测和初始化程序；  </li>\n<li>外部中断(后面讲解)和内部中断的中断例程；  </li>\n<li>用于对硬件设备进行 I&#x2F;O操作的中断例程；  </li>\n<li>其他和硬件系统相关的中断例程.</li>\n<li>交接给MBR</li>\n</ul>\n<p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供了中断例程中包含了许多子程序，这些子程序实现了程序员在编程时经常需要用到的功能。程序员在编程时，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p>\n<h3 id=\"BIOS和外设\"><a href=\"#BIOS和外设\" class=\"headerlink\" title=\"BIOS和外设\"></a>BIOS和外设</h3><p>BIOS中断例程访问外设，依赖外设ROM上的初始化代码和功能调用接口。访问方式有两种：</p>\n<ul>\n<li><p>MMIO<br>在MMIO中，内存和I&#x2F;O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种IO方法，它使用相同的地址总线来处理内存和I&#x2F;O设备，I&#x2F;O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I&#x2F;O设备的内存。因此，用于访问内存的CPU指令也可来访问I&#x2F;O设备。每个I&#x2F;O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I&#x2F;O设备，CPU必须预留给I&#x2F;O一个地址区域，该地址区域不能给物理内存使用。</p>\n</li>\n<li><p>PMIO<br>在PMIO中，内存和I&#x2F;O设备有各自的地址空间。 端口映射I&#x2F;O通常使用一种特殊的CPU指令，专门执行I&#x2F;O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读&#x2F;写1,2,4个字节(例如：outb, outw, outl)从&#x2F;到IO设备上。I&#x2F;O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I&#x2F;O引脚，要么增加一条专用的I&#x2F;O总线。由于I&#x2F;O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I&#x2F;O)。</p>\n</li>\n</ul>\n<h3 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h3><p>中断指令(in)，中断号，中断向量表，中断例程(处理程序)。<br>中断向量表是CPU硬件原生支持的；中断例程是BIOS，DOS等创建的。</p>\n<h3 id=\"BIOS内存位置\"><a href=\"#BIOS内存位置\" class=\"headerlink\" title=\"BIOS内存位置\"></a>BIOS内存位置</h3><p><img src=\"/images/real_time_mm.png\"></p>\n<h3 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h3><p>BIOS最后一项工作是校验启动盘中0盘0道1扇区的内容，如果扇区最后分别是0x55和0xaa，BIOS则认为此扇区中存在MBR可执行程序，然后会将此扇区中的内容加载到物理地址0x7c00处，大小为512字节，随后跳转到给地址，执行该处的程序。</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本章讨论BIOS：Base Input &amp; Output System，基本输入输出系统。(顺带点DOS)</p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>BIOS是计算机上第一个运行的软件，它存放在只读存储器ROM上。开机后，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0，此地址便是BIOS的入口地址，BIOS是在实模式下运行的。</p>\n<h3 id=\"BIOS和DOS\"><a href=\"#BIOS和DOS\" class=\"headerlink\" title=\"BIOS和DOS\"></a>BIOS和DOS</h3><p>系统板的ROM中存放着一套程序，称为BIOS基本输入输出系统。BIOS最主要功能是基于中断向量表，创建中断例程，中断例程提供了对硬件访问的方法。BIOS中主要包含几下部分内容：</p>\n<ul>\n<li>硬件系统的检测和初始化程序；  </li>\n<li>外部中断(后面讲解)和内部中断的中断例程；  </li>\n<li>用于对硬件设备进行 I&#x2F;O操作的中断例程；  </li>\n<li>其他和硬件系统相关的中断例程.</li>\n<li>交接给MBR</li>\n</ul>\n<p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供了中断例程中包含了许多子程序，这些子程序实现了程序员在编程时经常需要用到的功能。程序员在编程时，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p>\n<h3 id=\"BIOS和外设\"><a href=\"#BIOS和外设\" class=\"headerlink\" title=\"BIOS和外设\"></a>BIOS和外设</h3><p>BIOS中断例程访问外设，依赖外设ROM上的初始化代码和功能调用接口。访问方式有两种：</p>\n<ul>\n<li><p>MMIO<br>在MMIO中，内存和I&#x2F;O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种IO方法，它使用相同的地址总线来处理内存和I&#x2F;O设备，I&#x2F;O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I&#x2F;O设备的内存。因此，用于访问内存的CPU指令也可来访问I&#x2F;O设备。每个I&#x2F;O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I&#x2F;O设备，CPU必须预留给I&#x2F;O一个地址区域，该地址区域不能给物理内存使用。</p>\n</li>\n<li><p>PMIO<br>在PMIO中，内存和I&#x2F;O设备有各自的地址空间。 端口映射I&#x2F;O通常使用一种特殊的CPU指令，专门执行I&#x2F;O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读&#x2F;写1,2,4个字节(例如：outb, outw, outl)从&#x2F;到IO设备上。I&#x2F;O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I&#x2F;O引脚，要么增加一条专用的I&#x2F;O总线。由于I&#x2F;O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I&#x2F;O)。</p>\n</li>\n</ul>\n<h3 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h3><p>中断指令(in)，中断号，中断向量表，中断例程(处理程序)。<br>中断向量表是CPU硬件原生支持的；中断例程是BIOS，DOS等创建的。</p>\n<h3 id=\"BIOS内存位置\"><a href=\"#BIOS内存位置\" class=\"headerlink\" title=\"BIOS内存位置\"></a>BIOS内存位置</h3><p><img src=\"/images/real_time_mm.png\"></p>\n<h3 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h3><p>BIOS最后一项工作是校验启动盘中0盘0道1扇区的内容，如果扇区最后分别是0x55和0xaa，BIOS则认为此扇区中存在MBR可执行程序，然后会将此扇区中的内容加载到物理地址0x7c00处，大小为512字节，随后跳转到给地址，执行该处的程序。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Algorithm-1/bubble_sort.gif","slug":"bubble_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/bucket_sort.gif","slug":"bucket_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/count_sort.gif","slug":"count_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/heap_sort.gif","slug":"heap_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/insertion_sort.gif","slug":"insertion_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/merge_sort.gif","slug":"merge_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/quick_sort.gif","slug":"quick_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/radix_sort.gif","slug":"radix_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/selection_sort.gif","slug":"selection_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/shell_sort.gif","slug":"shell_sort.gif","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/sort_algorithm.png","slug":"sort_algorithm.png","post":"cltpdsk9k0000dk2d2xdpecd0","modified":0,"renderable":0},{"_id":"source/_posts/My-Desktop-tools/adb_tool.png","slug":"adb_tool.png","post":"cltpdsk9p000idk2d0g9464sc","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/common_registor.png","slug":"common_registor.png","post":"cltpdsk9r000tdk2d4tg502a4","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/control_registor.jpeg","slug":"control_registor.jpeg","post":"cltpdsk9r000tdk2d4tg502a4","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/cpu_workflow.png","slug":"cpu_workflow.png","post":"cltpdsk9r000tdk2d4tg502a4","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/flag_registor.png","slug":"flag_registor.png","post":"cltpdsk9r000tdk2d4tg502a4","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/gdt.png","slug":"gdt.png","post":"cltpdsk9r000tdk2d4tg502a4","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-2/jmp_condition.png","slug":"jmp_condition.png","post":"cltpdsk9r000udk2d9adn42f8","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cltpdsk9n0004dk2d3bno95yl","tag_id":"cltpdsk9m0002dk2dcvcxa9j8","_id":"cltpdsk9o0007dk2dgfoy1kox"},{"post_id":"cltpdsk9k0000dk2d2xdpecd0","tag_id":"cltpdsk9m0002dk2dcvcxa9j8","_id":"cltpdsk9o0009dk2d011mglsp"},{"post_id":"cltpdsk9m0001dk2d8gtzc2m2","tag_id":"cltpdsk9m0002dk2dcvcxa9j8","_id":"cltpdsk9p000cdk2d5gd0322o"},{"post_id":"cltpdsk9o000adk2d6uylgcca","tag_id":"cltpdsk9m0002dk2dcvcxa9j8","_id":"cltpdsk9p000edk2dee1ddrk9"},{"post_id":"cltpdsk9n0003dk2de5auhksg","tag_id":"cltpdsk9m0002dk2dcvcxa9j8","_id":"cltpdsk9p000hdk2d2plh3doo"},{"post_id":"cltpdsk9p000fdk2dflf99u6l","tag_id":"cltpdsk9m0002dk2dcvcxa9j8","_id":"cltpdsk9q000jdk2d5f753v2o"},{"post_id":"cltpdsk9n0005dk2dfl6ihnw7","tag_id":"cltpdsk9p000gdk2d4qvq8cqx","_id":"cltpdsk9q000ldk2dbj8kcuj8"},{"post_id":"cltpdsk9o0008dk2d0dm97xgd","tag_id":"cltpdsk9q000kdk2dh6o72x2f","_id":"cltpdsk9q000odk2de7aj04t2"},{"post_id":"cltpdsk9o0008dk2d0dm97xgd","tag_id":"cltpdsk9q000mdk2d6h3khln9","_id":"cltpdsk9q000pdk2dd0hf46bz"},{"post_id":"cltpdsk9p000ddk2d7nl61xzz","tag_id":"cltpdsk9q000ndk2d7dtpdmuj","_id":"cltpdsk9q000rdk2dfofphy0m"},{"post_id":"cltpdsk9p000idk2d0g9464sc","tag_id":"cltpdsk9q000ndk2d7dtpdmuj","_id":"cltpdsk9q000sdk2da52x3juv"},{"post_id":"cltpdsk9r000tdk2d4tg502a4","tag_id":"cltpdsk9r000vdk2dc1s5hm0z","_id":"cltpdsk9r000ydk2d5wjp8697"},{"post_id":"cltpdsk9r000udk2d9adn42f8","tag_id":"cltpdsk9r000vdk2dc1s5hm0z","_id":"cltpdsk9r0010dk2dc4iwfpi5"},{"post_id":"cltpdsk9r000wdk2d9jtxhomk","tag_id":"cltpdsk9r000vdk2dc1s5hm0z","_id":"cltpdsk9r0011dk2d1abv7qf5"}],"Tag":[{"name":"IT-Basics","_id":"cltpdsk9m0002dk2dcvcxa9j8"},{"name":"Backend","_id":"cltpdsk9p000gdk2d4qvq8cqx"},{"name":"Blockchain","_id":"cltpdsk9q000kdk2dh6o72x2f"},{"name":"Android","_id":"cltpdsk9q000mdk2d6h3khln9"},{"name":"Tool","_id":"cltpdsk9q000ndk2d7dtpdmuj"},{"name":"OS","_id":"cltpdsk9r000vdk2dc1s5hm0z"}]}}