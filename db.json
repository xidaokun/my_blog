{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/hingle/source/static/hingle.css","path":"static/hingle.css","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/hingle.js","path":"static/hingle.js","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/kico.css","path":"static/kico.css","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/kico.js","path":"static/kico.js","modified":0,"renderable":1},{"_id":"themes/hingle/source/static/img/icon.png","path":"static/img/icon.png","modified":0,"renderable":1},{"_id":"source/images/real_time_mm.png","path":"images/real_time_mm.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"1c2796c37847ce2895a6587efabfc9b345db7fd8","modified":1710337882516},{"_id":"source/_posts/.DS_Store","hash":"1474bdb43eb808a94bfc142dc9bb2e021f8db254","modified":1710337882516},{"_id":"source/_posts/AOSP-Build.md","hash":"4be86c23a460be95fd586cfb18b6c41249c9908a","modified":1710340999140},{"_id":"source/_posts/Algorithm-1.md","hash":"ee18ac25f3bcb82219bd7f89771623ded343bec5","modified":1710337882516},{"_id":"source/_posts/Algorithm-2.md","hash":"2ea21a358b732aa39d37c8776f01a6e9f64d6e45","modified":1710337882558},{"_id":"source/_posts/Algorithm-3.md","hash":"9e12b3a051efa55da287d98aa78302c3bef7d587","modified":1710337882559},{"_id":"source/_posts/Algorithm-4.md","hash":"436c86de4693143eeb6f07ce11fa0ef054b71fca","modified":1710337882559},{"_id":"source/_posts/Backend-Node.md","hash":"3197ee400a2a830210ab584cf642c336b882b2a9","modified":1710337882559},{"_id":"source/_posts/Data-Struct-1.md","hash":"bbe982aed2353654d20b3d8e280a861003604d2d","modified":1710337882560},{"_id":"source/_posts/Data-Struct-2.md","hash":"ff11ac67785da9b03c765ccd74479d03e1446436","modified":1710337882571},{"_id":"source/_posts/Blockchain-wallet.md","hash":"053fc76b8763b0834b4531cd6f925553afc928d7","modified":1710337882560},{"_id":"source/_posts/Data-Struct-3.md","hash":"698de580e41e022790f27f29eb60e375d107e75a","modified":1710337882576},{"_id":"source/_posts/My-Desktop-tools.md","hash":"84d24c44ce7dfe0a4601e8f76c63d5feea27a7f2","modified":1710337882578},{"_id":"source/_posts/Markdown-Tutorial.md","hash":"122324cc345247c074637151e3fd0e5290b43a28","modified":1710337882578},{"_id":"source/_posts/OS-Develop-1.md","hash":"959380fd8b98281c52d3d5b2aacaa60e473bb60d","modified":1710337882581},{"_id":"source/_posts/OS-Develop-2.md","hash":"a42a7ecf83b34afcaa1bbc1a4c6a72f368a8a281","modified":1710337882590},{"_id":"source/_posts/OS-Develop-3.md","hash":"a2c3cb7c6667a12cdf0262f032a21390ecec7c2c","modified":1710337882593},{"_id":"source/_posts/Data-Struct-3/struct_directed_graphs.png","hash":"e3a53df49c2d0b388df5a10ed003555e5fa7775b","modified":1710337882577},{"_id":"source/_posts/Data-Struct-3/struct_undirected_graphs.png","hash":"f76ecce5d17f3c10e1e1109d4c98f6f300456565","modified":1710337882577},{"_id":"source/_posts/OS-Develop-1/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1710337882581},{"_id":"source/_posts/OS-Develop-1/control_registor.jpeg","hash":"679f23e35e852dc2aff262ca407971f4cacb6e45","modified":1710337882582},{"_id":"source/_posts/OS-Develop-1/common_registor.png","hash":"f0622451de775f6ac80766b42c382f6deac44b63","modified":1710337882582},{"_id":"source/_posts/Data-Struct-1/struct_array.png","hash":"72f29c8029c899a8532068c1f691ea9c708e2590","modified":1710337882563},{"_id":"source/_posts/Data-Struct-1/struct_hash_table.png","hash":"88062f7838d44eca39c1f3273d4b479ce1d21a2c","modified":1710337882567},{"_id":"source/_posts/Data-Struct-1/struct_double_queue.png","hash":"cf3688b63cc8582f7ae6ae2d484fc2c2622be0bf","modified":1710337882564},{"_id":"source/_posts/Data-Struct-1/struct_queue.png","hash":"8804b48951e24b396d41d949b84d3db47fe16902","modified":1710337882570},{"_id":"source/_posts/Data-Struct-1/struct_stack.png","hash":"8903ff4e02c9fb5641ff5061b2ae9b2ef6a46557","modified":1710337882571},{"_id":"source/_posts/Data-Struct-2/complete_binary_tree.png","hash":"c7d7659385e9a7a3e176ee5265b4d801bc707c87","modified":1710337882573},{"_id":"source/_posts/Data-Struct-2/struct_full_binary_tree.png","hash":"00a4cd91478be62a7453db8f4b72a8a287c86d12","modified":1710337882574},{"_id":"source/_posts/Data-Struct-1/hash_table_link_addr.png","hash":"3dfff1d795be73a270580f660bc313a0c40e2413","modified":1710337882562},{"_id":"source/_posts/Data-Struct-1/struct_hash_imp.png","hash":"8044f81ca4e92cc69c4fe867f6866022f088af82","modified":1710337882566},{"_id":"source/_posts/Data-Struct-1/struct_link_list.png","hash":"29417f7005d6ea45894525b6b780c58093aef8e7","modified":1710337882569},{"_id":"source/_posts/Data-Struct-2/struct_tree.png","hash":"79d6fa802fb7d3a6cafecf16fc1d5cba51e475f5","modified":1710337882576},{"_id":"source/_posts/My-Desktop-tools/adb_tool.png","hash":"47966a9a4183226ff7fc5f1b9f6861617db0fa2b","modified":1710337882580},{"_id":"source/_posts/OS-Develop-1/gdt.png","hash":"487d6c2a4aac59c7b6b3b2d53ad21ad9d71f6c55","modified":1710337882589},{"_id":"source/_posts/Algorithm-1/radix_sort.gif","hash":"c1fb6b874f066ec2cf7fcd565051ec9d61896a79","modified":1710337882546},{"_id":"source/_posts/OS-Develop-1/flag_registor.png","hash":"d8654ce9ac80a2801385908660c1f5f923d7b137","modified":1710337882587},{"_id":"source/_posts/OS-Develop-1/cpu_workflow.png","hash":"24ba6e7afdca32c8bcaf0ac6f987f779751ecad8","modified":1710337882584},{"_id":"source/_posts/Algorithm-1/count_sort.gif","hash":"f51b9cc8cf02c104e695753f50229c6d2ba4ab91","modified":1710337882525},{"_id":"source/_posts/Algorithm-1/sort_algorithm.png","hash":"cc78f5b8180a654e4ca3c1ee37938990f204579e","modified":1710337882558},{"_id":"themes/hingle/.gitignore","hash":"1e51bee1ec3527ff3e2d6818a5367b5d81c69038","modified":1710337882601},{"_id":"themes/hingle/LICENSE","hash":"4de1840f7346984f481500155ab438f0fdd12634","modified":1710337882601},{"_id":"themes/hingle/README.md","hash":"71d1762328de3b6eb7c0536c2d414e8221be0742","modified":1710337882601},{"_id":"themes/hingle/_config.yml","hash":"3b63495f728c434ecbae2c3d61d5d7852472e6d3","modified":1710337882602},{"_id":"themes/hingle/_config.example.yml","hash":"fc83bfd27d3ae19e908c04ea696583179e7cc25f","modified":1710337882601},{"_id":"themes/hingle/layout/archive.ejs","hash":"90eff02318b17c6eff80021d9a32c2a680415d29","modified":1710337882605},{"_id":"themes/hingle/layout/index.ejs","hash":"9bcb0ddbe47e19149c6b50b0dc669955d7804caa","modified":1710337882605},{"_id":"themes/hingle/layout/layout.ejs","hash":"6b51c9598139016d4a451cd32ca9076c3a9089d7","modified":1710337882605},{"_id":"themes/hingle/layout/page.ejs","hash":"c0cb64ef3215a041c077d91adc911b2f8380c6c1","modified":1710337882607},{"_id":"themes/hingle/layout/post.ejs","hash":"69cae3890cb41aef16b4bb80ac1b135afa6ca9e8","modified":1710337882607},{"_id":"themes/hingle/source/static/hingle.css","hash":"40faa7ef23ecd7e248bc16d1e73cdcb573ee03dc","modified":1710337882607},{"_id":"themes/hingle/source/static/hingle.js","hash":"cb7c49db65b063d89bca03eee3e2e79af2ada0c1","modified":1710337882608},{"_id":"themes/hingle/source/static/kico.css","hash":"5cfb69fc5cb76f93d39a95ee571160262388659f","modified":1710337882612},{"_id":"themes/hingle/source/static/kico.js","hash":"353d3ece9b5020bdac573c35fece1455e72b40ee","modified":1710337882612},{"_id":"themes/hingle/layout/_partial/archive-list.ejs","hash":"d0ff1db7c10c68230f4ee8f7052bf68aa1301f13","modified":1710337882603},{"_id":"themes/hingle/layout/_partial/footer.ejs","hash":"87fdf554945711875f547e6c086f055fcae1df72","modified":1710337882603},{"_id":"themes/hingle/layout/_partial/header.ejs","hash":"2f13227159607016a577345c974c80fe397666e5","modified":1710337882604},{"_id":"themes/hingle/layout/_partial/social.ejs","hash":"482bf0adfb597d2a3f54a28adde9c9f7c4a93300","modified":1710337882605},{"_id":"themes/hingle/layout/_partial/head.ejs","hash":"3e83286f7fdb7c321e17147b11f9cb04dc4f68f9","modified":1710337882604},{"_id":"themes/hingle/source/static/img/icon.png","hash":"2f02d8ad49d7efee4b49fa6287297dd53a112440","modified":1710337882611},{"_id":"source/_posts/OS-Develop-2/jmp_condition.png","hash":"64ca85a6fad8acbf29426e35871f4bfb3118336e","modified":1710337882593},{"_id":"source/_posts/Algorithm-1/merge_sort.gif","hash":"5f153792344405f72f8f04d1f62c61c54b09c58e","modified":1710337882543},{"_id":"source/_posts/Algorithm-1/quick_sort.gif","hash":"59872dea97baee80e4333917f80c48627f888ed2","modified":1710337882545},{"_id":"source/_posts/Algorithm-1/insertion_sort.gif","hash":"ca62c4dc80eac486ff5ab2807f76e825228b6951","modified":1710337882540},{"_id":"source/images/real_time_mm.png","hash":"c28bb286a80699649eb67dbb24d422731792b2cb","modified":1710337882600},{"_id":"source/_posts/Algorithm-1/bubble_sort.gif","hash":"fd6590aecff7c33327ce82b348004d88d56c6a84","modified":1710337882519},{"_id":"source/_posts/Algorithm-1/selection_sort.gif","hash":"a52157c0615c58066467795c4cd29b6b55a367dc","modified":1710337882550},{"_id":"source/_posts/Algorithm-1/shell_sort.gif","hash":"f48d889185d607a6c1337a674bd4045f40e675b5","modified":1710337882555},{"_id":"source/_posts/Algorithm-1/bucket_sort.gif","hash":"296368f251f92e52c985e19bbd710c82c7b046e0","modified":1710337882523},{"_id":"source/_posts/Algorithm-1/heap_sort.gif","hash":"ef85422ba616c31be79468551be2091f0fede721","modified":1710337882538},{"_id":"public/2022/04/05/Backend-Node/index.html","hash":"e9a644349dcbfba02ed75cbacbb531e573e23d25","modified":1710341007487},{"_id":"public/2022/03/28/OS-Develop-3/index.html","hash":"68fa724198520dda5108dc63de7b3a8e5f75cdf7","modified":1710341007487},{"_id":"public/2022/03/22/OS-Develop-2/index.html","hash":"7c9c09e3a79b389ac5243da8c0af5cf5b81929c9","modified":1710341007487},{"_id":"public/2022/03/17/OS-Develop-1/index.html","hash":"600ad80fa49f67d6554de7993afd1e81a7a09789","modified":1710341007487},{"_id":"public/2022/03/11/My-Desktop-tools/index.html","hash":"2c9729091004e0c68dea404826d3e7da834e2567","modified":1710341007487},{"_id":"public/2022/02/03/Markdown-Tutorial/index.html","hash":"c3194ae0364b06bd0905f7edd75eedc730daf3ef","modified":1710341007487},{"_id":"public/2022/01/22/Algorithm-4/index.html","hash":"fcbe62b7ee01c12f18acaacd7797f4c9678c8df2","modified":1710341007487},{"_id":"public/2022/01/20/Algorithm-3/index.html","hash":"a5152b823027e80a0172bde75fbd9691512ed83f","modified":1710341007487},{"_id":"public/2022/01/18/Algorithm-2/index.html","hash":"925436504d279615f8b4c84d9ac8670761650535","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/index.html","hash":"abe44263d18dbcb8b5e2d6e8f9ad63a5e4cec6e6","modified":1710341007487},{"_id":"public/2022/01/09/Data-Struct-3/index.html","hash":"59e24ac44568f0d6b4a39ff62367eaacabb858f0","modified":1710341007487},{"_id":"public/2022/01/08/Data-Struct-2/index.html","hash":"4643201c68c8d0bdffc4eec15206e755f31c8f79","modified":1710341007487},{"_id":"public/2022/01/05/Data-Struct-1/index.html","hash":"ab379478e6ce73939d270a5f58e952cd2e537323","modified":1710341007487},{"_id":"public/2020/08/15/AOSP-Build/index.html","hash":"8eec43e765d23c225e0e4183a1389ce35bab86ab","modified":1710341007487},{"_id":"public/2019/07/18/Blockchain-wallet/index.html","hash":"0263a890a698303b354ae09ec4192a2a2bc11088","modified":1710341007487},{"_id":"public/archives/index.html","hash":"186473bcfa5116236a7c340a68eb5efb9a1d4fac","modified":1710341007487},{"_id":"public/archives/page/2/index.html","hash":"ff166ed0c7adb7db7fb6310f25a9bd82998d321a","modified":1710341007487},{"_id":"public/archives/2019/index.html","hash":"16ef2c153db0a2eff978dcf0be12add8131ac2b5","modified":1710341007487},{"_id":"public/archives/2019/07/index.html","hash":"867b1b0b2250240bd8b0c32bf95d0ef38686a45f","modified":1710341007487},{"_id":"public/archives/2020/index.html","hash":"b250d8d48c4ef29cea104222abe9213d149882cf","modified":1710341007487},{"_id":"public/archives/2020/08/index.html","hash":"0c6ed79c8da6900aad7ee6ff6eb5a5697d5c678b","modified":1710341007487},{"_id":"public/archives/2022/index.html","hash":"54b812de6ef5d7d161f5c91d145c7c3fa84966e3","modified":1710341007487},{"_id":"public/archives/2022/page/2/index.html","hash":"4a98ad35eebe8e9f574791b5cbb205b0267c2341","modified":1710341007487},{"_id":"public/archives/2022/01/index.html","hash":"3a285dd441eacb863643f878aa41c674eb4252eb","modified":1710341007487},{"_id":"public/archives/2022/02/index.html","hash":"a1114fd1ae04158e51e7914c728349ebd66c9f07","modified":1710341007487},{"_id":"public/archives/2022/03/index.html","hash":"38d607fcd997e9cd6a828189a8bf75aaf6645a24","modified":1710341007487},{"_id":"public/archives/2022/04/index.html","hash":"8e2ca6665bf52df2daa3d1e81dee5d88f2895617","modified":1710341007487},{"_id":"public/index.html","hash":"058e3cbd2589c2feb87baef3ee73fcef08e436fa","modified":1710341007487},{"_id":"public/page/2/index.html","hash":"6ce3126197ef6e055c5e5600a369dd8b3762be39","modified":1710341007487},{"_id":"public/tags/Android/index.html","hash":"b1ddbdea018c711cba98463dca134101ff47f121","modified":1710341007487},{"_id":"public/tags/IT-Basics/index.html","hash":"2eee3887819cb2a042d5eacd9ccf0e086addd856","modified":1710341007487},{"_id":"public/tags/Algorithm/index.html","hash":"0a239801ba2442aa6800f625bc2c6fd6181db72c","modified":1710341007487},{"_id":"public/tags/Blockchain/index.html","hash":"f0c3bf55bf1d6f19369696c79f75251eb4efc788","modified":1710341007487},{"_id":"public/tags/Backend/index.html","hash":"43501fa9b5fe13ae86216de0690c4985a6982435","modified":1710341007487},{"_id":"public/tags/Tool/index.html","hash":"204941d606fb04fc5bbbb83233d342cea5053c6b","modified":1710341007487},{"_id":"public/tags/OS/index.html","hash":"16a10ed16ce7d362a7606e9ee010fcf377d4588b","modified":1710341007487},{"_id":"public/static/img/icon.png","hash":"2f02d8ad49d7efee4b49fa6287297dd53a112440","modified":1710341007487},{"_id":"public/2022/01/09/Data-Struct-3/struct_undirected_graphs.png","hash":"f76ecce5d17f3c10e1e1109d4c98f6f300456565","modified":1710341007487},{"_id":"public/2022/01/09/Data-Struct-3/struct_directed_graphs.png","hash":"e3a53df49c2d0b388df5a10ed003555e5fa7775b","modified":1710341007487},{"_id":"public/2022/03/17/OS-Develop-1/common_registor.png","hash":"f0622451de775f6ac80766b42c382f6deac44b63","modified":1710341007487},{"_id":"public/2022/03/17/OS-Develop-1/control_registor.jpeg","hash":"679f23e35e852dc2aff262ca407971f4cacb6e45","modified":1710341007487},{"_id":"public/static/hingle.css","hash":"40faa7ef23ecd7e248bc16d1e73cdcb573ee03dc","modified":1710341007487},{"_id":"public/static/hingle.js","hash":"cb7c49db65b063d89bca03eee3e2e79af2ada0c1","modified":1710341007487},{"_id":"public/static/kico.css","hash":"5cfb69fc5cb76f93d39a95ee571160262388659f","modified":1710341007487},{"_id":"public/static/kico.js","hash":"353d3ece9b5020bdac573c35fece1455e72b40ee","modified":1710341007487},{"_id":"public/2022/01/05/Data-Struct-1/struct_array.png","hash":"72f29c8029c899a8532068c1f691ea9c708e2590","modified":1710341007487},{"_id":"public/2022/01/05/Data-Struct-1/struct_hash_table.png","hash":"88062f7838d44eca39c1f3273d4b479ce1d21a2c","modified":1710341007487},{"_id":"public/2022/01/05/Data-Struct-1/struct_double_queue.png","hash":"cf3688b63cc8582f7ae6ae2d484fc2c2622be0bf","modified":1710341007487},{"_id":"public/2022/01/05/Data-Struct-1/struct_queue.png","hash":"8804b48951e24b396d41d949b84d3db47fe16902","modified":1710341007487},{"_id":"public/2022/01/05/Data-Struct-1/struct_stack.png","hash":"8903ff4e02c9fb5641ff5061b2ae9b2ef6a46557","modified":1710341007487},{"_id":"public/2022/01/08/Data-Struct-2/struct_full_binary_tree.png","hash":"00a4cd91478be62a7453db8f4b72a8a287c86d12","modified":1710341007487},{"_id":"public/2022/01/08/Data-Struct-2/complete_binary_tree.png","hash":"c7d7659385e9a7a3e176ee5265b4d801bc707c87","modified":1710341007487},{"_id":"public/2022/01/05/Data-Struct-1/hash_table_link_addr.png","hash":"3dfff1d795be73a270580f660bc313a0c40e2413","modified":1710341007487},{"_id":"public/2022/01/05/Data-Struct-1/struct_hash_imp.png","hash":"8044f81ca4e92cc69c4fe867f6866022f088af82","modified":1710341007487},{"_id":"public/2022/01/05/Data-Struct-1/struct_link_list.png","hash":"29417f7005d6ea45894525b6b780c58093aef8e7","modified":1710341007487},{"_id":"public/2022/01/08/Data-Struct-2/struct_tree.png","hash":"79d6fa802fb7d3a6cafecf16fc1d5cba51e475f5","modified":1710341007487},{"_id":"public/2022/03/11/My-Desktop-tools/adb_tool.png","hash":"47966a9a4183226ff7fc5f1b9f6861617db0fa2b","modified":1710341007487},{"_id":"public/2022/03/17/OS-Develop-1/gdt.png","hash":"487d6c2a4aac59c7b6b3b2d53ad21ad9d71f6c55","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/radix_sort.gif","hash":"c1fb6b874f066ec2cf7fcd565051ec9d61896a79","modified":1710341007487},{"_id":"public/2022/03/17/OS-Develop-1/cpu_workflow.png","hash":"24ba6e7afdca32c8bcaf0ac6f987f779751ecad8","modified":1710341007487},{"_id":"public/2022/03/17/OS-Develop-1/flag_registor.png","hash":"d8654ce9ac80a2801385908660c1f5f923d7b137","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/count_sort.gif","hash":"f51b9cc8cf02c104e695753f50229c6d2ba4ab91","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/sort_algorithm.png","hash":"cc78f5b8180a654e4ca3c1ee37938990f204579e","modified":1710341007487},{"_id":"public/2022/03/22/OS-Develop-2/jmp_condition.png","hash":"64ca85a6fad8acbf29426e35871f4bfb3118336e","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/merge_sort.gif","hash":"5f153792344405f72f8f04d1f62c61c54b09c58e","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/quick_sort.gif","hash":"59872dea97baee80e4333917f80c48627f888ed2","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/insertion_sort.gif","hash":"ca62c4dc80eac486ff5ab2807f76e825228b6951","modified":1710341007487},{"_id":"public/images/real_time_mm.png","hash":"c28bb286a80699649eb67dbb24d422731792b2cb","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/bubble_sort.gif","hash":"fd6590aecff7c33327ce82b348004d88d56c6a84","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/shell_sort.gif","hash":"f48d889185d607a6c1337a674bd4045f40e675b5","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/selection_sort.gif","hash":"a52157c0615c58066467795c4cd29b6b55a367dc","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/bucket_sort.gif","hash":"296368f251f92e52c985e19bbd710c82c7b046e0","modified":1710341007487},{"_id":"public/2022/01/17/Algorithm-1/heap_sort.gif","hash":"ef85422ba616c31be79468551be2091f0fede721","modified":1710341007487}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"AOSP Build","date":"2020-08-15T07:27:45.000Z","_content":"\n### 安装Repo\n1，下载\n{% codeblock %}\n$mkdir ~/bin\n$PATH=~/bin:$PATH\n$curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n$chmod a+x ~/bin/repo\n{% endcodeblock %}\n\n2，将repo url改为国内镜像url\n将REPO_URL = 'https://gerrit.googlesource.com/git-repo'，改为\nREPO_URL = 'https://aosp.tuna.tsinghua.edu.cn/android/git-repo'\n\n\n### 检出分支\n{% codeblock %}\n$mkdir AOSP\n$cd AOSP\n$repo init -u https://aosp.tuna.tsinghua.edu.cn/android/platform/manifest\n$repo init -u https://aosp.tuna.tsinghua.edu.cn/android/platform/manifest -b android-9.0.0_r18\n{% endcodeblock %}\n\n### 下载源码\n{% codeblock %}\n$repo sync\n{% endcodeblock %}\n\n### 安装jdk\n{% codeblock %}\n$sudo apt-get install openjdk-8-jdk\n{% endcodeblock %}\n\n### 安装依赖\n{% codeblock %}\n$sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386\n$sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib\n$sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386\n$sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib\n$sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev \n$sudo apt-get install lib32z-dev ccache\n{% endcodeblock %}\n\n### 配置ccache\n{% codeblock %}\n$export USE_CCACHE=1  (在你home主目录的.bashrc中加入)\n$export CCACHE_DIR=/home/ubuntu/.ccache  (指定一个缓存目录，也可以不指定，默认目录为你当前用户目录下的.ccache)\n$prebuilts/misc/linux-x86/ccache/ccache -M 50G （这个命令在Android源码中，缓存大小按照自己的硬盘来适当调整）\n$source ~/.bashrc  （source命令使修改立即生效）\n{% endcodeblock %}\n\n### 编译\n{% codeblock %}\n//向shell脚本中写入环境变量\n$source build/envsetup.sh\n// 选择构建目标\n$lunch (lunch选定的版本按照实际情况来)\n// 开始编译\n$make -j16  （和cpu有关，适当调整数字）\n{% endcodeblock %}\n\n### 启动模拟器\n{% codeblock %}\n//在编译完成后可以直接运行，若关闭了终端, 或重新加载了环境, 则有可能导致执行错误,建议执行前确认是否已经执行\n//source ./build/envsetup.sh\n//lunch xxxx\n$ emulator\n{% endcodeblock %}\n\n### 遇到的问题\n1，prebuilts/clang/host/linux-x86/clang-3289846/bin/clang.real: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory\n{% codeblock %}\n//安装依赖库\nsudo apt install libncurses5\n{% endcodeblock %}\n\n\n2，解决python版本问题\n{% codeblock %}\n//安装python2.7\nsudo apt-get install python2-minimal\n// 重置软连接\nsudo ln -s /usr/bin/python2.7 python\n{% endcodeblock %}\n\n3，[  2% 1921/83098] Lex: checkpolicy <= external/selinux/checkpolicy/policy_scan.l\nFAILED: out/host/linux-x86/obj/EXECUTABLES/checkpolicy_intermediates/policy_scan.c \n/bin/bash -c \"prebuilts/misc/linux-x86/flex/flex-2.5.39 -oout/host/linux-x86/obj/EXECUTABLES/checkpolicy_intermediates/policy_scan.c external/selinux/checkpolicy/policy_scan.l\"\nflex-2.5.39: loadlocale.c:130: _nl_intern_locale_data: Assertion `cnt < (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))' failed.\n\n{% codeblock %}\n//重新编译flex\ncd prebuilts/misc/linux-x86/flex\nrm flex-2.5.39\ntar zxf flex-2.5.39.tar.gz\ncd flex-2.5.39\n./configure\nmake\nmv flex ../\ncd ../\nrm -rf flex-2.5.39\nmv flex flex-2.5.39\n{% endcodeblock %}\n\n4，android p build failing - apache-xml_intermediates - hiddenapi\n{% codeblock %}\n$ make clean-ims-common\n$ make ims-common\n$ make apache-xml\n$ make -j12\n{% endcodeblock %}\n\n5，Try increasing heap size with java option '-Xmx<size>'\n{% codeblock %}\n$export JACK_SERVER_VM_ARGUMENTS=\"-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g\"\n$./prebuilts/sdk/tools/jack-admin kill-server\n$./prebuilts/sdk/tools/jack-admin start-server\n{% endcodeblock %}\n\n6，make sdk\nSDK: warning: including GNU target out/target/product/generic/system/lib/libext2fs.so SDK: warning: including GNU target out/target/product/generic/system/lib/libiprouteutil.so\n\nSDK: warning: including GNU target out/target/product/generic/system/lib/libmicrohttpd.so\n\nSDK: warning: including GNU target out/target/product/generic/system/lib/libnetlink.so\n\nSDK: warning: including GNU target out/target/product/generic/system/lib/libnl.so\n\nSDK: warning: including GNU target out/target/product/generic/system/lib/libxmlrpc++.so\n\nSDK: warning: including GNU target out/target/product/generic/system/xbin/fio\n\nSDK: warning: including GNU target out/target/product/generic/system/xbin/mmc_utils\n\ndevelopment/build/sdk.atree:49: couldn't locate source file: bin/etc1tool\n\ndevelopment/build/sdk.atree:83: couldn't locate source file: bin/split-select\n\ndevelopment/build/sdk.atree:88: couldn't locate source file: bin/bcc_compat\n\ndevelopment/build/sdk.atree:203: couldn't locate source file: framework/layoutlib.jar\n\ndevelopment/build/sdk.atree:588: couldn't locate source file: framework/layoutlib-tests.jar\n\ndevelopment/build/sdk.atree:589: couldn't locate source file: system/app/EmulatorSmokeTests/EmulatorSmokeTests.apk\n\nninja: build stopped: subcommand failed.\n\nmake: *** [ninja_wrapper] Error 1\n{% codeblock %}\n注释以上development/build/sdk.atree 中的 49 83 88 203 586 589行的内容   再次make sdk\n编译成功，在相关目录下生成以下的文件:\nPackage SDK: out/host/linux-x86/sdk/aosp_arm/android-sdk_eng.builder_linux-x86.zip\n{% endcodeblock %}\n\n\n\n\n\n\n","source":"_posts/AOSP-Build.md","raw":"---\ntitle: AOSP Build\ndate: 2020-08-15 15:27:45\ntags:\n    - Android\n---\n\n### 安装Repo\n1，下载\n{% codeblock %}\n$mkdir ~/bin\n$PATH=~/bin:$PATH\n$curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\n$chmod a+x ~/bin/repo\n{% endcodeblock %}\n\n2，将repo url改为国内镜像url\n将REPO_URL = 'https://gerrit.googlesource.com/git-repo'，改为\nREPO_URL = 'https://aosp.tuna.tsinghua.edu.cn/android/git-repo'\n\n\n### 检出分支\n{% codeblock %}\n$mkdir AOSP\n$cd AOSP\n$repo init -u https://aosp.tuna.tsinghua.edu.cn/android/platform/manifest\n$repo init -u https://aosp.tuna.tsinghua.edu.cn/android/platform/manifest -b android-9.0.0_r18\n{% endcodeblock %}\n\n### 下载源码\n{% codeblock %}\n$repo sync\n{% endcodeblock %}\n\n### 安装jdk\n{% codeblock %}\n$sudo apt-get install openjdk-8-jdk\n{% endcodeblock %}\n\n### 安装依赖\n{% codeblock %}\n$sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386\n$sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib\n$sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386\n$sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib\n$sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev \n$sudo apt-get install lib32z-dev ccache\n{% endcodeblock %}\n\n### 配置ccache\n{% codeblock %}\n$export USE_CCACHE=1  (在你home主目录的.bashrc中加入)\n$export CCACHE_DIR=/home/ubuntu/.ccache  (指定一个缓存目录，也可以不指定，默认目录为你当前用户目录下的.ccache)\n$prebuilts/misc/linux-x86/ccache/ccache -M 50G （这个命令在Android源码中，缓存大小按照自己的硬盘来适当调整）\n$source ~/.bashrc  （source命令使修改立即生效）\n{% endcodeblock %}\n\n### 编译\n{% codeblock %}\n//向shell脚本中写入环境变量\n$source build/envsetup.sh\n// 选择构建目标\n$lunch (lunch选定的版本按照实际情况来)\n// 开始编译\n$make -j16  （和cpu有关，适当调整数字）\n{% endcodeblock %}\n\n### 启动模拟器\n{% codeblock %}\n//在编译完成后可以直接运行，若关闭了终端, 或重新加载了环境, 则有可能导致执行错误,建议执行前确认是否已经执行\n//source ./build/envsetup.sh\n//lunch xxxx\n$ emulator\n{% endcodeblock %}\n\n### 遇到的问题\n1，prebuilts/clang/host/linux-x86/clang-3289846/bin/clang.real: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory\n{% codeblock %}\n//安装依赖库\nsudo apt install libncurses5\n{% endcodeblock %}\n\n\n2，解决python版本问题\n{% codeblock %}\n//安装python2.7\nsudo apt-get install python2-minimal\n// 重置软连接\nsudo ln -s /usr/bin/python2.7 python\n{% endcodeblock %}\n\n3，[  2% 1921/83098] Lex: checkpolicy <= external/selinux/checkpolicy/policy_scan.l\nFAILED: out/host/linux-x86/obj/EXECUTABLES/checkpolicy_intermediates/policy_scan.c \n/bin/bash -c \"prebuilts/misc/linux-x86/flex/flex-2.5.39 -oout/host/linux-x86/obj/EXECUTABLES/checkpolicy_intermediates/policy_scan.c external/selinux/checkpolicy/policy_scan.l\"\nflex-2.5.39: loadlocale.c:130: _nl_intern_locale_data: Assertion `cnt < (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))' failed.\n\n{% codeblock %}\n//重新编译flex\ncd prebuilts/misc/linux-x86/flex\nrm flex-2.5.39\ntar zxf flex-2.5.39.tar.gz\ncd flex-2.5.39\n./configure\nmake\nmv flex ../\ncd ../\nrm -rf flex-2.5.39\nmv flex flex-2.5.39\n{% endcodeblock %}\n\n4，android p build failing - apache-xml_intermediates - hiddenapi\n{% codeblock %}\n$ make clean-ims-common\n$ make ims-common\n$ make apache-xml\n$ make -j12\n{% endcodeblock %}\n\n5，Try increasing heap size with java option '-Xmx<size>'\n{% codeblock %}\n$export JACK_SERVER_VM_ARGUMENTS=\"-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g\"\n$./prebuilts/sdk/tools/jack-admin kill-server\n$./prebuilts/sdk/tools/jack-admin start-server\n{% endcodeblock %}\n\n6，make sdk\nSDK: warning: including GNU target out/target/product/generic/system/lib/libext2fs.so SDK: warning: including GNU target out/target/product/generic/system/lib/libiprouteutil.so\n\nSDK: warning: including GNU target out/target/product/generic/system/lib/libmicrohttpd.so\n\nSDK: warning: including GNU target out/target/product/generic/system/lib/libnetlink.so\n\nSDK: warning: including GNU target out/target/product/generic/system/lib/libnl.so\n\nSDK: warning: including GNU target out/target/product/generic/system/lib/libxmlrpc++.so\n\nSDK: warning: including GNU target out/target/product/generic/system/xbin/fio\n\nSDK: warning: including GNU target out/target/product/generic/system/xbin/mmc_utils\n\ndevelopment/build/sdk.atree:49: couldn't locate source file: bin/etc1tool\n\ndevelopment/build/sdk.atree:83: couldn't locate source file: bin/split-select\n\ndevelopment/build/sdk.atree:88: couldn't locate source file: bin/bcc_compat\n\ndevelopment/build/sdk.atree:203: couldn't locate source file: framework/layoutlib.jar\n\ndevelopment/build/sdk.atree:588: couldn't locate source file: framework/layoutlib-tests.jar\n\ndevelopment/build/sdk.atree:589: couldn't locate source file: system/app/EmulatorSmokeTests/EmulatorSmokeTests.apk\n\nninja: build stopped: subcommand failed.\n\nmake: *** [ninja_wrapper] Error 1\n{% codeblock %}\n注释以上development/build/sdk.atree 中的 49 83 88 203 586 589行的内容   再次make sdk\n编译成功，在相关目录下生成以下的文件:\nPackage SDK: out/host/linux-x86/sdk/aosp_arm/android-sdk_eng.builder_linux-x86.zip\n{% endcodeblock %}\n\n\n\n\n\n\n","slug":"AOSP-Build","published":1,"updated":"2024-03-13T14:43:19.140Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjqr0000em3i1lob7hts","content":"<h3 id=\"安装Repo\"><a href=\"#安装Repo\" class=\"headerlink\" title=\"安装Repo\"></a>安装Repo</h3><p>1，下载</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> ~/bin</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">PATH=~/bin:<span class=\"hljs-variable\">$PATH</span></span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">chmod</span> a+x ~/bin/repo</span><br></code></pre></td></tr></table></figure>\n\n<p>2，将repo url改为国内镜像url<br>将REPO_URL &#x3D; ‘<a href=\"https://gerrit.googlesource.com/git-repo'%EF%BC%8C%E6%94%B9%E4%B8%BA\">https://gerrit.googlesource.com/git-repo&#39;，改为</a><br>REPO_URL &#x3D; ‘<a href=\"https://aosp.tuna.tsinghua.edu.cn/android/git-repo\">https://aosp.tuna.tsinghua.edu.cn/android/git-repo</a>‘</p>\n<h3 id=\"检出分支\"><a href=\"#检出分支\" class=\"headerlink\" title=\"检出分支\"></a>检出分支</h3><figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-variable\">$mkdir</span> AOSP<br><span class=\"hljs-variable\">$cd</span> AOSP<br><span class=\"hljs-variable\">$repo</span> init -u https:<span class=\"hljs-regexp\">//</span>aosp.tuna.tsinghua.edu.cn<span class=\"hljs-regexp\">/android/</span>platform/manifest<br><span class=\"hljs-variable\">$repo</span> init -u https:<span class=\"hljs-regexp\">//</span>aosp.tuna.tsinghua.edu.cn<span class=\"hljs-regexp\">/android/</span>platform/manifest -b android-<span class=\"hljs-number\">9.0</span>.<span class=\"hljs-number\">0</span>_r18<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"下载源码\"><a href=\"#下载源码\" class=\"headerlink\" title=\"下载源码\"></a>下载源码</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$repo</span> <span class=\"hljs-built_in\">sync</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h3><figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install openjdk-8-jdk<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install -y git flex bison gperf build-essential libncurses5-dev:i386<br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib<br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386<br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install zip curl zlib1g-dev gcc-multilib g++-multilib<br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install lib32ncurses5-dev x11proto-core-dev libx11-dev <br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install lib32z-dev ccache<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置ccache\"><a href=\"#配置ccache\" class=\"headerlink\" title=\"配置ccache\"></a>配置ccache</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">export</span> USE_CCACHE=1  (在你home主目录的.bashrc中加入)</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">export</span> CCACHE_DIR=/home/ubuntu/.ccache  (指定一个缓存目录，也可以不指定，默认目录为你当前用户目录下的.ccache)</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">prebuilts/misc/linux-x86/ccache/ccache -M 50G （这个命令在Android源码中，缓存大小按照自己的硬盘来适当调整）</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">source</span> ~/.bashrc  （<span class=\"hljs-built_in\">source</span>命令使修改立即生效）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><figure class=\"highlight gams\"><table><tr><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//向shell脚本中写入环境变量</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$source</span> build/envsetup.sh</span><br><span class=\"hljs-comment\">// 选择构建目标</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$lunch</span> (lunch选定的版本按照实际情况来)</span><br><span class=\"hljs-comment\">// 开始编译</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$make</span> -j16  （和cpu有关，适当调整数字）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"启动模拟器\"><a href=\"#启动模拟器\" class=\"headerlink\" title=\"启动模拟器\"></a>启动模拟器</h3><figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span>在编译完成后可以直接运行，若关闭了终端, 或重新加载了环境, 则有可能导致执行错误,建议执行前确认是否已经执行<br><span class=\"hljs-regexp\">//</span>source .<span class=\"hljs-regexp\">/build/</span>envsetup.sh<br><span class=\"hljs-regexp\">//</span>lunch xxxx<br>$ emulator<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><p>1，prebuilts&#x2F;clang&#x2F;host&#x2F;linux-x86&#x2F;clang-3289846&#x2F;bin&#x2F;clang.real: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//安装依赖库</span><br>sudo apt install libncurses5<br></code></pre></td></tr></table></figure>\n\n\n<p>2，解决python版本问题</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"code\"><pre><code class=\"hljs sqf\"><span class=\"hljs-comment\">//安装python2.7</span><br>sudo apt-<span class=\"hljs-built_in\">get</span> install python2-minimal<br><span class=\"hljs-comment\">// 重置软连接</span><br>sudo <span class=\"hljs-built_in\">ln</span> -s /usr/bin/python2.<span class=\"hljs-number\">7</span> python<br></code></pre></td></tr></table></figure>\n\n<p>3，[  2% 1921&#x2F;83098] Lex: checkpolicy &lt;&#x3D; external&#x2F;selinux&#x2F;checkpolicy&#x2F;policy_scan.l<br>FAILED: out&#x2F;host&#x2F;linux-x86&#x2F;obj&#x2F;EXECUTABLES&#x2F;checkpolicy_intermediates&#x2F;policy_scan.c<br>&#x2F;bin&#x2F;bash -c “prebuilts&#x2F;misc&#x2F;linux-x86&#x2F;flex&#x2F;flex-2.5.39 -oout&#x2F;host&#x2F;linux-x86&#x2F;obj&#x2F;EXECUTABLES&#x2F;checkpolicy_intermediates&#x2F;policy_scan.c external&#x2F;selinux&#x2F;checkpolicy&#x2F;policy_scan.l”<br>flex-2.5.39: loadlocale.c:130: _nl_intern_locale_data: Assertion &#96;cnt &lt; (sizeof (_nl_value_type_LC_TIME) &#x2F; sizeof (_nl_value_type_LC_TIME[0]))’ failed.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">//重新编译flex<br><span class=\"hljs-built_in\">cd</span> prebuilts/misc/linux-x86/flex<br><span class=\"hljs-built_in\">rm</span> flex-2.5.39<br>tar zxf flex-2.5.39.tar.gz<br><span class=\"hljs-built_in\">cd</span> flex-2.5.39<br>./configure<br>make<br><span class=\"hljs-built_in\">mv</span> flex ../<br><span class=\"hljs-built_in\">cd</span> ../<br><span class=\"hljs-built_in\">rm</span> -rf flex-2.5.39<br><span class=\"hljs-built_in\">mv</span> flex flex-2.5.39<br></code></pre></td></tr></table></figure>\n\n<p>4，android p build failing - apache-xml_intermediates - hiddenapi</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>make clean-ims-common<br><span class=\"hljs-variable\">$ </span>make ims-common<br><span class=\"hljs-variable\">$ </span>make apache-xml<br><span class=\"hljs-variable\">$ </span>make -j12<br></code></pre></td></tr></table></figure>\n\n<p>5，Try increasing heap size with java option ‘-Xmx<size>‘</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">export</span> JACK_SERVER_VM_ARGUMENTS=<span class=\"hljs-string\">&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g&quot;</span></span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">./prebuilts/sdk/tools/jack-admin kill-server</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">./prebuilts/sdk/tools/jack-admin start-server</span><br></code></pre></td></tr></table></figure>\n\n<p>6，make sdk<br>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libext2fs.so SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libiprouteutil.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libmicrohttpd.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libnetlink.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libnl.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libxmlrpc++.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;xbin&#x2F;fio</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;xbin&#x2F;mmc_utils</p>\n<p>development&#x2F;build&#x2F;sdk.atree:49: couldn’t locate source file: bin&#x2F;etc1tool</p>\n<p>development&#x2F;build&#x2F;sdk.atree:83: couldn’t locate source file: bin&#x2F;split-select</p>\n<p>development&#x2F;build&#x2F;sdk.atree:88: couldn’t locate source file: bin&#x2F;bcc_compat</p>\n<p>development&#x2F;build&#x2F;sdk.atree:203: couldn’t locate source file: framework&#x2F;layoutlib.jar</p>\n<p>development&#x2F;build&#x2F;sdk.atree:588: couldn’t locate source file: framework&#x2F;layoutlib-tests.jar</p>\n<p>development&#x2F;build&#x2F;sdk.atree:589: couldn’t locate source file: system&#x2F;app&#x2F;EmulatorSmokeTests&#x2F;EmulatorSmokeTests.apk</p>\n<p>ninja: build stopped: subcommand failed.</p>\n<p>make: *** [ninja_wrapper] Error 1</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><code class=\"hljs gradle\">注释以上development<span class=\"hljs-regexp\">/build/</span>sdk.atree 中的 <span class=\"hljs-number\">49</span> <span class=\"hljs-number\">83</span> <span class=\"hljs-number\">88</span> <span class=\"hljs-number\">203</span> <span class=\"hljs-number\">586</span> <span class=\"hljs-number\">589</span>行的内容   再次make sdk<br>编译成功，在相关目录下生成以下的文件:<br><span class=\"hljs-keyword\">Package</span> SDK: out<span class=\"hljs-regexp\">/host/</span>linux-x86<span class=\"hljs-regexp\">/sdk/</span>aosp_arm/android-sdk_eng.builder_linux-x86.zip<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n","excerpt":"","more":"<h3 id=\"安装Repo\"><a href=\"#安装Repo\" class=\"headerlink\" title=\"安装Repo\"></a>安装Repo</h3><p>1，下载</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">mkdir</span> ~/bin</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">PATH=~/bin:<span class=\"hljs-variable\">$PATH</span></span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">chmod</span> a+x ~/bin/repo</span><br></code></pre></td></tr></table></figure>\n\n<p>2，将repo url改为国内镜像url<br>将REPO_URL &#x3D; ‘<a href=\"https://gerrit.googlesource.com/git-repo'%EF%BC%8C%E6%94%B9%E4%B8%BA\">https://gerrit.googlesource.com/git-repo&#39;，改为</a><br>REPO_URL &#x3D; ‘<a href=\"https://aosp.tuna.tsinghua.edu.cn/android/git-repo\">https://aosp.tuna.tsinghua.edu.cn/android/git-repo</a>‘</p>\n<h3 id=\"检出分支\"><a href=\"#检出分支\" class=\"headerlink\" title=\"检出分支\"></a>检出分支</h3><figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-variable\">$mkdir</span> AOSP<br><span class=\"hljs-variable\">$cd</span> AOSP<br><span class=\"hljs-variable\">$repo</span> init -u https:<span class=\"hljs-regexp\">//</span>aosp.tuna.tsinghua.edu.cn<span class=\"hljs-regexp\">/android/</span>platform/manifest<br><span class=\"hljs-variable\">$repo</span> init -u https:<span class=\"hljs-regexp\">//</span>aosp.tuna.tsinghua.edu.cn<span class=\"hljs-regexp\">/android/</span>platform/manifest -b android-<span class=\"hljs-number\">9.0</span>.<span class=\"hljs-number\">0</span>_r18<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"下载源码\"><a href=\"#下载源码\" class=\"headerlink\" title=\"下载源码\"></a>下载源码</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-variable\">$repo</span> <span class=\"hljs-built_in\">sync</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h3><figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install openjdk-8-jdk<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install -y git flex bison gperf build-essential libncurses5-dev:i386<br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib<br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386<br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install zip curl zlib1g-dev gcc-multilib g++-multilib<br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install lib32ncurses5-dev x11proto-core-dev libx11-dev <br><span class=\"hljs-variable\">$sudo</span> apt-<span class=\"hljs-built_in\">get</span> install lib32z-dev ccache<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"配置ccache\"><a href=\"#配置ccache\" class=\"headerlink\" title=\"配置ccache\"></a>配置ccache</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">export</span> USE_CCACHE=1  (在你home主目录的.bashrc中加入)</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">export</span> CCACHE_DIR=/home/ubuntu/.ccache  (指定一个缓存目录，也可以不指定，默认目录为你当前用户目录下的.ccache)</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">prebuilts/misc/linux-x86/ccache/ccache -M 50G （这个命令在Android源码中，缓存大小按照自己的硬盘来适当调整）</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">source</span> ~/.bashrc  （<span class=\"hljs-built_in\">source</span>命令使修改立即生效）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><figure class=\"highlight gams\"><table><tr><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-comment\">//向shell脚本中写入环境变量</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$source</span> build/envsetup.sh</span><br><span class=\"hljs-comment\">// 选择构建目标</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$lunch</span> (lunch选定的版本按照实际情况来)</span><br><span class=\"hljs-comment\">// 开始编译</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$make</span> -j16  （和cpu有关，适当调整数字）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"启动模拟器\"><a href=\"#启动模拟器\" class=\"headerlink\" title=\"启动模拟器\"></a>启动模拟器</h3><figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span>在编译完成后可以直接运行，若关闭了终端, 或重新加载了环境, 则有可能导致执行错误,建议执行前确认是否已经执行<br><span class=\"hljs-regexp\">//</span>source .<span class=\"hljs-regexp\">/build/</span>envsetup.sh<br><span class=\"hljs-regexp\">//</span>lunch xxxx<br>$ emulator<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><p>1，prebuilts&#x2F;clang&#x2F;host&#x2F;linux-x86&#x2F;clang-3289846&#x2F;bin&#x2F;clang.real: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-comment\">//安装依赖库</span><br>sudo apt install libncurses5<br></code></pre></td></tr></table></figure>\n\n\n<p>2，解决python版本问题</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"code\"><pre><code class=\"hljs sqf\"><span class=\"hljs-comment\">//安装python2.7</span><br>sudo apt-<span class=\"hljs-built_in\">get</span> install python2-minimal<br><span class=\"hljs-comment\">// 重置软连接</span><br>sudo <span class=\"hljs-built_in\">ln</span> -s /usr/bin/python2.<span class=\"hljs-number\">7</span> python<br></code></pre></td></tr></table></figure>\n\n<p>3，[  2% 1921&#x2F;83098] Lex: checkpolicy &lt;&#x3D; external&#x2F;selinux&#x2F;checkpolicy&#x2F;policy_scan.l<br>FAILED: out&#x2F;host&#x2F;linux-x86&#x2F;obj&#x2F;EXECUTABLES&#x2F;checkpolicy_intermediates&#x2F;policy_scan.c<br>&#x2F;bin&#x2F;bash -c “prebuilts&#x2F;misc&#x2F;linux-x86&#x2F;flex&#x2F;flex-2.5.39 -oout&#x2F;host&#x2F;linux-x86&#x2F;obj&#x2F;EXECUTABLES&#x2F;checkpolicy_intermediates&#x2F;policy_scan.c external&#x2F;selinux&#x2F;checkpolicy&#x2F;policy_scan.l”<br>flex-2.5.39: loadlocale.c:130: _nl_intern_locale_data: Assertion &#96;cnt &lt; (sizeof (_nl_value_type_LC_TIME) &#x2F; sizeof (_nl_value_type_LC_TIME[0]))’ failed.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">//重新编译flex<br><span class=\"hljs-built_in\">cd</span> prebuilts/misc/linux-x86/flex<br><span class=\"hljs-built_in\">rm</span> flex-2.5.39<br>tar zxf flex-2.5.39.tar.gz<br><span class=\"hljs-built_in\">cd</span> flex-2.5.39<br>./configure<br>make<br><span class=\"hljs-built_in\">mv</span> flex ../<br><span class=\"hljs-built_in\">cd</span> ../<br><span class=\"hljs-built_in\">rm</span> -rf flex-2.5.39<br><span class=\"hljs-built_in\">mv</span> flex flex-2.5.39<br></code></pre></td></tr></table></figure>\n\n<p>4，android p build failing - apache-xml_intermediates - hiddenapi</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-variable\">$ </span>make clean-ims-common<br><span class=\"hljs-variable\">$ </span>make ims-common<br><span class=\"hljs-variable\">$ </span>make apache-xml<br><span class=\"hljs-variable\">$ </span>make -j12<br></code></pre></td></tr></table></figure>\n\n<p>5，Try increasing heap size with java option ‘-Xmx<size>‘</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\"><span class=\"hljs-built_in\">export</span> JACK_SERVER_VM_ARGUMENTS=<span class=\"hljs-string\">&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g&quot;</span></span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">./prebuilts/sdk/tools/jack-admin kill-server</span><br><span class=\"hljs-meta prompt_\">$</span><span class=\"language-bash\">./prebuilts/sdk/tools/jack-admin start-server</span><br></code></pre></td></tr></table></figure>\n\n<p>6，make sdk<br>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libext2fs.so SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libiprouteutil.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libmicrohttpd.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libnetlink.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libnl.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;lib&#x2F;libxmlrpc++.so</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;xbin&#x2F;fio</p>\n<p>SDK: warning: including GNU target out&#x2F;target&#x2F;product&#x2F;generic&#x2F;system&#x2F;xbin&#x2F;mmc_utils</p>\n<p>development&#x2F;build&#x2F;sdk.atree:49: couldn’t locate source file: bin&#x2F;etc1tool</p>\n<p>development&#x2F;build&#x2F;sdk.atree:83: couldn’t locate source file: bin&#x2F;split-select</p>\n<p>development&#x2F;build&#x2F;sdk.atree:88: couldn’t locate source file: bin&#x2F;bcc_compat</p>\n<p>development&#x2F;build&#x2F;sdk.atree:203: couldn’t locate source file: framework&#x2F;layoutlib.jar</p>\n<p>development&#x2F;build&#x2F;sdk.atree:588: couldn’t locate source file: framework&#x2F;layoutlib-tests.jar</p>\n<p>development&#x2F;build&#x2F;sdk.atree:589: couldn’t locate source file: system&#x2F;app&#x2F;EmulatorSmokeTests&#x2F;EmulatorSmokeTests.apk</p>\n<p>ninja: build stopped: subcommand failed.</p>\n<p>make: *** [ninja_wrapper] Error 1</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><code class=\"hljs gradle\">注释以上development<span class=\"hljs-regexp\">/build/</span>sdk.atree 中的 <span class=\"hljs-number\">49</span> <span class=\"hljs-number\">83</span> <span class=\"hljs-number\">88</span> <span class=\"hljs-number\">203</span> <span class=\"hljs-number\">586</span> <span class=\"hljs-number\">589</span>行的内容   再次make sdk<br>编译成功，在相关目录下生成以下的文件:<br><span class=\"hljs-keyword\">Package</span> SDK: out<span class=\"hljs-regexp\">/host/</span>linux-x86<span class=\"hljs-regexp\">/sdk/</span>aosp_arm/android-sdk_eng.builder_linux-x86.zip<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n"},{"title":"Algorithm 1","date":"2022-01-17T11:22:54.000Z","_content":"\n### 简介\n算法第一章，讨论排序算法。\n{% asset_img sort_algorithm.png sort algorithm %}\n\n### 插入排序\n- 从第一个元素开始，该元素可以认为已经被排序；\n- 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n- 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n将新元素插入到该位置后；\n- 重复步骤2~5。\n{% asset_img insertion_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while (preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex + 1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex + 1] = current;\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n### 冒泡排序\n- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n- 针对所有的元素重复以上的步骤，除了最后一个；\n- 重复步骤1~3，直到排序完成。\n{% asset_img bubble_sort.gif bubble sort %}\n\n{% codeblock %}\n    function bubbleSort(arr) {\n        var len = arr.length;\n        for (var i = 0; i < len - 1; i++) {\n            for (var j = 0; j < len - 1 - i; j++) {\n                if (arr[j] > arr[j+1]) {        // 相邻元素两两对比\n                    var temp = arr[j+1];        // 元素交换\n                    arr[j+1] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n        return arr;\n    }\n{% endcodeblock %}\n\n### 选择排序\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n\n- 初始状态：无序区为R[1..n]，有序区为空；\n- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n- n-1趟结束，数组有序化了。\n{% asset_img selection_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     // 寻找最小的数\n                minIndex = j;                 // 将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n} \n{% endcodeblock %}\n\n### 希尔排序\n- 先选定一个整数gap，把待排序文件中所有元素分成gap组，即所有距离为gap的分在同一组内，并对每一组内的元素进行直接插入排序（本质是进行预排序，使数组更接近有序，目的是使最后一次直接插入排序提高效率）；\n- 取gap=gap/2或者gap=gap/3+1重复上述分组和排序的工作；\n- 当gap到达1时，数组是已经接近有序的，当gap=1，即以一个元素为一组，就相当于对整个数组进行直接插入排序了。\n{% asset_img shell_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction shellSort(arr) {\n    var len = arr.length;\n    for (var gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行\n        for (var i = gap; i < len; i++) {\n            var j = i;\n            var current = arr[i];\n            while (j - gap >= 0 && current < arr[j - gap]) {\n                 arr[j] = arr[j - gap];\n                 j = j - gap;\n            }\n            arr[j] = current;\n        }\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n### 归并排序\n- 把长度为n的输入序列分成两个长度为n/2的子序列；\n- 对这两个子序列分别采用归并排序；\n- 将两个排序好的子序列合并成一个最终的排序序列。\n{% asset_img merge_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction mergeSort(arr) {\n    var len = arr.length;\n    if (len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n \nfunction merge(left, right) {\n    var result = [];\n \n    while (left.length>0 && right.length>0) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n \n    while (left.length)\n        result.push(left.shift());\n \n    while (right.length)\n        result.push(right.shift());\n \n    return result;\n}\n{% endcodeblock %}\n\n### 快速排序\n- 从数列中挑出一个元素，称为 “基准”（pivot）；\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n{% asset_img quick_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction quickSort(arr, left, right) {\n    var len = arr.length,\n        partitionIndex,\n        left = typeof left != 'number' ? 0 : left,\n        right = typeof right != 'number' ? len - 1 : right;\n \n    if (left < right) {\n        partitionIndex = partition(arr, left, right);\n        quickSort(arr, left, partitionIndex-1);\n        quickSort(arr, partitionIndex+1, right);\n    }\n    return arr;\n}\n \nfunction partition(arr, left ,right) {     // 分区操作\n    var pivot = left,                      // 设定基准值（pivot）\n        index = pivot + 1;\n    for (var i = index; i <= right; i++) {\n        if (arr[i] < arr[pivot]) {\n            swap(arr, i, index);\n            index++;\n        }       \n    }\n    swap(arr, pivot, index - 1);\n    return index-1;\n}\n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n{% endcodeblock %}\n\n### 堆排序\n- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\n- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\n- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n{% asset_img heap_sort.gif bubble sort %}\n\n{% codeblock %}\nvar len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量\n \nfunction buildMaxHeap(arr) {   // 建立大顶堆\n    len = arr.length;\n    for (var i = Math.floor(len/2); i >= 0; i--) {\n        heapify(arr, i);\n    }\n}\n \nfunction heapify(arr, i) {     // 堆调整\n    var left = 2 * i + 1,\n        right = 2 * i + 2,\n        largest = i;\n \n    if (left < len && arr[left] > arr[largest]) {\n        largest = left;\n    }\n \n    if (right < len && arr[right] > arr[largest]) {\n        largest = right;\n    }\n \n    if (largest != i) {\n        swap(arr, i, largest);\n        heapify(arr, largest);\n    }\n}\n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n \nfunction heapSort(arr) {\n    buildMaxHeap(arr);\n \n    for (var i = arr.length - 1; i > 0; i--) {\n        swap(arr, 0, i);\n        len--;\n        heapify(arr, 0);\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n\n### 计数排序\n- 找出待排序的数组中最大和最小的元素；\n- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\n- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\n- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\n{% asset_img count_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction countingSort(arr, maxValue) {\n    var bucket = new Array(maxValue + 1),\n        sortedIndex = 0;\n        arrLen = arr.length,\n        bucketLen = maxValue + 1;\n \n    for (var i = 0; i < arrLen; i++) {\n        if (!bucket[arr[i]]) {\n            bucket[arr[i]] = 0;\n        }\n        bucket[arr[i]]++;\n    }\n \n    for (var j = 0; j < bucketLen; j++) {\n        while(bucket[j] > 0) {\n            arr[sortedIndex++] = j;\n            bucket[j]--;\n        }\n    }\n \n    return arr;\n}\n{% endcodeblock %}\n\n\n### 桶排序\n- 设置一个定量的数组当作空桶；\n- 遍历输入数据，并且把数据一个一个放到对应的桶里去；\n- 对每个不是空的桶进行排序；\n- 从不是空的桶里把排好序的数据拼接起来。\n{% asset_img bucket_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction bucketSort(arr, bucketSize) {\n    if (arr.length === 0) {\n      return arr;\n    }\n \n    var i;\n    var minValue = arr[0];\n    var maxValue = arr[0];\n    for (i = 1; i < arr.length; i++) {\n      if (arr[i] < minValue) {\n          minValue = arr[i];                // 输入数据的最小值\n      } else if (arr[i] > maxValue) {\n          maxValue = arr[i];                // 输入数据的最大值\n      }\n    }\n \n    // 桶的初始化\n    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5\n    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\n    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  \n    var buckets = new Array(bucketCount);\n    for (i = 0; i < buckets.length; i++) {\n        buckets[i] = [];\n    }\n \n    // 利用映射函数将数据分配到各个桶中\n    for (i = 0; i < arr.length; i++) {\n        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);\n    }\n \n    arr.length = 0;\n    for (i = 0; i < buckets.length; i++) {\n        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序\n        for (var j = 0; j < buckets[i].length; j++) {\n            arr.push(buckets[i][j]);                     \n        }\n    }\n \n    return arr;\n}\n{% endcodeblock %}\n\n\n### 基数排序\n- 取得数组中的最大数，并取得位数；\n- arr为原始数组，从最低位开始取每个位组成radix数组；\n- 对radix进行计数排序（利用计数排序适用于小范围数的特点）；\n{% asset_img radix_sort.gif bubble sort %}\n\n{% codeblock %}\nvar counter = [];\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]==null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Algorithm-1.md","raw":"---\ntitle: Algorithm 1\ndate: 2022-01-17 19:22:54\ntags: \n    - IT-Basics\n    - Algorithm\n---\n\n### 简介\n算法第一章，讨论排序算法。\n{% asset_img sort_algorithm.png sort algorithm %}\n\n### 插入排序\n- 从第一个元素开始，该元素可以认为已经被排序；\n- 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n- 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n将新元素插入到该位置后；\n- 重复步骤2~5。\n{% asset_img insertion_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while (preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex + 1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex + 1] = current;\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n### 冒泡排序\n- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n- 针对所有的元素重复以上的步骤，除了最后一个；\n- 重复步骤1~3，直到排序完成。\n{% asset_img bubble_sort.gif bubble sort %}\n\n{% codeblock %}\n    function bubbleSort(arr) {\n        var len = arr.length;\n        for (var i = 0; i < len - 1; i++) {\n            for (var j = 0; j < len - 1 - i; j++) {\n                if (arr[j] > arr[j+1]) {        // 相邻元素两两对比\n                    var temp = arr[j+1];        // 元素交换\n                    arr[j+1] = arr[j];\n                    arr[j] = temp;\n                }\n            }\n        }\n        return arr;\n    }\n{% endcodeblock %}\n\n### 选择排序\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n\n- 初始状态：无序区为R[1..n]，有序区为空；\n- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n- n-1趟结束，数组有序化了。\n{% asset_img selection_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     // 寻找最小的数\n                minIndex = j;                 // 将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n} \n{% endcodeblock %}\n\n### 希尔排序\n- 先选定一个整数gap，把待排序文件中所有元素分成gap组，即所有距离为gap的分在同一组内，并对每一组内的元素进行直接插入排序（本质是进行预排序，使数组更接近有序，目的是使最后一次直接插入排序提高效率）；\n- 取gap=gap/2或者gap=gap/3+1重复上述分组和排序的工作；\n- 当gap到达1时，数组是已经接近有序的，当gap=1，即以一个元素为一组，就相当于对整个数组进行直接插入排序了。\n{% asset_img shell_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction shellSort(arr) {\n    var len = arr.length;\n    for (var gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {\n        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行\n        for (var i = gap; i < len; i++) {\n            var j = i;\n            var current = arr[i];\n            while (j - gap >= 0 && current < arr[j - gap]) {\n                 arr[j] = arr[j - gap];\n                 j = j - gap;\n            }\n            arr[j] = current;\n        }\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n### 归并排序\n- 把长度为n的输入序列分成两个长度为n/2的子序列；\n- 对这两个子序列分别采用归并排序；\n- 将两个排序好的子序列合并成一个最终的排序序列。\n{% asset_img merge_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction mergeSort(arr) {\n    var len = arr.length;\n    if (len < 2) {\n        return arr;\n    }\n    var middle = Math.floor(len / 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n \nfunction merge(left, right) {\n    var result = [];\n \n    while (left.length>0 && right.length>0) {\n        if (left[0] <= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n \n    while (left.length)\n        result.push(left.shift());\n \n    while (right.length)\n        result.push(right.shift());\n \n    return result;\n}\n{% endcodeblock %}\n\n### 快速排序\n- 从数列中挑出一个元素，称为 “基准”（pivot）；\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n{% asset_img quick_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction quickSort(arr, left, right) {\n    var len = arr.length,\n        partitionIndex,\n        left = typeof left != 'number' ? 0 : left,\n        right = typeof right != 'number' ? len - 1 : right;\n \n    if (left < right) {\n        partitionIndex = partition(arr, left, right);\n        quickSort(arr, left, partitionIndex-1);\n        quickSort(arr, partitionIndex+1, right);\n    }\n    return arr;\n}\n \nfunction partition(arr, left ,right) {     // 分区操作\n    var pivot = left,                      // 设定基准值（pivot）\n        index = pivot + 1;\n    for (var i = index; i <= right; i++) {\n        if (arr[i] < arr[pivot]) {\n            swap(arr, i, index);\n            index++;\n        }       \n    }\n    swap(arr, pivot, index - 1);\n    return index-1;\n}\n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n{% endcodeblock %}\n\n### 堆排序\n- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\n- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\n- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n{% asset_img heap_sort.gif bubble sort %}\n\n{% codeblock %}\nvar len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量\n \nfunction buildMaxHeap(arr) {   // 建立大顶堆\n    len = arr.length;\n    for (var i = Math.floor(len/2); i >= 0; i--) {\n        heapify(arr, i);\n    }\n}\n \nfunction heapify(arr, i) {     // 堆调整\n    var left = 2 * i + 1,\n        right = 2 * i + 2,\n        largest = i;\n \n    if (left < len && arr[left] > arr[largest]) {\n        largest = left;\n    }\n \n    if (right < len && arr[right] > arr[largest]) {\n        largest = right;\n    }\n \n    if (largest != i) {\n        swap(arr, i, largest);\n        heapify(arr, largest);\n    }\n}\n \nfunction swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n}\n \nfunction heapSort(arr) {\n    buildMaxHeap(arr);\n \n    for (var i = arr.length - 1; i > 0; i--) {\n        swap(arr, 0, i);\n        len--;\n        heapify(arr, 0);\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n\n### 计数排序\n- 找出待排序的数组中最大和最小的元素；\n- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\n- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\n- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\n{% asset_img count_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction countingSort(arr, maxValue) {\n    var bucket = new Array(maxValue + 1),\n        sortedIndex = 0;\n        arrLen = arr.length,\n        bucketLen = maxValue + 1;\n \n    for (var i = 0; i < arrLen; i++) {\n        if (!bucket[arr[i]]) {\n            bucket[arr[i]] = 0;\n        }\n        bucket[arr[i]]++;\n    }\n \n    for (var j = 0; j < bucketLen; j++) {\n        while(bucket[j] > 0) {\n            arr[sortedIndex++] = j;\n            bucket[j]--;\n        }\n    }\n \n    return arr;\n}\n{% endcodeblock %}\n\n\n### 桶排序\n- 设置一个定量的数组当作空桶；\n- 遍历输入数据，并且把数据一个一个放到对应的桶里去；\n- 对每个不是空的桶进行排序；\n- 从不是空的桶里把排好序的数据拼接起来。\n{% asset_img bucket_sort.gif bubble sort %}\n\n{% codeblock %}\nfunction bucketSort(arr, bucketSize) {\n    if (arr.length === 0) {\n      return arr;\n    }\n \n    var i;\n    var minValue = arr[0];\n    var maxValue = arr[0];\n    for (i = 1; i < arr.length; i++) {\n      if (arr[i] < minValue) {\n          minValue = arr[i];                // 输入数据的最小值\n      } else if (arr[i] > maxValue) {\n          maxValue = arr[i];                // 输入数据的最大值\n      }\n    }\n \n    // 桶的初始化\n    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5\n    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;\n    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  \n    var buckets = new Array(bucketCount);\n    for (i = 0; i < buckets.length; i++) {\n        buckets[i] = [];\n    }\n \n    // 利用映射函数将数据分配到各个桶中\n    for (i = 0; i < arr.length; i++) {\n        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);\n    }\n \n    arr.length = 0;\n    for (i = 0; i < buckets.length; i++) {\n        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序\n        for (var j = 0; j < buckets[i].length; j++) {\n            arr.push(buckets[i][j]);                     \n        }\n    }\n \n    return arr;\n}\n{% endcodeblock %}\n\n\n### 基数排序\n- 取得数组中的最大数，并取得位数；\n- arr为原始数组，从最低位开始取每个位组成radix数组；\n- 对radix进行计数排序（利用计数排序适用于小范围数的特点）；\n{% asset_img radix_sort.gif bubble sort %}\n\n{% codeblock %}\nvar counter = [];\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {\n        for(var j = 0; j < arr.length; j++) {\n            var bucket = parseInt((arr[j] % mod) / dev);\n            if(counter[bucket]==null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j < counter.length; j++) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos++] = value;\n                }\n          }\n        }\n    }\n    return arr;\n}\n{% endcodeblock %}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Algorithm-1","published":1,"updated":"2024-03-13T13:51:22.516Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjqw0001em3i8lt30i6e","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第一章，讨论排序算法。</p>\n<img src=\"/2022/01/17/Algorithm-1/sort_algorithm.png\" class=\"\" title=\"sort algorithm\">\n\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；</li>\n<li>重复步骤2~5。<img src=\"/2022/01/17/Algorithm-1/insertion_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight nsis\"><table><tr><td class=\"code\"><pre><code class=\"hljs nsis\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">insertionSort</span>(arr) &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">len</span> = arr.length<span class=\"hljs-comment\">;</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">preIndex</span>, <span class=\"hljs-literal\">current</span><span class=\"hljs-comment\">;</span><br>    for (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> = <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">; i &lt; len; i++) &#123;</span><br>        preIndex = i - <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>        <span class=\"hljs-literal\">current</span> = arr[i]<span class=\"hljs-comment\">;</span><br>        while (preIndex &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[preIndex] &gt; <span class=\"hljs-literal\">current</span>) &#123;<br>            arr[preIndex + <span class=\"hljs-number\">1</span>] = arr[preIndex]<span class=\"hljs-comment\">;</span><br>            preIndex--<span class=\"hljs-comment\">;</span><br>        &#125;<br>        arr[preIndex + <span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">current</span><span class=\"hljs-comment\">;</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr<span class=\"hljs-comment\">;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。<img src=\"/2022/01/17/Algorithm-1/bubble_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bubbleSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; len - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; len - <span class=\"hljs-number\">1</span> - i; j++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"hljs-number\">1</span>]) &#123;        <span class=\"hljs-comment\">// 相邻元素两两对比</span><br>                <span class=\"hljs-keyword\">var</span> temp = arr[j+<span class=\"hljs-number\">1</span>];        <span class=\"hljs-comment\">// 元素交换</span><br>                arr[j+<span class=\"hljs-number\">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>\n<ul>\n<li>初始状态：无序区为R[1..n]，有序区为空；</li>\n<li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li>n-1趟结束，数组有序化了。<img src=\"/2022/01/17/Algorithm-1/selection_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">selectionSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">var</span> minIndex, temp;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; len - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        minIndex = i;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; len; j++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class=\"hljs-comment\">// 寻找最小的数</span><br>                minIndex = j;                 <span class=\"hljs-comment\">// 将最小数的索引保存</span><br>            &#125;<br>        &#125;<br>        temp = arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125; <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><ul>\n<li>先选定一个整数gap，把待排序文件中所有元素分成gap组，即所有距离为gap的分在同一组内，并对每一组内的元素进行直接插入排序（本质是进行预排序，使数组更接近有序，目的是使最后一次直接插入排序提高效率）；</li>\n<li>取gap&#x3D;gap&#x2F;2或者gap&#x3D;gap&#x2F;3+1重复上述分组和排序的工作；</li>\n<li>当gap到达1时，数组是已经接近有序的，当gap&#x3D;1，即以一个元素为一组，就相当于对整个数组进行直接插入排序了。<img src=\"/2022/01/17/Algorithm-1/shell_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">shellSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> gap = Math.<span class=\"hljs-built_in\">floor</span>(len / <span class=\"hljs-number\">2</span>); gap &gt; <span class=\"hljs-number\">0</span>; gap = Math.<span class=\"hljs-built_in\">floor</span>(gap / <span class=\"hljs-number\">2</span>)) &#123;<br>        <span class=\"hljs-comment\">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = gap; i &lt; len; i++) &#123;<br>            <span class=\"hljs-keyword\">var</span> j = i;<br>            <span class=\"hljs-keyword\">var</span> current = arr[i];<br>            <span class=\"hljs-keyword\">while</span> (j - gap &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;<br>                 arr[j] = arr[j - gap];<br>                 j = j - gap;<br>            &#125;<br>            arr[j] = current;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。<img src=\"/2022/01/17/Algorithm-1/merge_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mergeSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">if</span> (len &lt; <span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br>    <span class=\"hljs-keyword\">var</span> middle = Math.<span class=\"hljs-built_in\">floor</span>(len / <span class=\"hljs-number\">2</span>),<br>        <span class=\"hljs-built_in\">left</span> = arr.<span class=\"hljs-built_in\">slice</span>(<span class=\"hljs-number\">0</span>, middle),<br>        <span class=\"hljs-built_in\">right</span> = arr.<span class=\"hljs-built_in\">slice</span>(middle);<br>    <span class=\"hljs-keyword\">return</span> merge(mergeSort(<span class=\"hljs-built_in\">left</span>), mergeSort(<span class=\"hljs-built_in\">right</span>));<br>&#125;<br> <br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">left, right</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = [];<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">left</span>.<span class=\"hljs-built_in\">length</span>&gt;<span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-built_in\">right</span>.<span class=\"hljs-built_in\">length</span>&gt;<span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">left</span>[<span class=\"hljs-number\">0</span>] &lt;= <span class=\"hljs-built_in\">right</span>[<span class=\"hljs-number\">0</span>]) &#123;<br>            result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">left</span>.shift());<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">right</span>.shift());<br>        &#125;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">left</span>.<span class=\"hljs-built_in\">length</span>)<br>        result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">left</span>.shift());<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">right</span>.<span class=\"hljs-built_in\">length</span>)<br>        result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">right</span>.shift());<br> <br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ul>\n<img src=\"/2022/01/17/Algorithm-1/quick_sort.gif\" class=\"\" title=\"bubble sort\">\n\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><code class=\"hljs excel\">function quickSort(arr, <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">right</span>) &#123;<br>    <span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">len</span> = arr.length,<br>        partitionIndex,<br>        <span class=\"hljs-built_in\">left</span> = typeof <span class=\"hljs-built_in\">left</span> != &#x27;number&#x27; ? <span class=\"hljs-number\">0</span> <span class=\"hljs-symbol\">:</span> <span class=\"hljs-built_in\">left</span>,<br>        <span class=\"hljs-built_in\">right</span> = typeof <span class=\"hljs-built_in\">right</span> != &#x27;number&#x27; ? <span class=\"hljs-built_in\">len</span> - <span class=\"hljs-number\">1</span> <span class=\"hljs-symbol\">:</span> <span class=\"hljs-built_in\">right</span>;<br> <br>    <span class=\"hljs-built_in\">if</span> (<span class=\"hljs-built_in\">left</span> &lt; <span class=\"hljs-built_in\">right</span>) &#123;<br>        partitionIndex = partition(arr, <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">right</span>);<br>        quickSort(arr, <span class=\"hljs-built_in\">left</span>, partitionIndex-<span class=\"hljs-number\">1</span>);<br>        quickSort(arr, partitionIndex+<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">right</span>);<br>    &#125;<br>    return arr;<br>&#125;<br> <br>function partition(arr, <span class=\"hljs-built_in\">left</span> ,<span class=\"hljs-built_in\">right</span>) &#123;     // 分区操作<br>    <span class=\"hljs-built_in\">var</span> pivot = <span class=\"hljs-built_in\">left</span>,                      // 设定基准值（pivot）<br>        <span class=\"hljs-built_in\">index</span> = pivot + <span class=\"hljs-number\">1</span>;<br>    for (<span class=\"hljs-built_in\">var</span> i = <span class=\"hljs-built_in\">index</span>; i &lt;= <span class=\"hljs-built_in\">right</span>; i++) &#123;<br>        <span class=\"hljs-built_in\">if</span> (arr[i] &lt; arr[pivot]) &#123;<br>            swap(arr, i, <span class=\"hljs-built_in\">index</span>);<br>            <span class=\"hljs-built_in\">index</span>++;<br>        &#125;       <br>    &#125;<br>    swap(arr, pivot, <span class=\"hljs-built_in\">index</span> - <span class=\"hljs-number\">1</span>);<br>    return <span class=\"hljs-built_in\">index</span>-<span class=\"hljs-number\">1</span>;<br>&#125;<br> <br>function swap(arr, i, j) &#123;<br>    <span class=\"hljs-built_in\">var</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>\n<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<img src=\"/2022/01/17/Algorithm-1/heap_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight wren\"><table><tr><td class=\"code\"><pre><code class=\"hljs wren\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">len</span>;    <span class=\"hljs-comment\">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">buildMaxHeap</span>(<span class=\"hljs-params\">arr</span>) &#123;   <span class=\"hljs-comment\">// 建立大顶堆</span><br>    <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>.<span class=\"hljs-property\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">floor</span>(<span class=\"hljs-variable\">len</span>/<span class=\"hljs-number\">2</span>); <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">i</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>) &#123;<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">i</span>);<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-params\">arr</span>, <span class=\"hljs-params\">i</span>) &#123;     <span class=\"hljs-comment\">// 堆调整</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span>,<br>        <span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">2</span>,<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">i</span>;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">&amp;&amp;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">left</span>] <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">largest</span>]) &#123;<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">left</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">&amp;&amp;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">right</span>] <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">largest</span>]) &#123;<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">right</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">!=</span> <span class=\"hljs-variable\">i</span>) &#123;<br>        <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">i</span>, <span class=\"hljs-variable\">largest</span>);<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">largest</span>);<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-params\">arr</span>, <span class=\"hljs-params\">i</span>, <span class=\"hljs-params\">j</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>];<br>    <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">j</span>];<br>    <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">j</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">temp</span>;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">heapSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-title function_\">buildMaxHeap</span>(<span class=\"hljs-variable\">arr</span>);<br> <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>.<span class=\"hljs-property\">length</span> <span class=\"hljs-operator\">-</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">i</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>) &#123;<br>        <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable\">i</span>);<br>        <span class=\"hljs-variable\">len</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>;<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-number\">0</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable\">arr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<img src=\"/2022/01/17/Algorithm-1/count_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><code class=\"hljs mipsasm\">function countingSort(arr, maxValue) &#123;<br>    var <span class=\"hljs-keyword\">bucket </span>= new Array(maxValue + <span class=\"hljs-number\">1</span>),<br>        sortedIndex = <span class=\"hljs-number\">0</span>;<br>        arrLen = arr.length,<br>        <span class=\"hljs-keyword\">bucketLen </span>= maxValue + <span class=\"hljs-number\">1</span>;<br> <br>    for (var i = <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; i &lt; arrLen; i++) &#123;</span><br>        if (!<span class=\"hljs-keyword\">bucket[arr[i]]) </span>&#123;<br>            <span class=\"hljs-keyword\">bucket[arr[i]] </span>= <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">bucket[arr[i]]++;</span><br><span class=\"hljs-keyword\"></span>    &#125;<br> <br>    for (var <span class=\"hljs-keyword\">j </span>= <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; j &lt; bucketLen; j++) &#123;</span><br>        while(<span class=\"hljs-keyword\">bucket[j] </span>&gt; <span class=\"hljs-number\">0</span>) &#123;<br>            arr[sortedIndex++] = <span class=\"hljs-keyword\">j;</span><br><span class=\"hljs-keyword\"></span>            <span class=\"hljs-keyword\">bucket[j]--;</span><br><span class=\"hljs-keyword\"></span>        &#125;<br>    &#125;<br> <br>    return arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li>设置一个定量的数组当作空桶；</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>对每个不是空的桶进行排序；</li>\n<li>从不是空的桶里把排好序的数据拼接起来。<img src=\"/2022/01/17/Algorithm-1/bucket_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bucketSort</span>(<span class=\"hljs-params\">arr, bucketSize</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (arr.<span class=\"hljs-built_in\">length</span> === <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">var</span> i;<br>    <span class=\"hljs-keyword\">var</span> minValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">var</span> maxValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">1</span>; i &lt; arr.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; minValue) &#123;<br>          minValue = arr[i];                <span class=\"hljs-comment\">// 输入数据的最小值</span><br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[i] &gt; maxValue) &#123;<br>          maxValue = arr[i];                <span class=\"hljs-comment\">// 输入数据的最大值</span><br>      &#125;<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// 桶的初始化</span><br>    <span class=\"hljs-keyword\">var</span> DEFAULT_BUCKET_SIZE = <span class=\"hljs-number\">5</span>;            <span class=\"hljs-comment\">// 设置桶的默认数量为5</span><br>    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;<br>    <span class=\"hljs-keyword\">var</span> bucketCount = Math.<span class=\"hljs-built_in\">floor</span>((maxValue - minValue) / bucketSize) + <span class=\"hljs-number\">1</span>;  <br>    <span class=\"hljs-keyword\">var</span> buckets = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(bucketCount);<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; buckets.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        buckets[i] = [];<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// 利用映射函数将数据分配到各个桶中</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        buckets[Math.<span class=\"hljs-built_in\">floor</span>((arr[i] - minValue) / bucketSize)].<span class=\"hljs-built_in\">push</span>(arr[i]);<br>    &#125;<br> <br>    arr.<span class=\"hljs-built_in\">length</span> = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; buckets.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        insertionSort(buckets[i]);                      <span class=\"hljs-comment\">// 对每个桶进行排序，这里使用了插入排序</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; buckets[i].<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            arr.<span class=\"hljs-built_in\">push</span>(buckets[i][j]);                     <br>        &#125;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><ul>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>\n<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；<img src=\"/2022/01/17/Algorithm-1/radix_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">var</span> counter = [];<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">radixSort</span>(<span class=\"hljs-params\">arr, maxDigit</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> mod = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">var</span> dev = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; maxDigit; i++, dev *= <span class=\"hljs-number\">10</span>, mod *= <span class=\"hljs-number\">10</span>) &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; arr.<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            <span class=\"hljs-keyword\">var</span> bucket = parseInt((arr[j] % mod) / dev);<br>            <span class=\"hljs-keyword\">if</span>(counter[bucket]==<span class=\"hljs-literal\">null</span>) &#123;<br>                counter[bucket] = [];<br>            &#125;<br>            counter[bucket].<span class=\"hljs-built_in\">push</span>(arr[j]);<br>        &#125;<br>        <span class=\"hljs-keyword\">var</span> pos = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; counter.<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-literal\">null</span>;<br>            <span class=\"hljs-keyword\">if</span>(counter[j]!=<span class=\"hljs-literal\">null</span>) &#123;<br>                <span class=\"hljs-keyword\">while</span> ((value = counter[j].shift()) != <span class=\"hljs-literal\">null</span>) &#123;<br>                      arr[pos++] = value;<br>                &#125;<br>          &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第一章，讨论排序算法。</p>\n<img src=\"/2022/01/17/Algorithm-1/sort_algorithm.png\" class=\"\" title=\"sort algorithm\">\n\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；<br>将新元素插入到该位置后；</li>\n<li>重复步骤2~5。<img src=\"/2022/01/17/Algorithm-1/insertion_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight nsis\"><table><tr><td class=\"code\"><pre><code class=\"hljs nsis\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">insertionSort</span>(arr) &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">len</span> = arr.length<span class=\"hljs-comment\">;</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">preIndex</span>, <span class=\"hljs-literal\">current</span><span class=\"hljs-comment\">;</span><br>    for (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> = <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">; i &lt; len; i++) &#123;</span><br>        preIndex = i - <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br>        <span class=\"hljs-literal\">current</span> = arr[i]<span class=\"hljs-comment\">;</span><br>        while (preIndex &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; arr[preIndex] &gt; <span class=\"hljs-literal\">current</span>) &#123;<br>            arr[preIndex + <span class=\"hljs-number\">1</span>] = arr[preIndex]<span class=\"hljs-comment\">;</span><br>            preIndex--<span class=\"hljs-comment\">;</span><br>        &#125;<br>        arr[preIndex + <span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">current</span><span class=\"hljs-comment\">;</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr<span class=\"hljs-comment\">;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。<img src=\"/2022/01/17/Algorithm-1/bubble_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bubbleSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; len - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; len - <span class=\"hljs-number\">1</span> - i; j++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[j] &gt; arr[j+<span class=\"hljs-number\">1</span>]) &#123;        <span class=\"hljs-comment\">// 相邻元素两两对比</span><br>                <span class=\"hljs-keyword\">var</span> temp = arr[j+<span class=\"hljs-number\">1</span>];        <span class=\"hljs-comment\">// 元素交换</span><br>                arr[j+<span class=\"hljs-number\">1</span>] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>\n<ul>\n<li>初始状态：无序区为R[1..n]，有序区为空；</li>\n<li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li>n-1趟结束，数组有序化了。<img src=\"/2022/01/17/Algorithm-1/selection_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">selectionSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">var</span> minIndex, temp;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; len - <span class=\"hljs-number\">1</span>; i++) &#123;<br>        minIndex = i;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; len; j++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class=\"hljs-comment\">// 寻找最小的数</span><br>                minIndex = j;                 <span class=\"hljs-comment\">// 将最小数的索引保存</span><br>            &#125;<br>        &#125;<br>        temp = arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125; <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><ul>\n<li>先选定一个整数gap，把待排序文件中所有元素分成gap组，即所有距离为gap的分在同一组内，并对每一组内的元素进行直接插入排序（本质是进行预排序，使数组更接近有序，目的是使最后一次直接插入排序提高效率）；</li>\n<li>取gap&#x3D;gap&#x2F;2或者gap&#x3D;gap&#x2F;3+1重复上述分组和排序的工作；</li>\n<li>当gap到达1时，数组是已经接近有序的，当gap&#x3D;1，即以一个元素为一组，就相当于对整个数组进行直接插入排序了。<img src=\"/2022/01/17/Algorithm-1/shell_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">shellSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> gap = Math.<span class=\"hljs-built_in\">floor</span>(len / <span class=\"hljs-number\">2</span>); gap &gt; <span class=\"hljs-number\">0</span>; gap = Math.<span class=\"hljs-built_in\">floor</span>(gap / <span class=\"hljs-number\">2</span>)) &#123;<br>        <span class=\"hljs-comment\">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = gap; i &lt; len; i++) &#123;<br>            <span class=\"hljs-keyword\">var</span> j = i;<br>            <span class=\"hljs-keyword\">var</span> current = arr[i];<br>            <span class=\"hljs-keyword\">while</span> (j - gap &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;<br>                 arr[j] = arr[j - gap];<br>                 j = j - gap;<br>            &#125;<br>            arr[j] = current;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。<img src=\"/2022/01/17/Algorithm-1/merge_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mergeSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> len = arr.<span class=\"hljs-built_in\">length</span>;<br>    <span class=\"hljs-keyword\">if</span> (len &lt; <span class=\"hljs-number\">2</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br>    <span class=\"hljs-keyword\">var</span> middle = Math.<span class=\"hljs-built_in\">floor</span>(len / <span class=\"hljs-number\">2</span>),<br>        <span class=\"hljs-built_in\">left</span> = arr.<span class=\"hljs-built_in\">slice</span>(<span class=\"hljs-number\">0</span>, middle),<br>        <span class=\"hljs-built_in\">right</span> = arr.<span class=\"hljs-built_in\">slice</span>(middle);<br>    <span class=\"hljs-keyword\">return</span> merge(mergeSort(<span class=\"hljs-built_in\">left</span>), mergeSort(<span class=\"hljs-built_in\">right</span>));<br>&#125;<br> <br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">merge</span>(<span class=\"hljs-params\">left, right</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> result = [];<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">left</span>.<span class=\"hljs-built_in\">length</span>&gt;<span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-built_in\">right</span>.<span class=\"hljs-built_in\">length</span>&gt;<span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">left</span>[<span class=\"hljs-number\">0</span>] &lt;= <span class=\"hljs-built_in\">right</span>[<span class=\"hljs-number\">0</span>]) &#123;<br>            result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">left</span>.shift());<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">right</span>.shift());<br>        &#125;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">left</span>.<span class=\"hljs-built_in\">length</span>)<br>        result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">left</span>.shift());<br> <br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">right</span>.<span class=\"hljs-built_in\">length</span>)<br>        result.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">right</span>.shift());<br> <br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ul>\n<img src=\"/2022/01/17/Algorithm-1/quick_sort.gif\" class=\"\" title=\"bubble sort\">\n\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><code class=\"hljs excel\">function quickSort(arr, <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">right</span>) &#123;<br>    <span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">len</span> = arr.length,<br>        partitionIndex,<br>        <span class=\"hljs-built_in\">left</span> = typeof <span class=\"hljs-built_in\">left</span> != &#x27;number&#x27; ? <span class=\"hljs-number\">0</span> <span class=\"hljs-symbol\">:</span> <span class=\"hljs-built_in\">left</span>,<br>        <span class=\"hljs-built_in\">right</span> = typeof <span class=\"hljs-built_in\">right</span> != &#x27;number&#x27; ? <span class=\"hljs-built_in\">len</span> - <span class=\"hljs-number\">1</span> <span class=\"hljs-symbol\">:</span> <span class=\"hljs-built_in\">right</span>;<br> <br>    <span class=\"hljs-built_in\">if</span> (<span class=\"hljs-built_in\">left</span> &lt; <span class=\"hljs-built_in\">right</span>) &#123;<br>        partitionIndex = partition(arr, <span class=\"hljs-built_in\">left</span>, <span class=\"hljs-built_in\">right</span>);<br>        quickSort(arr, <span class=\"hljs-built_in\">left</span>, partitionIndex-<span class=\"hljs-number\">1</span>);<br>        quickSort(arr, partitionIndex+<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">right</span>);<br>    &#125;<br>    return arr;<br>&#125;<br> <br>function partition(arr, <span class=\"hljs-built_in\">left</span> ,<span class=\"hljs-built_in\">right</span>) &#123;     // 分区操作<br>    <span class=\"hljs-built_in\">var</span> pivot = <span class=\"hljs-built_in\">left</span>,                      // 设定基准值（pivot）<br>        <span class=\"hljs-built_in\">index</span> = pivot + <span class=\"hljs-number\">1</span>;<br>    for (<span class=\"hljs-built_in\">var</span> i = <span class=\"hljs-built_in\">index</span>; i &lt;= <span class=\"hljs-built_in\">right</span>; i++) &#123;<br>        <span class=\"hljs-built_in\">if</span> (arr[i] &lt; arr[pivot]) &#123;<br>            swap(arr, i, <span class=\"hljs-built_in\">index</span>);<br>            <span class=\"hljs-built_in\">index</span>++;<br>        &#125;       <br>    &#125;<br>    swap(arr, pivot, <span class=\"hljs-built_in\">index</span> - <span class=\"hljs-number\">1</span>);<br>    return <span class=\"hljs-built_in\">index</span>-<span class=\"hljs-number\">1</span>;<br>&#125;<br> <br>function swap(arr, i, j) &#123;<br>    <span class=\"hljs-built_in\">var</span> temp = arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li>\n<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<img src=\"/2022/01/17/Algorithm-1/heap_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight wren\"><table><tr><td class=\"code\"><pre><code class=\"hljs wren\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">len</span>;    <span class=\"hljs-comment\">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">buildMaxHeap</span>(<span class=\"hljs-params\">arr</span>) &#123;   <span class=\"hljs-comment\">// 建立大顶堆</span><br>    <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>.<span class=\"hljs-property\">length</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">floor</span>(<span class=\"hljs-variable\">len</span>/<span class=\"hljs-number\">2</span>); <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">i</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>) &#123;<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">i</span>);<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-params\">arr</span>, <span class=\"hljs-params\">i</span>) &#123;     <span class=\"hljs-comment\">// 堆调整</span><br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span>,<br>        <span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">2</span>,<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">i</span>;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">&amp;&amp;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">left</span>] <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">largest</span>]) &#123;<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">left</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-variable\">len</span> <span class=\"hljs-operator\">&amp;&amp;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">right</span>] <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">largest</span>]) &#123;<br>        <span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">right</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">largest</span> <span class=\"hljs-operator\">!=</span> <span class=\"hljs-variable\">i</span>) &#123;<br>        <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">i</span>, <span class=\"hljs-variable\">largest</span>);<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-variable\">largest</span>);<br>    &#125;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-params\">arr</span>, <span class=\"hljs-params\">i</span>, <span class=\"hljs-params\">j</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>];<br>    <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">i</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">j</span>];<br>    <span class=\"hljs-variable\">arr</span>[<span class=\"hljs-variable\">j</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">temp</span>;<br>&#125;<br> <br><span class=\"hljs-variable\">function</span> <span class=\"hljs-title function_\">heapSort</span>(<span class=\"hljs-params\">arr</span>) &#123;<br>    <span class=\"hljs-title function_\">buildMaxHeap</span>(<span class=\"hljs-variable\">arr</span>);<br> <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">arr</span>.<span class=\"hljs-property\">length</span> <span class=\"hljs-operator\">-</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-variable\">i</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>) &#123;<br>        <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-variable\">i</span>);<br>        <span class=\"hljs-variable\">len</span><span class=\"hljs-operator\">-</span><span class=\"hljs-operator\">-</span>;<br>        <span class=\"hljs-title function_\">heapify</span>(<span class=\"hljs-variable\">arr</span>, <span class=\"hljs-number\">0</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable\">arr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<img src=\"/2022/01/17/Algorithm-1/count_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><code class=\"hljs mipsasm\">function countingSort(arr, maxValue) &#123;<br>    var <span class=\"hljs-keyword\">bucket </span>= new Array(maxValue + <span class=\"hljs-number\">1</span>),<br>        sortedIndex = <span class=\"hljs-number\">0</span>;<br>        arrLen = arr.length,<br>        <span class=\"hljs-keyword\">bucketLen </span>= maxValue + <span class=\"hljs-number\">1</span>;<br> <br>    for (var i = <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; i &lt; arrLen; i++) &#123;</span><br>        if (!<span class=\"hljs-keyword\">bucket[arr[i]]) </span>&#123;<br>            <span class=\"hljs-keyword\">bucket[arr[i]] </span>= <span class=\"hljs-number\">0</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">bucket[arr[i]]++;</span><br><span class=\"hljs-keyword\"></span>    &#125;<br> <br>    for (var <span class=\"hljs-keyword\">j </span>= <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">; j &lt; bucketLen; j++) &#123;</span><br>        while(<span class=\"hljs-keyword\">bucket[j] </span>&gt; <span class=\"hljs-number\">0</span>) &#123;<br>            arr[sortedIndex++] = <span class=\"hljs-keyword\">j;</span><br><span class=\"hljs-keyword\"></span>            <span class=\"hljs-keyword\">bucket[j]--;</span><br><span class=\"hljs-keyword\"></span>        &#125;<br>    &#125;<br> <br>    return arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li>设置一个定量的数组当作空桶；</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>对每个不是空的桶进行排序；</li>\n<li>从不是空的桶里把排好序的数据拼接起来。<img src=\"/2022/01/17/Algorithm-1/bucket_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bucketSort</span>(<span class=\"hljs-params\">arr, bucketSize</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (arr.<span class=\"hljs-built_in\">length</span> === <span class=\"hljs-number\">0</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">var</span> i;<br>    <span class=\"hljs-keyword\">var</span> minValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">var</span> maxValue = arr[<span class=\"hljs-number\">0</span>];<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">1</span>; i &lt; arr.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>      <span class=\"hljs-keyword\">if</span> (arr[i] &lt; minValue) &#123;<br>          minValue = arr[i];                <span class=\"hljs-comment\">// 输入数据的最小值</span><br>      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[i] &gt; maxValue) &#123;<br>          maxValue = arr[i];                <span class=\"hljs-comment\">// 输入数据的最大值</span><br>      &#125;<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// 桶的初始化</span><br>    <span class=\"hljs-keyword\">var</span> DEFAULT_BUCKET_SIZE = <span class=\"hljs-number\">5</span>;            <span class=\"hljs-comment\">// 设置桶的默认数量为5</span><br>    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;<br>    <span class=\"hljs-keyword\">var</span> bucketCount = Math.<span class=\"hljs-built_in\">floor</span>((maxValue - minValue) / bucketSize) + <span class=\"hljs-number\">1</span>;  <br>    <span class=\"hljs-keyword\">var</span> buckets = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(bucketCount);<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; buckets.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        buckets[i] = [];<br>    &#125;<br> <br>    <span class=\"hljs-comment\">// 利用映射函数将数据分配到各个桶中</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        buckets[Math.<span class=\"hljs-built_in\">floor</span>((arr[i] - minValue) / bucketSize)].<span class=\"hljs-built_in\">push</span>(arr[i]);<br>    &#125;<br> <br>    arr.<span class=\"hljs-built_in\">length</span> = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; buckets.<span class=\"hljs-built_in\">length</span>; i++) &#123;<br>        insertionSort(buckets[i]);                      <span class=\"hljs-comment\">// 对每个桶进行排序，这里使用了插入排序</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; buckets[i].<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            arr.<span class=\"hljs-built_in\">push</span>(buckets[i][j]);                     <br>        &#125;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><ul>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>\n<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；<img src=\"/2022/01/17/Algorithm-1/radix_sort.gif\" class=\"\" title=\"bubble sort\"></li>\n</ul>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">var</span> counter = [];<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">radixSort</span>(<span class=\"hljs-params\">arr, maxDigit</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> mod = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">var</span> dev = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; maxDigit; i++, dev *= <span class=\"hljs-number\">10</span>, mod *= <span class=\"hljs-number\">10</span>) &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; arr.<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            <span class=\"hljs-keyword\">var</span> bucket = parseInt((arr[j] % mod) / dev);<br>            <span class=\"hljs-keyword\">if</span>(counter[bucket]==<span class=\"hljs-literal\">null</span>) &#123;<br>                counter[bucket] = [];<br>            &#125;<br>            counter[bucket].<span class=\"hljs-built_in\">push</span>(arr[j]);<br>        &#125;<br>        <span class=\"hljs-keyword\">var</span> pos = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; counter.<span class=\"hljs-built_in\">length</span>; j++) &#123;<br>            <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-literal\">null</span>;<br>            <span class=\"hljs-keyword\">if</span>(counter[j]!=<span class=\"hljs-literal\">null</span>) &#123;<br>                <span class=\"hljs-keyword\">while</span> ((value = counter[j].shift()) != <span class=\"hljs-literal\">null</span>) &#123;<br>                      arr[pos++] = value;<br>                &#125;<br>          &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"Algorithm 2","date":"2022-01-18T05:29:34.000Z","_content":"\n\n### 简介\n算法第二章，讨论搜索算法。\n\n\n\n\n### 回溯算法\n\n\n\n### 深度优先算法\n\n\n\n### 广度优先算法\n\n\n### 剪枝算法\n\n\n### 枚举算法\n\n\n\n","source":"_posts/Algorithm-2.md","raw":"---\ntitle: Algorithm 2\ndate: 2022-01-18 13:29:34\ntags:\n    - IT-Basics\n    - Algorithm\n---\n\n\n### 简介\n算法第二章，讨论搜索算法。\n\n\n\n\n### 回溯算法\n\n\n\n### 深度优先算法\n\n\n\n### 广度优先算法\n\n\n### 剪枝算法\n\n\n### 枚举算法\n\n\n\n","slug":"Algorithm-2","published":1,"updated":"2024-03-13T13:51:22.558Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjr00003em3i0p2eeja4","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第二章，讨论搜索算法。</p>\n<h3 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h3><h3 id=\"深度优先算法\"><a href=\"#深度优先算法\" class=\"headerlink\" title=\"深度优先算法\"></a>深度优先算法</h3><h3 id=\"广度优先算法\"><a href=\"#广度优先算法\" class=\"headerlink\" title=\"广度优先算法\"></a>广度优先算法</h3><h3 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h3><h3 id=\"枚举算法\"><a href=\"#枚举算法\" class=\"headerlink\" title=\"枚举算法\"></a>枚举算法</h3>","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第二章，讨论搜索算法。</p>\n<h3 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h3><h3 id=\"深度优先算法\"><a href=\"#深度优先算法\" class=\"headerlink\" title=\"深度优先算法\"></a>深度优先算法</h3><h3 id=\"广度优先算法\"><a href=\"#广度优先算法\" class=\"headerlink\" title=\"广度优先算法\"></a>广度优先算法</h3><h3 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h3><h3 id=\"枚举算法\"><a href=\"#枚举算法\" class=\"headerlink\" title=\"枚举算法\"></a>枚举算法</h3>"},{"title":"Algorithm 3","date":"2022-01-20T07:12:38.000Z","_content":"\n\n### 简介\n算法第三章，讨论动态规划。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Algorithm-3.md","raw":"---\ntitle: Algorithm 3\ndate: 2022-01-20 15:12:38\ntags:\n    - IT-Basics\n    - Algorithm\n---\n\n\n### 简介\n算法第三章，讨论动态规划。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Algorithm-3","published":1,"updated":"2024-03-13T13:51:22.559Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjr10004em3i468z9ae3","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第三章，讨论动态规划。</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第三章，讨论动态规划。</p>\n"},{"title":"Algorithm 4","date":"2022-01-22T09:36:10.000Z","_content":"\n\n### 简介\n算法第四章，讨论算法思想和技巧。\n\n\n\n### 分治\n\n\n### 倍增\n\n\n### 二分法\n\n\n### 贪心算法\n\n\n\n","source":"_posts/Algorithm-4.md","raw":"---\ntitle: Algorithm 4\ndate: 2022-01-22 17:36:10\ntags:\n   - IT-Basics\n   - Algorithm\n---\n\n\n### 简介\n算法第四章，讨论算法思想和技巧。\n\n\n\n### 分治\n\n\n### 倍增\n\n\n### 二分法\n\n\n### 贪心算法\n\n\n\n","slug":"Algorithm-4","published":1,"updated":"2024-03-13T13:51:22.559Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjr20005em3ic6di34eo","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第四章，讨论算法思想和技巧。</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><h3 id=\"倍增\"><a href=\"#倍增\" class=\"headerlink\" title=\"倍增\"></a>倍增</h3><h3 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h3><h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3>","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>算法第四章，讨论算法思想和技巧。</p>\n<h3 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h3><h3 id=\"倍增\"><a href=\"#倍增\" class=\"headerlink\" title=\"倍增\"></a>倍增</h3><h3 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h3><h3 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h3>"},{"title":"Blockchain wallet","date":"2019-07-18T07:27:45.000Z","_content":"\n### 简介\n一款支持多币种，多账户的区块链HD钱包，项目开源。\n\n\n### 特点\n1，简捷的支付方式\n2，支持BTC, BCH, ETH和所有ERC-20 tokens\n3，简捷的密钥备份\n4，安全的密钥存储\n5，支持众多Dapp\n\n\n### 开发&部署\n1，Download and install Java 7 or up\n2，Download and Install the latest Android studio\n3，Download and install the latest NDK https://developer.android.com/ndk/downloads/index.html or download it in android studio by \"choosing the NDK\" and press \"download\"(Ndk Version must be 16)\n4，Go to https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android\n5，Open the project with Android Studio and let the project sync\n6，Go to SDK Manager and download all the SDK Platforms and SDK Tools\n7，Build -> Rebuild Project","source":"_posts/Blockchain-wallet.md","raw":"---\ntitle: Blockchain wallet\ndate: 2019-07-18 15:27:45\ntags: \n    - Blockchain\n    - Android\n---\n\n### 简介\n一款支持多币种，多账户的区块链HD钱包，项目开源。\n\n\n### 特点\n1，简捷的支付方式\n2，支持BTC, BCH, ETH和所有ERC-20 tokens\n3，简捷的密钥备份\n4，安全的密钥存储\n5，支持众多Dapp\n\n\n### 开发&部署\n1，Download and install Java 7 or up\n2，Download and Install the latest Android studio\n3，Download and install the latest NDK https://developer.android.com/ndk/downloads/index.html or download it in android studio by \"choosing the NDK\" and press \"download\"(Ndk Version must be 16)\n4，Go to https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android\n5，Open the project with Android Studio and let the project sync\n6，Go to SDK Manager and download all the SDK Platforms and SDK Tools\n7，Build -> Rebuild Project","slug":"Blockchain-wallet","published":1,"updated":"2024-03-13T13:51:22.560Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjr30008em3i9t0f87m5","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>一款支持多币种，多账户的区块链HD钱包，项目开源。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>1，简捷的支付方式<br>2，支持BTC, BCH, ETH和所有ERC-20 tokens<br>3，简捷的密钥备份<br>4，安全的密钥存储<br>5，支持众多Dapp</p>\n<h3 id=\"开发-部署\"><a href=\"#开发-部署\" class=\"headerlink\" title=\"开发&amp;部署\"></a>开发&amp;部署</h3><p>1，Download and install Java 7 or up<br>2，Download and Install the latest Android studio<br>3，Download and install the latest NDK <a href=\"https://developer.android.com/ndk/downloads/index.html\">https://developer.android.com/ndk/downloads/index.html</a> or download it in android studio by “choosing the NDK” and press “download”(Ndk Version must be 16)<br>4，Go to <a href=\"https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android\">https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android</a><br>5，Open the project with Android Studio and let the project sync<br>6，Go to SDK Manager and download all the SDK Platforms and SDK Tools<br>7，Build -&gt; Rebuild Project</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>一款支持多币种，多账户的区块链HD钱包，项目开源。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>1，简捷的支付方式<br>2，支持BTC, BCH, ETH和所有ERC-20 tokens<br>3，简捷的密钥备份<br>4，安全的密钥存储<br>5，支持众多Dapp</p>\n<h3 id=\"开发-部署\"><a href=\"#开发-部署\" class=\"headerlink\" title=\"开发&amp;部署\"></a>开发&amp;部署</h3><p>1，Download and install Java 7 or up<br>2，Download and Install the latest Android studio<br>3，Download and install the latest NDK <a href=\"https://developer.android.com/ndk/downloads/index.html\">https://developer.android.com/ndk/downloads/index.html</a> or download it in android studio by “choosing the NDK” and press “download”(Ndk Version must be 16)<br>4，Go to <a href=\"https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android\">https://github.com/xidaokun/Elastos.App.Wallet.Elephant.Android</a><br>5，Open the project with Android Studio and let the project sync<br>6，Go to SDK Manager and download all the SDK Platforms and SDK Tools<br>7，Build -&gt; Rebuild Project</p>\n"},{"title":"Backend Node","date":"2022-04-05T09:22:00.000Z","_content":"\n### 1，简介\n一个后台服务项目，可以存储用户的文件和数据，并将文件同步到第三方云盘。\n\n### 2，功能\n- 手机号注册/手机号登录\n- OAuth授权\n- 账户登录\n- 密码修改\n\n- API鉴权\n- 数据管理\n- 文件管理\n- 个人云盘数据同步\n\n- 数字货币fee(TODO)\n\n\n### 3，部署\n3.1 clone\n{% blockquote %}\n$git clone https://github.com/xidaokun/Cary.Project.Python.Backend.git\n{% endblockquote %}\n\n3.2 run\n{% blockquote %}\n$./run.sh start\n{% endblockquote %}\n\n### 4，APIS\n##### 4.1 User manager\n1.register user\n{% blockquote %}\n$curl -d '{\"name\":\"cary\", \"password\":\"123456\", \"phone\":\"1234567890\", \"code\":1111}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/register\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\" }\n{% endblockquote %}\n\n2.user login\n{% blockquote %}\n$curl -d '{\"name\":\"cary\", \"password\":\"123456\"}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/login\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\", \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\\.  \neyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYs  \nImF1ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJj  \nYXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0\\.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8\", \"user_id\": \"608abd1c9f394f7d7f019f95\", \"user_name\": \"cary\" }\n{% endblockquote %}\n\n3.verification code\n{% blockquote %}\n$curl -d '{\"phone\":\"1234567890\"}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/verification_code\n{% endblockquote %}\n\n4.change password\n{% blockquote %}\n$curl -d '{\"password\":\"12345\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/change_pwd\n{% endblockquote %}\n\n##### 4.2 OAuth\n{% blockquote %}\n$curl http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&type=github&redirect_uri=http://example.com&state=xyz\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\", \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\\.  \neyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYsImF1  \nZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJjY  \nXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0\\.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8\", \"user_id\": \"608abd1c9f394f7d7f019f95\", \"user_name\": \"cary\" }\n{% endblockquote %}\n\n##### 4.3 File operation\n1.upload file\n{% blockquote %}\n$curl -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/upload/test.txt\n{% endblockquote %}\n\n2.download file\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/download?path=test.txt\n{% endblockquote %}\n\n3.list files\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/list\n{% endblockquote %}\n\n4.get file information\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/information\n{% endblockquote %}\n\n5.delete file\n{% blockquote %}\ncurl -d '{\"file\":\"test.txt\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/file/delete\n{% endblockquote %}\n\n##### 4.4 Database operation\n1.create collection\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/create_col\n{% endblockquote %}\n\n2.insert one/many document\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"document\":{\"worker\":\"cary\",\"title\":\"developer\"},\"options\":{\"bypass_document_validation\":false}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/insert_one\n{% endblockquote %}\n\n3.update one/many document\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",},\"update\":{\"$set\":{\"author\":\"cary\",\"title\":\"manger\"}},\"options\":{\"upsert\":true,\"bypass_document_validation\":false}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/update_one\n{% endblockquote %}\n\n4.count documents\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",},\"options\":{\"skip\":0,\"limit\":10,\"maxTimeMS\":1000000000}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/count_documents\n{% endblockquote %}\n\n5.delete one/many documents\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/delete_one\n{% endblockquote %}\n\n6.delete collection\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/delete_col\n{% endblockquote %}\n\n\n","source":"_posts/Backend-Node.md","raw":"---\ntitle: Backend Node\ndate: 2022-04-05 17:22:00\ntags: Backend\n---\n\n### 1，简介\n一个后台服务项目，可以存储用户的文件和数据，并将文件同步到第三方云盘。\n\n### 2，功能\n- 手机号注册/手机号登录\n- OAuth授权\n- 账户登录\n- 密码修改\n\n- API鉴权\n- 数据管理\n- 文件管理\n- 个人云盘数据同步\n\n- 数字货币fee(TODO)\n\n\n### 3，部署\n3.1 clone\n{% blockquote %}\n$git clone https://github.com/xidaokun/Cary.Project.Python.Backend.git\n{% endblockquote %}\n\n3.2 run\n{% blockquote %}\n$./run.sh start\n{% endblockquote %}\n\n### 4，APIS\n##### 4.1 User manager\n1.register user\n{% blockquote %}\n$curl -d '{\"name\":\"cary\", \"password\":\"123456\", \"phone\":\"1234567890\", \"code\":1111}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/register\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\" }\n{% endblockquote %}\n\n2.user login\n{% blockquote %}\n$curl -d '{\"name\":\"cary\", \"password\":\"123456\"}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/login\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\", \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\\.  \neyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYs  \nImF1ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJj  \nYXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0\\.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8\", \"user_id\": \"608abd1c9f394f7d7f019f95\", \"user_name\": \"cary\" }\n{% endblockquote %}\n\n3.verification code\n{% blockquote %}\n$curl -d '{\"phone\":\"1234567890\"}' -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/verification_code\n{% endblockquote %}\n\n4.change password\n{% blockquote %}\n$curl -d '{\"password\":\"12345\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/user/change_pwd\n{% endblockquote %}\n\n##### 4.2 OAuth\n{% blockquote %}\n$curl http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&type=github&redirect_uri=http://example.com&state=xyz\n{% endblockquote %}\n\n{% blockquote %}\n{ \"_status\": \"OK\", \"access_token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\\.  \neyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYsImF1  \nZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJjY  \nXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0\\.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8\", \"user_id\": \"608abd1c9f394f7d7f019f95\", \"user_name\": \"cary\" }\n{% endblockquote %}\n\n##### 4.3 File operation\n1.upload file\n{% blockquote %}\n$curl -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/upload/test.txt\n{% endblockquote %}\n\n2.download file\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/download?path=test.txt\n{% endblockquote %}\n\n3.list files\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/list\n{% endblockquote %}\n\n4.get file information\n{% blockquote %}\n$curl -i -H \"If-Match: token JWT_TOKEN\" http://127.0.0.1:5000/api/v1/file/information\n{% endblockquote %}\n\n5.delete file\n{% blockquote %}\ncurl -d '{\"file\":\"test.txt\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/file/delete\n{% endblockquote %}\n\n##### 4.4 Database operation\n1.create collection\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/create_col\n{% endblockquote %}\n\n2.insert one/many document\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"document\":{\"worker\":\"cary\",\"title\":\"developer\"},\"options\":{\"bypass_document_validation\":false}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/insert_one\n{% endblockquote %}\n\n3.update one/many document\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",},\"update\":{\"$set\":{\"author\":\"cary\",\"title\":\"manger\"}},\"options\":{\"upsert\":true,\"bypass_document_validation\":false}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/update_one\n{% endblockquote %}\n\n4.count documents\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",},\"options\":{\"skip\":0,\"limit\":10,\"maxTimeMS\":1000000000}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/count_documents\n{% endblockquote %}\n\n5.delete one/many documents\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\",\"filter\":{\"worker\":\"cary\",}}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/delete_one\n{% endblockquote %}\n\n6.delete collection\n{% blockquote %}\n$curl -d '{\"collection\":\"workers\"}' -H \"If-Match: token JWT_TOKEN\" -H 'Content-Type: application/json' http://127.0.0.1:5000/api/v1/db/delete_col\n{% endblockquote %}\n\n\n","slug":"Backend-Node","published":1,"updated":"2024-03-13T13:51:22.559Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjr40009em3ieawb2eny","content":"<h3 id=\"1，简介\"><a href=\"#1，简介\" class=\"headerlink\" title=\"1，简介\"></a>1，简介</h3><p>一个后台服务项目，可以存储用户的文件和数据，并将文件同步到第三方云盘。</p>\n<h3 id=\"2，功能\"><a href=\"#2，功能\" class=\"headerlink\" title=\"2，功能\"></a>2，功能</h3><ul>\n<li><p>手机号注册&#x2F;手机号登录</p>\n</li>\n<li><p>OAuth授权</p>\n</li>\n<li><p>账户登录</p>\n</li>\n<li><p>密码修改</p>\n</li>\n<li><p>API鉴权</p>\n</li>\n<li><p>数据管理</p>\n</li>\n<li><p>文件管理</p>\n</li>\n<li><p>个人云盘数据同步</p>\n</li>\n<li><p>数字货币fee(TODO)</p>\n</li>\n</ul>\n<h3 id=\"3，部署\"><a href=\"#3，部署\" class=\"headerlink\" title=\"3，部署\"></a>3，部署</h3><p>3.1 clone</p>\n<blockquote><p>$git clone <a href=\"https://github.com/xidaokun/Cary.Project.Python.Backend.git\">https://github.com/xidaokun/Cary.Project.Python.Backend.git</a></p>\n</blockquote>\n\n<p>3.2 run</p>\n<blockquote><p>$.&#x2F;run.sh start</p>\n</blockquote>\n\n<h3 id=\"4，APIS\"><a href=\"#4，APIS\" class=\"headerlink\" title=\"4，APIS\"></a>4，APIS</h3><h5 id=\"4-1-User-manager\"><a href=\"#4-1-User-manager\" class=\"headerlink\" title=\"4.1 User manager\"></a>4.1 User manager</h5><p>1.register user</p>\n<blockquote><p>$curl -d ‘{“name”:”cary”, “password”:”123456”, “phone”:”1234567890”, “code”:1111}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/register\">http://127.0.0.1:5000/api/v1/user/register</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK” }</p>\n</blockquote>\n\n<p>2.user login</p>\n<blockquote><p>$curl -d ‘{“name”:”cary”, “password”:”123456”}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/login\">http://127.0.0.1:5000/api/v1/user/login</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK”, “access_token”: “eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<br>eyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYs<br>ImF1ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJj<br>YXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8”, “user_id”: “608abd1c9f394f7d7f019f95”, “user_name”: “cary” }</p>\n</blockquote>\n\n<p>3.verification code</p>\n<blockquote><p>$curl -d ‘{“phone”:”1234567890”}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/verification_code\">http://127.0.0.1:5000/api/v1/user/verification_code</a></p>\n</blockquote>\n\n<p>4.change password</p>\n<blockquote><p>$curl -d ‘{“password”:”12345”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/change_pwd\">http://127.0.0.1:5000/api/v1/user/change_pwd</a></p>\n</blockquote>\n\n<h5 id=\"4-2-OAuth\"><a href=\"#4-2-OAuth\" class=\"headerlink\" title=\"4.2 OAuth\"></a>4.2 OAuth</h5><blockquote><p>$curl <a href=\"http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&type=github&redirect_uri=http://example.com&state=xyz\">http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&amp;type=github&amp;redirect_uri=http://example.com&amp;state=xyz</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK”, “access_token”: “eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<br>eyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYsImF1<br>ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJjY<br>XJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8”, “user_id”: “608abd1c9f394f7d7f019f95”, “user_name”: “cary” }</p>\n</blockquote>\n\n<h5 id=\"4-3-File-operation\"><a href=\"#4-3-File-operation\" class=\"headerlink\" title=\"4.3 File operation\"></a>4.3 File operation</h5><p>1.upload file</p>\n<blockquote><p>$curl -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/upload/test.txt\">http://127.0.0.1:5000/api/v1/file/upload/test.txt</a></p>\n</blockquote>\n\n<p>2.download file</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/download?path=test.txt\">http://127.0.0.1:5000/api/v1/file/download?path=test.txt</a></p>\n</blockquote>\n\n<p>3.list files</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/list\">http://127.0.0.1:5000/api/v1/file/list</a></p>\n</blockquote>\n\n<p>4.get file information</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/information\">http://127.0.0.1:5000/api/v1/file/information</a></p>\n</blockquote>\n\n<p>5.delete file</p>\n<blockquote><p>curl -d ‘{“file”:”test.txt”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/file/delete\">http://127.0.0.1:5000/api/v1/file/delete</a></p>\n</blockquote>\n\n<h5 id=\"4-4-Database-operation\"><a href=\"#4-4-Database-operation\" class=\"headerlink\" title=\"4.4 Database operation\"></a>4.4 Database operation</h5><p>1.create collection</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/create_col\">http://127.0.0.1:5000/api/v1/db/create_col</a></p>\n</blockquote>\n\n<p>2.insert one&#x2F;many document</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”document”:{“worker”:”cary”,”title”:”developer”},”options”:{“bypass_document_validation”:false}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/insert_one\">http://127.0.0.1:5000/api/v1/db/insert_one</a></p>\n</blockquote>\n\n<p>3.update one&#x2F;many document</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,},”update”:{“$set”:{“author”:”cary”,”title”:”manger”}},”options”:{“upsert”:true,”bypass_document_validation”:false}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/update_one\">http://127.0.0.1:5000/api/v1/db/update_one</a></p>\n</blockquote>\n\n<p>4.count documents</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,},”options”:{“skip”:0,”limit”:10,”maxTimeMS”:1000000000}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/count_documents\">http://127.0.0.1:5000/api/v1/db/count_documents</a></p>\n</blockquote>\n\n<p>5.delete one&#x2F;many documents</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/delete_one\">http://127.0.0.1:5000/api/v1/db/delete_one</a></p>\n</blockquote>\n\n<p>6.delete collection</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/delete_col\">http://127.0.0.1:5000/api/v1/db/delete_col</a></p>\n</blockquote>\n\n\n","excerpt":"","more":"<h3 id=\"1，简介\"><a href=\"#1，简介\" class=\"headerlink\" title=\"1，简介\"></a>1，简介</h3><p>一个后台服务项目，可以存储用户的文件和数据，并将文件同步到第三方云盘。</p>\n<h3 id=\"2，功能\"><a href=\"#2，功能\" class=\"headerlink\" title=\"2，功能\"></a>2，功能</h3><ul>\n<li><p>手机号注册&#x2F;手机号登录</p>\n</li>\n<li><p>OAuth授权</p>\n</li>\n<li><p>账户登录</p>\n</li>\n<li><p>密码修改</p>\n</li>\n<li><p>API鉴权</p>\n</li>\n<li><p>数据管理</p>\n</li>\n<li><p>文件管理</p>\n</li>\n<li><p>个人云盘数据同步</p>\n</li>\n<li><p>数字货币fee(TODO)</p>\n</li>\n</ul>\n<h3 id=\"3，部署\"><a href=\"#3，部署\" class=\"headerlink\" title=\"3，部署\"></a>3，部署</h3><p>3.1 clone</p>\n<blockquote><p>$git clone <a href=\"https://github.com/xidaokun/Cary.Project.Python.Backend.git\">https://github.com/xidaokun/Cary.Project.Python.Backend.git</a></p>\n</blockquote>\n\n<p>3.2 run</p>\n<blockquote><p>$.&#x2F;run.sh start</p>\n</blockquote>\n\n<h3 id=\"4，APIS\"><a href=\"#4，APIS\" class=\"headerlink\" title=\"4，APIS\"></a>4，APIS</h3><h5 id=\"4-1-User-manager\"><a href=\"#4-1-User-manager\" class=\"headerlink\" title=\"4.1 User manager\"></a>4.1 User manager</h5><p>1.register user</p>\n<blockquote><p>$curl -d ‘{“name”:”cary”, “password”:”123456”, “phone”:”1234567890”, “code”:1111}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/register\">http://127.0.0.1:5000/api/v1/user/register</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK” }</p>\n</blockquote>\n\n<p>2.user login</p>\n<blockquote><p>$curl -d ‘{“name”:”cary”, “password”:”123456”}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/login\">http://127.0.0.1:5000/api/v1/user/login</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK”, “access_token”: “eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<br>eyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYs<br>ImF1ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJj<br>YXJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8”, “user_id”: “608abd1c9f394f7d7f019f95”, “user_name”: “cary” }</p>\n</blockquote>\n\n<p>3.verification code</p>\n<blockquote><p>$curl -d ‘{“phone”:”1234567890”}’ -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/verification_code\">http://127.0.0.1:5000/api/v1/user/verification_code</a></p>\n</blockquote>\n\n<p>4.change password</p>\n<blockquote><p>$curl -d ‘{“password”:”12345”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/user/change_pwd\">http://127.0.0.1:5000/api/v1/user/change_pwd</a></p>\n</blockquote>\n\n<h5 id=\"4-2-OAuth\"><a href=\"#4-2-OAuth\" class=\"headerlink\" title=\"4.2 OAuth\"></a>4.2 OAuth</h5><blockquote><p>$curl <a href=\"http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&type=github&redirect_uri=http://example.com&state=xyz\">http://127.0.0.1:5000/api/v1/user/oauth?code=your_access_code&amp;type=github&amp;redirect_uri=http://example.com&amp;state=xyz</a></p>\n</blockquote>\n\n<blockquote><p>{ “_status”: “OK”, “access_token”: “eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.<br>eyJpc3MiOiJiYWNrZW5kIiwiaWF0IjoxNjE5NzA1MTg2LCJleHAiOjE2MTk3MDU0ODYsImF1<br>ZCI6ImNsaWVudCIsInN1YiI6IjYwOGFiZDFjOWYzOTRmN2Q3ZjAxOWY5NSIsIm5hbWUiOiJjY<br>XJ5Iiwic2NvcGVzIjpbIm9wZW4iXX0.3wirR5I5UCUDmuCi96adm3SctPEOFPYQKf9gcAF9Ib8”, “user_id”: “608abd1c9f394f7d7f019f95”, “user_name”: “cary” }</p>\n</blockquote>\n\n<h5 id=\"4-3-File-operation\"><a href=\"#4-3-File-operation\" class=\"headerlink\" title=\"4.3 File operation\"></a>4.3 File operation</h5><p>1.upload file</p>\n<blockquote><p>$curl -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/upload/test.txt\">http://127.0.0.1:5000/api/v1/file/upload/test.txt</a></p>\n</blockquote>\n\n<p>2.download file</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/download?path=test.txt\">http://127.0.0.1:5000/api/v1/file/download?path=test.txt</a></p>\n</blockquote>\n\n<p>3.list files</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/list\">http://127.0.0.1:5000/api/v1/file/list</a></p>\n</blockquote>\n\n<p>4.get file information</p>\n<blockquote><p>$curl -i -H “If-Match: token JWT_TOKEN” <a href=\"http://127.0.0.1:5000/api/v1/file/information\">http://127.0.0.1:5000/api/v1/file/information</a></p>\n</blockquote>\n\n<p>5.delete file</p>\n<blockquote><p>curl -d ‘{“file”:”test.txt”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/file/delete\">http://127.0.0.1:5000/api/v1/file/delete</a></p>\n</blockquote>\n\n<h5 id=\"4-4-Database-operation\"><a href=\"#4-4-Database-operation\" class=\"headerlink\" title=\"4.4 Database operation\"></a>4.4 Database operation</h5><p>1.create collection</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/create_col\">http://127.0.0.1:5000/api/v1/db/create_col</a></p>\n</blockquote>\n\n<p>2.insert one&#x2F;many document</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”document”:{“worker”:”cary”,”title”:”developer”},”options”:{“bypass_document_validation”:false}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/insert_one\">http://127.0.0.1:5000/api/v1/db/insert_one</a></p>\n</blockquote>\n\n<p>3.update one&#x2F;many document</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,},”update”:{“$set”:{“author”:”cary”,”title”:”manger”}},”options”:{“upsert”:true,”bypass_document_validation”:false}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/update_one\">http://127.0.0.1:5000/api/v1/db/update_one</a></p>\n</blockquote>\n\n<p>4.count documents</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,},”options”:{“skip”:0,”limit”:10,”maxTimeMS”:1000000000}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/count_documents\">http://127.0.0.1:5000/api/v1/db/count_documents</a></p>\n</blockquote>\n\n<p>5.delete one&#x2F;many documents</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”,”filter”:{“worker”:”cary”,}}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/delete_one\">http://127.0.0.1:5000/api/v1/db/delete_one</a></p>\n</blockquote>\n\n<p>6.delete collection</p>\n<blockquote><p>$curl -d ‘{“collection”:”workers”}’ -H “If-Match: token JWT_TOKEN” -H ‘Content-Type: application&#x2F;json’ <a href=\"http://127.0.0.1:5000/api/v1/db/delete_col\">http://127.0.0.1:5000/api/v1/db/delete_col</a></p>\n</blockquote>\n\n\n"},{"title":"Data Struct 1","date":"2022-01-05T10:10:23.000Z","_content":"\n### 简介\n数据结构讨论第一章，包括：数组，链表，栈，队列，哈希表。\n\n\n### 数组(array)\n数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。\n{% asset_img struct_array.png struct array %}\n优点：\n- 空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。\n- 支持随机访问：数组允许在 时间内访问任何元素。\n- 缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\n局限：\n- 插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。\n- 长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\n- 空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。\n\n### 链表(linked list)\n常见的链表类型包括三种:\n- 单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。\n- 环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。\n- 双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。\n{% asset_img struct_link_list.png link list %}\n\n### 栈(stack)\n栈是一种遵循先入后出逻辑的线性数据结构。\n{% asset_img struct_stack.png link list %}\n操作：\npush，元素入栈到栈顶，时间复杂度O(1)。\npop，栈顶元素出栈，时间复杂度O(1)。\npeek，访问栈顶元素，时间复杂度O(1)。\n\n\n### 队列(queue)\n队列是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。\n{% asset_img struct_queue.png queue list %}\n操作：\npush，元素入队，即将元素添加至队尾，时间复杂度O(1)。\npop，队首元素出队，时间复杂度O(1)。\npeek，访问队首元素，时间复杂度O(1)。\n\n\n### 双向队列(double-ended queue)\n双向队列提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作;双向队列的实现与队列类似，可以选择链表或数组作为底层数据结构。\n{% asset_img struct_double_queue.png queue list %}\n操作：\npush_first，将元素添加至队首，时间复杂度O(1)。\npush_last，将元素添加至队尾，时间复杂度O(1)。\npop_first，删除队首元素，时间复杂度O(1)。\npop_last，删除队尾元素，时间复杂度O(1)。\npeek_first，访问队首元素，时间复杂度O(1)。\npeek_last，访问队尾元素，时间复杂度O(1)。\n\n\n### 哈希表(hash table)\n哈希表，又称散列表，它通过建立键key与值value之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键key，则可以在时间内获取对应的值value。\n{% asset_img struct_hash_table.png hash table %}\n1，实现\n{% asset_img struct_hash_imp.png hash table implement %}\n2，哈希冲突\n常情况下哈希函数的输入空间远大于输出空间，因此理论上哈希冲突是不可避免的。我们通过下面两个策略来解决冲突：\n- 改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。\n- 仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。\n\n哈希表的结构改良方法主要包括“链式地址法”和“开放寻址法”。\n\n3，链式地址(separate chaining)法\n在原始哈希表中，每个桶仅能存储一个键值对。「链式地址 separate chaining」将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。\n{% asset_img hash_table_link_addr.png hash table implement %}\n查询元素，输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比key以查找目标键值对。\n添加元素，首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。\n删除元素，根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。\n局限：\n占用空间增大，链表包含节点指针，它相比数组更加耗费内存空间。\n查询效率降低，因为需要线性遍历链表来查找对应元素。\n\n当链表很长时，查询效率很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至。\n\n\n4，开发寻址(open addressing)法\n开放寻址不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。\n\n\n\n\n\n\n\n\n","source":"_posts/Data-Struct-1.md","raw":"---\ntitle: Data Struct 1\ndate: 2022-01-05 18:10:23\ntags:    \n    - IT-Basics\n    - Algorithm\n---\n\n### 简介\n数据结构讨论第一章，包括：数组，链表，栈，队列，哈希表。\n\n\n### 数组(array)\n数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。\n{% asset_img struct_array.png struct array %}\n优点：\n- 空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。\n- 支持随机访问：数组允许在 时间内访问任何元素。\n- 缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。\n局限：\n- 插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。\n- 长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。\n- 空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。\n\n### 链表(linked list)\n常见的链表类型包括三种:\n- 单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。\n- 环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。\n- 双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。\n{% asset_img struct_link_list.png link list %}\n\n### 栈(stack)\n栈是一种遵循先入后出逻辑的线性数据结构。\n{% asset_img struct_stack.png link list %}\n操作：\npush，元素入栈到栈顶，时间复杂度O(1)。\npop，栈顶元素出栈，时间复杂度O(1)。\npeek，访问栈顶元素，时间复杂度O(1)。\n\n\n### 队列(queue)\n队列是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。\n{% asset_img struct_queue.png queue list %}\n操作：\npush，元素入队，即将元素添加至队尾，时间复杂度O(1)。\npop，队首元素出队，时间复杂度O(1)。\npeek，访问队首元素，时间复杂度O(1)。\n\n\n### 双向队列(double-ended queue)\n双向队列提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作;双向队列的实现与队列类似，可以选择链表或数组作为底层数据结构。\n{% asset_img struct_double_queue.png queue list %}\n操作：\npush_first，将元素添加至队首，时间复杂度O(1)。\npush_last，将元素添加至队尾，时间复杂度O(1)。\npop_first，删除队首元素，时间复杂度O(1)。\npop_last，删除队尾元素，时间复杂度O(1)。\npeek_first，访问队首元素，时间复杂度O(1)。\npeek_last，访问队尾元素，时间复杂度O(1)。\n\n\n### 哈希表(hash table)\n哈希表，又称散列表，它通过建立键key与值value之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键key，则可以在时间内获取对应的值value。\n{% asset_img struct_hash_table.png hash table %}\n1，实现\n{% asset_img struct_hash_imp.png hash table implement %}\n2，哈希冲突\n常情况下哈希函数的输入空间远大于输出空间，因此理论上哈希冲突是不可避免的。我们通过下面两个策略来解决冲突：\n- 改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。\n- 仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。\n\n哈希表的结构改良方法主要包括“链式地址法”和“开放寻址法”。\n\n3，链式地址(separate chaining)法\n在原始哈希表中，每个桶仅能存储一个键值对。「链式地址 separate chaining」将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。\n{% asset_img hash_table_link_addr.png hash table implement %}\n查询元素，输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比key以查找目标键值对。\n添加元素，首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。\n删除元素，根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。\n局限：\n占用空间增大，链表包含节点指针，它相比数组更加耗费内存空间。\n查询效率降低，因为需要线性遍历链表来查找对应元素。\n\n当链表很长时，查询效率很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至。\n\n\n4，开发寻址(open addressing)法\n开放寻址不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。\n\n\n\n\n\n\n\n\n","slug":"Data-Struct-1","published":1,"updated":"2024-03-13T13:51:22.560Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjr5000bem3i18mu4nqk","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构讨论第一章，包括：数组，链表，栈，队列，哈希表。</p>\n<h3 id=\"数组-array\"><a href=\"#数组-array\" class=\"headerlink\" title=\"数组(array)\"></a>数组(array)</h3><p>数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_array.png\" class=\"\" title=\"struct array\">\n<p>优点：</p>\n<ul>\n<li>空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。</li>\n<li>支持随机访问：数组允许在 时间内访问任何元素。</li>\n<li>缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。<br>局限：</li>\n<li>插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li>\n<li>长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li>\n<li>空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li>\n</ul>\n<h3 id=\"链表-linked-list\"><a href=\"#链表-linked-list\" class=\"headerlink\" title=\"链表(linked list)\"></a>链表(linked list)</h3><p>常见的链表类型包括三种:</p>\n<ul>\n<li>单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。</li>\n<li>环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li>\n<li>双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。<img src=\"/2022/01/05/Data-Struct-1/struct_link_list.png\" class=\"\" title=\"link list\"></li>\n</ul>\n<h3 id=\"栈-stack\"><a href=\"#栈-stack\" class=\"headerlink\" title=\"栈(stack)\"></a>栈(stack)</h3><p>栈是一种遵循先入后出逻辑的线性数据结构。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_stack.png\" class=\"\" title=\"link list\">\n<p>操作：<br>push，元素入栈到栈顶，时间复杂度O(1)。<br>pop，栈顶元素出栈，时间复杂度O(1)。<br>peek，访问栈顶元素，时间复杂度O(1)。</p>\n<h3 id=\"队列-queue\"><a href=\"#队列-queue\" class=\"headerlink\" title=\"队列(queue)\"></a>队列(queue)</h3><p>队列是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_queue.png\" class=\"\" title=\"queue list\">\n<p>操作：<br>push，元素入队，即将元素添加至队尾，时间复杂度O(1)。<br>pop，队首元素出队，时间复杂度O(1)。<br>peek，访问队首元素，时间复杂度O(1)。</p>\n<h3 id=\"双向队列-double-ended-queue\"><a href=\"#双向队列-double-ended-queue\" class=\"headerlink\" title=\"双向队列(double-ended queue)\"></a>双向队列(double-ended queue)</h3><p>双向队列提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作;双向队列的实现与队列类似，可以选择链表或数组作为底层数据结构。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_double_queue.png\" class=\"\" title=\"queue list\">\n<p>操作：<br>push_first，将元素添加至队首，时间复杂度O(1)。<br>push_last，将元素添加至队尾，时间复杂度O(1)。<br>pop_first，删除队首元素，时间复杂度O(1)。<br>pop_last，删除队尾元素，时间复杂度O(1)。<br>peek_first，访问队首元素，时间复杂度O(1)。<br>peek_last，访问队尾元素，时间复杂度O(1)。</p>\n<h3 id=\"哈希表-hash-table\"><a href=\"#哈希表-hash-table\" class=\"headerlink\" title=\"哈希表(hash table)\"></a>哈希表(hash table)</h3><p>哈希表，又称散列表，它通过建立键key与值value之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键key，则可以在时间内获取对应的值value。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_hash_table.png\" class=\"\" title=\"hash table\">\n<p>1，实现</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_hash_imp.png\" class=\"\" title=\"hash table implement\">\n<p>2，哈希冲突<br>常情况下哈希函数的输入空间远大于输出空间，因此理论上哈希冲突是不可避免的。我们通过下面两个策略来解决冲突：</p>\n<ul>\n<li>改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。</li>\n<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>\n</ul>\n<p>哈希表的结构改良方法主要包括“链式地址法”和“开放寻址法”。</p>\n<p>3，链式地址(separate chaining)法<br>在原始哈希表中，每个桶仅能存储一个键值对。「链式地址 separate chaining」将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。</p>\n<img src=\"/2022/01/05/Data-Struct-1/hash_table_link_addr.png\" class=\"\" title=\"hash table implement\">\n<p>查询元素，输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比key以查找目标键值对。<br>添加元素，首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。<br>删除元素，根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。<br>局限：<br>占用空间增大，链表包含节点指针，它相比数组更加耗费内存空间。<br>查询效率降低，因为需要线性遍历链表来查找对应元素。</p>\n<p>当链表很长时，查询效率很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至。</p>\n<p>4，开发寻址(open addressing)法<br>开放寻址不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构讨论第一章，包括：数组，链表，栈，队列，哈希表。</p>\n<h3 id=\"数组-array\"><a href=\"#数组-array\" class=\"headerlink\" title=\"数组(array)\"></a>数组(array)</h3><p>数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_array.png\" class=\"\" title=\"struct array\">\n<p>优点：</p>\n<ul>\n<li>空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销。</li>\n<li>支持随机访问：数组允许在 时间内访问任何元素。</li>\n<li>缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度。<br>局限：</li>\n<li>插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素。</li>\n<li>长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大。</li>\n<li>空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了。</li>\n</ul>\n<h3 id=\"链表-linked-list\"><a href=\"#链表-linked-list\" class=\"headerlink\" title=\"链表(linked list)\"></a>链表(linked list)</h3><p>常见的链表类型包括三种:</p>\n<ul>\n<li>单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。</li>\n<li>环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li>\n<li>双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。<img src=\"/2022/01/05/Data-Struct-1/struct_link_list.png\" class=\"\" title=\"link list\"></li>\n</ul>\n<h3 id=\"栈-stack\"><a href=\"#栈-stack\" class=\"headerlink\" title=\"栈(stack)\"></a>栈(stack)</h3><p>栈是一种遵循先入后出逻辑的线性数据结构。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_stack.png\" class=\"\" title=\"link list\">\n<p>操作：<br>push，元素入栈到栈顶，时间复杂度O(1)。<br>pop，栈顶元素出栈，时间复杂度O(1)。<br>peek，访问栈顶元素，时间复杂度O(1)。</p>\n<h3 id=\"队列-queue\"><a href=\"#队列-queue\" class=\"headerlink\" title=\"队列(queue)\"></a>队列(queue)</h3><p>队列是一种遵循先入先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_queue.png\" class=\"\" title=\"queue list\">\n<p>操作：<br>push，元素入队，即将元素添加至队尾，时间复杂度O(1)。<br>pop，队首元素出队，时间复杂度O(1)。<br>peek，访问队首元素，时间复杂度O(1)。</p>\n<h3 id=\"双向队列-double-ended-queue\"><a href=\"#双向队列-double-ended-queue\" class=\"headerlink\" title=\"双向队列(double-ended queue)\"></a>双向队列(double-ended queue)</h3><p>双向队列提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作;双向队列的实现与队列类似，可以选择链表或数组作为底层数据结构。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_double_queue.png\" class=\"\" title=\"queue list\">\n<p>操作：<br>push_first，将元素添加至队首，时间复杂度O(1)。<br>push_last，将元素添加至队尾，时间复杂度O(1)。<br>pop_first，删除队首元素，时间复杂度O(1)。<br>pop_last，删除队尾元素，时间复杂度O(1)。<br>peek_first，访问队首元素，时间复杂度O(1)。<br>peek_last，访问队尾元素，时间复杂度O(1)。</p>\n<h3 id=\"哈希表-hash-table\"><a href=\"#哈希表-hash-table\" class=\"headerlink\" title=\"哈希表(hash table)\"></a>哈希表(hash table)</h3><p>哈希表，又称散列表，它通过建立键key与值value之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键key，则可以在时间内获取对应的值value。</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_hash_table.png\" class=\"\" title=\"hash table\">\n<p>1，实现</p>\n<img src=\"/2022/01/05/Data-Struct-1/struct_hash_imp.png\" class=\"\" title=\"hash table implement\">\n<p>2，哈希冲突<br>常情况下哈希函数的输入空间远大于输出空间，因此理论上哈希冲突是不可避免的。我们通过下面两个策略来解决冲突：</p>\n<ul>\n<li>改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作。</li>\n<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>\n</ul>\n<p>哈希表的结构改良方法主要包括“链式地址法”和“开放寻址法”。</p>\n<p>3，链式地址(separate chaining)法<br>在原始哈希表中，每个桶仅能存储一个键值对。「链式地址 separate chaining」将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。</p>\n<img src=\"/2022/01/05/Data-Struct-1/hash_table_link_addr.png\" class=\"\" title=\"hash table implement\">\n<p>查询元素，输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比key以查找目标键值对。<br>添加元素，首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中。<br>删除元素，根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除。<br>局限：<br>占用空间增大，链表包含节点指针，它相比数组更加耗费内存空间。<br>查询效率降低，因为需要线性遍历链表来查找对应元素。</p>\n<p>当链表很长时，查询效率很差。此时可以将链表转换为“AVL 树”或“红黑树”，从而将查询操作的时间复杂度优化至。</p>\n<p>4，开发寻址(open addressing)法<br>开放寻址不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等。</p>\n"},{"title":"Data Struct 2","date":"2022-01-08T09:03:53.000Z","_content":"\n### 简介\n数据结构第二章，讨论树。\n\n\n### 树\n树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。\n树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。\n{% asset_img struct_tree.png struct tree %}\n- 子树: 除了根节点外，每个子节点都可以分为多个不相交的子树。\n- 孩子与双亲: 若一个结点有子树，那么该结点称为子树根的\"双亲\"，子树的根是该结点的\"孩子\"。上图中，B、H是A的孩子，A是B、H的双亲。\n- 兄弟: 具有相同双亲的节点互为兄弟，例如B与H互为兄弟。\n- 节点的度: 一个节点拥有子树的数目。例如A的度为2，B的度为1，C的度为3。\n- 叶子: 没有子树，也即是度为0的节点。\n- 分支节点: 除了叶子节点之外的节点，也即是度不为0的节点。\n- 内部节点: 除了根节点之外的分支节点。\n- 层次: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1。\n- 树的高度: 也称为树的深度，树中节点的最大层次。\n- 有序树: 树中节点各子树之间的次序是重要的，不可以随意交换位置。\n- 无序树: 树种节点各子树之间的次序是不重要的。可以随意交换位置。森林: 0或多棵互不相交的树的集合。例如图二中的两棵树为森林。\n\n### 二叉树\n最多有两棵子树的树被称为二叉树。\n{% asset_img struct_tree.png struct tree %}\n\n### 斜树\n所有节点都只有左子树的二叉树叫做左斜树，所有节点都只有右子树的二叉树叫做右斜树。\n\n\n### 满二叉树\n二叉树中所有非叶子结点的度都是2，且叶子结点都在同一层次上。\n{% asset_img struct_full_binary_tree.png full binary tree %}\n\n### 完全二叉树\n如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树。\n{% asset_img complete_binary_tree.png complete binary tree %}\n\n\n### 二叉查找树(BST)\n二叉查找树(Binary Search Tree)是指一棵空树或者具有下列性质的二叉树:\n- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n- 任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。\n\n\n### 平衡二叉树(AVL)\n含有相同节点的二叉查找树可以有不同的形态，而二叉查找树的平均查找长度与树的深度有关，所以需要找出一个查找平均长度最小的一棵，那就是平衡二叉树，具有以下性质:\n- 要么是棵空树，要么其根节点左右子树的深度之差的绝对值不超过1；\n- 其左右子树也都是平衡二叉树；\n- 二叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则平衡二叉树的所有节点的平衡因子只可能是-1,0,1。\n\n### 红黑树\n红黑树也是一种自平衡的二叉查找树。\n- 每个结点要么是红的要么是黑的。(红或黑)\n- 根结点是黑的。(根黑)\n- 每个叶结点(叶结点即指树尾端NIL指针或NULL结点)都是黑的。(叶黑)\n- 如果一个结点是红的，那么它的两个儿子都是黑的。(红子黑)\n- 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。(路径下黑相同)\n\n### 哈夫曼树\n哈夫曼又称最优二叉树。是一种带权路径长度最短的二叉树：\n- 将所有左，右子树都为空的作为根节点。\n- 在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。\n- 从森林中删除这两棵树，同时把新树加入到森林中。\n- 重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。\n\n### B树\nB树(B-tree)是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一种自平衡的m阶树，与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。\n\n\n### B+树\nB+ 树是一种树数据结构，通常用于关系型数据库(如Mysql)和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。b+树的非叶子节点不保存数据，只保存子树的临界值(最大或者最小)，所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。\n\n\n### R树\nR树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。R树的核心思想是聚合距离相近的节点并在树结构的上一层将其表示为这些节点的最小外接矩形(MBR)，这个最小外接矩形就成为上一层的一个节点。因为所有节点都在它们的最小外接矩形中，所以跟某个矩形不相交的查询就一定跟这个矩形中的所有节点都不相交。叶子节点上的每个矩形都代表一个对象，节点都是对象的聚合，并且越往上层聚合的对象就越多。也可以把每一层看做是对数据集的近似，叶子节点层是最细粒度的近似，与数据集相似度100%，越往上层越粗糙。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Data-Struct-2.md","raw":"---\ntitle: Data Struct 2\ndate: 2022-01-08 17:03:53\ntags:\n   - IT-Basics\n   - Algorithm\n---\n\n### 简介\n数据结构第二章，讨论树。\n\n\n### 树\n树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。\n树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。\n{% asset_img struct_tree.png struct tree %}\n- 子树: 除了根节点外，每个子节点都可以分为多个不相交的子树。\n- 孩子与双亲: 若一个结点有子树，那么该结点称为子树根的\"双亲\"，子树的根是该结点的\"孩子\"。上图中，B、H是A的孩子，A是B、H的双亲。\n- 兄弟: 具有相同双亲的节点互为兄弟，例如B与H互为兄弟。\n- 节点的度: 一个节点拥有子树的数目。例如A的度为2，B的度为1，C的度为3。\n- 叶子: 没有子树，也即是度为0的节点。\n- 分支节点: 除了叶子节点之外的节点，也即是度不为0的节点。\n- 内部节点: 除了根节点之外的分支节点。\n- 层次: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1。\n- 树的高度: 也称为树的深度，树中节点的最大层次。\n- 有序树: 树中节点各子树之间的次序是重要的，不可以随意交换位置。\n- 无序树: 树种节点各子树之间的次序是不重要的。可以随意交换位置。森林: 0或多棵互不相交的树的集合。例如图二中的两棵树为森林。\n\n### 二叉树\n最多有两棵子树的树被称为二叉树。\n{% asset_img struct_tree.png struct tree %}\n\n### 斜树\n所有节点都只有左子树的二叉树叫做左斜树，所有节点都只有右子树的二叉树叫做右斜树。\n\n\n### 满二叉树\n二叉树中所有非叶子结点的度都是2，且叶子结点都在同一层次上。\n{% asset_img struct_full_binary_tree.png full binary tree %}\n\n### 完全二叉树\n如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树。\n{% asset_img complete_binary_tree.png complete binary tree %}\n\n\n### 二叉查找树(BST)\n二叉查找树(Binary Search Tree)是指一棵空树或者具有下列性质的二叉树:\n- 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；\n- 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；\n- 任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。\n\n\n### 平衡二叉树(AVL)\n含有相同节点的二叉查找树可以有不同的形态，而二叉查找树的平均查找长度与树的深度有关，所以需要找出一个查找平均长度最小的一棵，那就是平衡二叉树，具有以下性质:\n- 要么是棵空树，要么其根节点左右子树的深度之差的绝对值不超过1；\n- 其左右子树也都是平衡二叉树；\n- 二叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则平衡二叉树的所有节点的平衡因子只可能是-1,0,1。\n\n### 红黑树\n红黑树也是一种自平衡的二叉查找树。\n- 每个结点要么是红的要么是黑的。(红或黑)\n- 根结点是黑的。(根黑)\n- 每个叶结点(叶结点即指树尾端NIL指针或NULL结点)都是黑的。(叶黑)\n- 如果一个结点是红的，那么它的两个儿子都是黑的。(红子黑)\n- 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。(路径下黑相同)\n\n### 哈夫曼树\n哈夫曼又称最优二叉树。是一种带权路径长度最短的二叉树：\n- 将所有左，右子树都为空的作为根节点。\n- 在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。\n- 从森林中删除这两棵树，同时把新树加入到森林中。\n- 重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。\n\n### B树\nB树(B-tree)是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一种自平衡的m阶树，与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。\n\n\n### B+树\nB+ 树是一种树数据结构，通常用于关系型数据库(如Mysql)和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。b+树的非叶子节点不保存数据，只保存子树的临界值(最大或者最小)，所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。\n\n\n### R树\nR树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。R树的核心思想是聚合距离相近的节点并在树结构的上一层将其表示为这些节点的最小外接矩形(MBR)，这个最小外接矩形就成为上一层的一个节点。因为所有节点都在它们的最小外接矩形中，所以跟某个矩形不相交的查询就一定跟这个矩形中的所有节点都不相交。叶子节点上的每个矩形都代表一个对象，节点都是对象的聚合，并且越往上层聚合的对象就越多。也可以把每一层看做是对数据集的近似，叶子节点层是最细粒度的近似，与数据集相似度100%，越往上层越粗糙。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Data-Struct-2","published":1,"updated":"2024-03-13T13:51:22.571Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjr6000cem3ie1od8azl","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构第二章，讨论树。</p>\n<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><p>树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。<br>树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。</p>\n<img src=\"/2022/01/08/Data-Struct-2/struct_tree.png\" class=\"\" title=\"struct tree\">\n<ul>\n<li>子树: 除了根节点外，每个子节点都可以分为多个不相交的子树。</li>\n<li>孩子与双亲: 若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。上图中，B、H是A的孩子，A是B、H的双亲。</li>\n<li>兄弟: 具有相同双亲的节点互为兄弟，例如B与H互为兄弟。</li>\n<li>节点的度: 一个节点拥有子树的数目。例如A的度为2，B的度为1，C的度为3。</li>\n<li>叶子: 没有子树，也即是度为0的节点。</li>\n<li>分支节点: 除了叶子节点之外的节点，也即是度不为0的节点。</li>\n<li>内部节点: 除了根节点之外的分支节点。</li>\n<li>层次: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1。</li>\n<li>树的高度: 也称为树的深度，树中节点的最大层次。</li>\n<li>有序树: 树中节点各子树之间的次序是重要的，不可以随意交换位置。</li>\n<li>无序树: 树种节点各子树之间的次序是不重要的。可以随意交换位置。森林: 0或多棵互不相交的树的集合。例如图二中的两棵树为森林。</li>\n</ul>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>最多有两棵子树的树被称为二叉树。</p>\n<img src=\"/2022/01/08/Data-Struct-2/struct_tree.png\" class=\"\" title=\"struct tree\">\n\n<h3 id=\"斜树\"><a href=\"#斜树\" class=\"headerlink\" title=\"斜树\"></a>斜树</h3><p>所有节点都只有左子树的二叉树叫做左斜树，所有节点都只有右子树的二叉树叫做右斜树。</p>\n<h3 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h3><p>二叉树中所有非叶子结点的度都是2，且叶子结点都在同一层次上。</p>\n<img src=\"/2022/01/08/Data-Struct-2/struct_full_binary_tree.png\" class=\"\" title=\"full binary tree\">\n\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><p>如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树。</p>\n<img src=\"/2022/01/08/Data-Struct-2/complete_binary_tree.png\" class=\"\" title=\"complete binary tree\">\n\n\n<h3 id=\"二叉查找树-BST\"><a href=\"#二叉查找树-BST\" class=\"headerlink\" title=\"二叉查找树(BST)\"></a>二叉查找树(BST)</h3><p>二叉查找树(Binary Search Tree)是指一棵空树或者具有下列性质的二叉树:</p>\n<ul>\n<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>\n<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>\n<li>任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。</li>\n</ul>\n<h3 id=\"平衡二叉树-AVL\"><a href=\"#平衡二叉树-AVL\" class=\"headerlink\" title=\"平衡二叉树(AVL)\"></a>平衡二叉树(AVL)</h3><p>含有相同节点的二叉查找树可以有不同的形态，而二叉查找树的平均查找长度与树的深度有关，所以需要找出一个查找平均长度最小的一棵，那就是平衡二叉树，具有以下性质:</p>\n<ul>\n<li>要么是棵空树，要么其根节点左右子树的深度之差的绝对值不超过1；</li>\n<li>其左右子树也都是平衡二叉树；</li>\n<li>二叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则平衡二叉树的所有节点的平衡因子只可能是-1,0,1。</li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><p>红黑树也是一种自平衡的二叉查找树。</p>\n<ul>\n<li>每个结点要么是红的要么是黑的。(红或黑)</li>\n<li>根结点是黑的。(根黑)</li>\n<li>每个叶结点(叶结点即指树尾端NIL指针或NULL结点)都是黑的。(叶黑)</li>\n<li>如果一个结点是红的，那么它的两个儿子都是黑的。(红子黑)</li>\n<li>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。(路径下黑相同)</li>\n</ul>\n<h3 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h3><p>哈夫曼又称最优二叉树。是一种带权路径长度最短的二叉树：</p>\n<ul>\n<li>将所有左，右子树都为空的作为根节点。</li>\n<li>在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。</li>\n<li>从森林中删除这两棵树，同时把新树加入到森林中。</li>\n<li>重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。</li>\n</ul>\n<h3 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h3><p>B树(B-tree)是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一种自平衡的m阶树，与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。</p>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><p>B+ 树是一种树数据结构，通常用于关系型数据库(如Mysql)和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。b+树的非叶子节点不保存数据，只保存子树的临界值(最大或者最小)，所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。</p>\n<h3 id=\"R树\"><a href=\"#R树\" class=\"headerlink\" title=\"R树\"></a>R树</h3><p>R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。R树的核心思想是聚合距离相近的节点并在树结构的上一层将其表示为这些节点的最小外接矩形(MBR)，这个最小外接矩形就成为上一层的一个节点。因为所有节点都在它们的最小外接矩形中，所以跟某个矩形不相交的查询就一定跟这个矩形中的所有节点都不相交。叶子节点上的每个矩形都代表一个对象，节点都是对象的聚合，并且越往上层聚合的对象就越多。也可以把每一层看做是对数据集的近似，叶子节点层是最细粒度的近似，与数据集相似度100%，越往上层越粗糙。</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构第二章，讨论树。</p>\n<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><p>树作为一种树状的数据结构，其数据节点之间的关系也如大树一样，将有限个节点根据不同层次关系进行排列，从而形成数据与数据之间的父子关系。<br>树的数据存储在结点中，每个结点有零个或者多个子结点。没有父结点的结点在最顶端，成为根节点；没有非根结点有且只有一个父节点；每个非根节点又可以分为多个不相交的子树。</p>\n<img src=\"/2022/01/08/Data-Struct-2/struct_tree.png\" class=\"\" title=\"struct tree\">\n<ul>\n<li>子树: 除了根节点外，每个子节点都可以分为多个不相交的子树。</li>\n<li>孩子与双亲: 若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。上图中，B、H是A的孩子，A是B、H的双亲。</li>\n<li>兄弟: 具有相同双亲的节点互为兄弟，例如B与H互为兄弟。</li>\n<li>节点的度: 一个节点拥有子树的数目。例如A的度为2，B的度为1，C的度为3。</li>\n<li>叶子: 没有子树，也即是度为0的节点。</li>\n<li>分支节点: 除了叶子节点之外的节点，也即是度不为0的节点。</li>\n<li>内部节点: 除了根节点之外的分支节点。</li>\n<li>层次: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1。</li>\n<li>树的高度: 也称为树的深度，树中节点的最大层次。</li>\n<li>有序树: 树中节点各子树之间的次序是重要的，不可以随意交换位置。</li>\n<li>无序树: 树种节点各子树之间的次序是不重要的。可以随意交换位置。森林: 0或多棵互不相交的树的集合。例如图二中的两棵树为森林。</li>\n</ul>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>最多有两棵子树的树被称为二叉树。</p>\n<img src=\"/2022/01/08/Data-Struct-2/struct_tree.png\" class=\"\" title=\"struct tree\">\n\n<h3 id=\"斜树\"><a href=\"#斜树\" class=\"headerlink\" title=\"斜树\"></a>斜树</h3><p>所有节点都只有左子树的二叉树叫做左斜树，所有节点都只有右子树的二叉树叫做右斜树。</p>\n<h3 id=\"满二叉树\"><a href=\"#满二叉树\" class=\"headerlink\" title=\"满二叉树\"></a>满二叉树</h3><p>二叉树中所有非叶子结点的度都是2，且叶子结点都在同一层次上。</p>\n<img src=\"/2022/01/08/Data-Struct-2/struct_full_binary_tree.png\" class=\"\" title=\"full binary tree\">\n\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><p>如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树。</p>\n<img src=\"/2022/01/08/Data-Struct-2/complete_binary_tree.png\" class=\"\" title=\"complete binary tree\">\n\n\n<h3 id=\"二叉查找树-BST\"><a href=\"#二叉查找树-BST\" class=\"headerlink\" title=\"二叉查找树(BST)\"></a>二叉查找树(BST)</h3><p>二叉查找树(Binary Search Tree)是指一棵空树或者具有下列性质的二叉树:</p>\n<ul>\n<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>\n<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>\n<li>任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。</li>\n</ul>\n<h3 id=\"平衡二叉树-AVL\"><a href=\"#平衡二叉树-AVL\" class=\"headerlink\" title=\"平衡二叉树(AVL)\"></a>平衡二叉树(AVL)</h3><p>含有相同节点的二叉查找树可以有不同的形态，而二叉查找树的平均查找长度与树的深度有关，所以需要找出一个查找平均长度最小的一棵，那就是平衡二叉树，具有以下性质:</p>\n<ul>\n<li>要么是棵空树，要么其根节点左右子树的深度之差的绝对值不超过1；</li>\n<li>其左右子树也都是平衡二叉树；</li>\n<li>二叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则平衡二叉树的所有节点的平衡因子只可能是-1,0,1。</li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><p>红黑树也是一种自平衡的二叉查找树。</p>\n<ul>\n<li>每个结点要么是红的要么是黑的。(红或黑)</li>\n<li>根结点是黑的。(根黑)</li>\n<li>每个叶结点(叶结点即指树尾端NIL指针或NULL结点)都是黑的。(叶黑)</li>\n<li>如果一个结点是红的，那么它的两个儿子都是黑的。(红子黑)</li>\n<li>对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。(路径下黑相同)</li>\n</ul>\n<h3 id=\"哈夫曼树\"><a href=\"#哈夫曼树\" class=\"headerlink\" title=\"哈夫曼树\"></a>哈夫曼树</h3><p>哈夫曼又称最优二叉树。是一种带权路径长度最短的二叉树：</p>\n<ul>\n<li>将所有左，右子树都为空的作为根节点。</li>\n<li>在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。</li>\n<li>从森林中删除这两棵树，同时把新树加入到森林中。</li>\n<li>重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。</li>\n</ul>\n<h3 id=\"B树\"><a href=\"#B树\" class=\"headerlink\" title=\"B树\"></a>B树</h3><p>B树(B-tree)是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一种自平衡的m阶树，与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。</p>\n<h3 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h3><p>B+ 树是一种树数据结构，通常用于关系型数据库(如Mysql)和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。在B树基础上，为叶子结点增加链表指针(B树+叶子有序链表)，所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中。b+树的非叶子节点不保存数据，只保存子树的临界值(最大或者最小)，所以同样大小的节点，b+树相对于b树能够有更多的分支，使得这棵树更加矮胖，查询时做的IO操作次数也更少。</p>\n<h3 id=\"R树\"><a href=\"#R树\" class=\"headerlink\" title=\"R树\"></a>R树</h3><p>R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。R树的核心思想是聚合距离相近的节点并在树结构的上一层将其表示为这些节点的最小外接矩形(MBR)，这个最小外接矩形就成为上一层的一个节点。因为所有节点都在它们的最小外接矩形中，所以跟某个矩形不相交的查询就一定跟这个矩形中的所有节点都不相交。叶子节点上的每个矩形都代表一个对象，节点都是对象的聚合，并且越往上层聚合的对象就越多。也可以把每一层看做是对数据集的近似，叶子节点层是最细粒度的近似，与数据集相似度100%，越往上层越粗糙。</p>\n"},{"title":"Data Struct 3","date":"2022-01-09T11:13:09.000Z","_content":"\n### 简介\n数据结构第二章，讨论图。\n\n### 图\n图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。\n\n- 顶点的度(Degree)\n顶点的度是指在图中与Vi相关联的边的条数。对于有向图来说，有入度(In-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和。\n- 邻接\n若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接(Adjacent)；若有向图中存在一条边\\<V3,V2\\>，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；\n- 路径(Path)\n在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称顶点Vi到顶点Vj的顶点序列为从顶点Vi到顶点Vj的路径。\n- 连通(Connected)\n若从Vi到Vj有路径可通，则称顶点Vi和顶点Vj是连通的。\n- 权(Weight)\n有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。\n\n\n### 邻接矩阵(Adjacency Matrix)表示法\n图的邻接矩阵表示法是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。\n\n### 无向图(Undirected graphs)\n如果图中任意两个顶点之间的边都是无向边(简而言之就是没有方向的边)，则称该图为无向图。\n无向图中的边使用小括号“()”表示; 比如 (V1,V2);\n\n邻接矩阵表示法：\n{% asset_img struct_undirected_graphs.png undirected graphs %}\n\n### 有向图(Directed graphs)\n如果图中任意两个顶点之间的边都是有向边(简而言之就是有方向的边)，则称该图为有向图。\n有向图中的边使用尖括号“<>”表示; 比如\\<V1,V2\\>。\n\n邻接矩阵表示法：\n{% asset_img struct_directed_graphs.png directed graphs %}\n\n### 完全图(Complete graphs)\n- 无向完全图， 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。\n- 有向完全图，在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。\n\n\n\n\n\n\n","source":"_posts/Data-Struct-3.md","raw":"---\ntitle: Data Struct 3\ndate: 2022-01-09 19:13:09\ntags:\n   - IT-Basics\n   - Algorithm\n---\n\n### 简介\n数据结构第二章，讨论图。\n\n### 图\n图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。\n\n- 顶点的度(Degree)\n顶点的度是指在图中与Vi相关联的边的条数。对于有向图来说，有入度(In-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和。\n- 邻接\n若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接(Adjacent)；若有向图中存在一条边\\<V3,V2\\>，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；\n- 路径(Path)\n在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称顶点Vi到顶点Vj的顶点序列为从顶点Vi到顶点Vj的路径。\n- 连通(Connected)\n若从Vi到Vj有路径可通，则称顶点Vi和顶点Vj是连通的。\n- 权(Weight)\n有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。\n\n\n### 邻接矩阵(Adjacency Matrix)表示法\n图的邻接矩阵表示法是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。\n\n### 无向图(Undirected graphs)\n如果图中任意两个顶点之间的边都是无向边(简而言之就是没有方向的边)，则称该图为无向图。\n无向图中的边使用小括号“()”表示; 比如 (V1,V2);\n\n邻接矩阵表示法：\n{% asset_img struct_undirected_graphs.png undirected graphs %}\n\n### 有向图(Directed graphs)\n如果图中任意两个顶点之间的边都是有向边(简而言之就是有方向的边)，则称该图为有向图。\n有向图中的边使用尖括号“<>”表示; 比如\\<V1,V2\\>。\n\n邻接矩阵表示法：\n{% asset_img struct_directed_graphs.png directed graphs %}\n\n### 完全图(Complete graphs)\n- 无向完全图， 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。\n- 有向完全图，在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。\n\n\n\n\n\n\n","slug":"Data-Struct-3","published":1,"updated":"2024-03-13T13:51:22.576Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjr7000fem3i8idgbltc","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构第二章，讨论图。</p>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><p>图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>\n<ul>\n<li>顶点的度(Degree)<br>顶点的度是指在图中与Vi相关联的边的条数。对于有向图来说，有入度(In-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和。</li>\n<li>邻接<br>若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接(Adjacent)；若有向图中存在一条边&lt;V3,V2&gt;，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；</li>\n<li>路径(Path)<br>在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称顶点Vi到顶点Vj的顶点序列为从顶点Vi到顶点Vj的路径。</li>\n<li>连通(Connected)<br>若从Vi到Vj有路径可通，则称顶点Vi和顶点Vj是连通的。</li>\n<li>权(Weight)<br>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。</li>\n</ul>\n<h3 id=\"邻接矩阵-Adjacency-Matrix-表示法\"><a href=\"#邻接矩阵-Adjacency-Matrix-表示法\" class=\"headerlink\" title=\"邻接矩阵(Adjacency Matrix)表示法\"></a>邻接矩阵(Adjacency Matrix)表示法</h3><p>图的邻接矩阵表示法是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</p>\n<h3 id=\"无向图-Undirected-graphs\"><a href=\"#无向图-Undirected-graphs\" class=\"headerlink\" title=\"无向图(Undirected graphs)\"></a>无向图(Undirected graphs)</h3><p>如果图中任意两个顶点之间的边都是无向边(简而言之就是没有方向的边)，则称该图为无向图。<br>无向图中的边使用小括号“()”表示; 比如 (V1,V2);</p>\n<p>邻接矩阵表示法：</p>\n<img src=\"/2022/01/09/Data-Struct-3/struct_undirected_graphs.png\" class=\"\" title=\"undirected graphs\">\n\n<h3 id=\"有向图-Directed-graphs\"><a href=\"#有向图-Directed-graphs\" class=\"headerlink\" title=\"有向图(Directed graphs)\"></a>有向图(Directed graphs)</h3><p>如果图中任意两个顶点之间的边都是有向边(简而言之就是有方向的边)，则称该图为有向图。<br>有向图中的边使用尖括号“&lt;&gt;”表示; 比如&lt;V1,V2&gt;。</p>\n<p>邻接矩阵表示法：</p>\n<img src=\"/2022/01/09/Data-Struct-3/struct_directed_graphs.png\" class=\"\" title=\"directed graphs\">\n\n<h3 id=\"完全图-Complete-graphs\"><a href=\"#完全图-Complete-graphs\" class=\"headerlink\" title=\"完全图(Complete graphs)\"></a>完全图(Complete graphs)</h3><ul>\n<li>无向完全图， 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。</li>\n<li>有向完全图，在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>数据结构第二章，讨论图。</p>\n<h3 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h3><p>图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>\n<ul>\n<li>顶点的度(Degree)<br>顶点的度是指在图中与Vi相关联的边的条数。对于有向图来说，有入度(In-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和。</li>\n<li>邻接<br>若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接(Adjacent)；若有向图中存在一条边&lt;V3,V2&gt;，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；</li>\n<li>路径(Path)<br>在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称顶点Vi到顶点Vj的顶点序列为从顶点Vi到顶点Vj的路径。</li>\n<li>连通(Connected)<br>若从Vi到Vj有路径可通，则称顶点Vi和顶点Vj是连通的。</li>\n<li>权(Weight)<br>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。</li>\n</ul>\n<h3 id=\"邻接矩阵-Adjacency-Matrix-表示法\"><a href=\"#邻接矩阵-Adjacency-Matrix-表示法\" class=\"headerlink\" title=\"邻接矩阵(Adjacency Matrix)表示法\"></a>邻接矩阵(Adjacency Matrix)表示法</h3><p>图的邻接矩阵表示法是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</p>\n<h3 id=\"无向图-Undirected-graphs\"><a href=\"#无向图-Undirected-graphs\" class=\"headerlink\" title=\"无向图(Undirected graphs)\"></a>无向图(Undirected graphs)</h3><p>如果图中任意两个顶点之间的边都是无向边(简而言之就是没有方向的边)，则称该图为无向图。<br>无向图中的边使用小括号“()”表示; 比如 (V1,V2);</p>\n<p>邻接矩阵表示法：</p>\n<img src=\"/2022/01/09/Data-Struct-3/struct_undirected_graphs.png\" class=\"\" title=\"undirected graphs\">\n\n<h3 id=\"有向图-Directed-graphs\"><a href=\"#有向图-Directed-graphs\" class=\"headerlink\" title=\"有向图(Directed graphs)\"></a>有向图(Directed graphs)</h3><p>如果图中任意两个顶点之间的边都是有向边(简而言之就是有方向的边)，则称该图为有向图。<br>有向图中的边使用尖括号“&lt;&gt;”表示; 比如&lt;V1,V2&gt;。</p>\n<p>邻接矩阵表示法：</p>\n<img src=\"/2022/01/09/Data-Struct-3/struct_directed_graphs.png\" class=\"\" title=\"directed graphs\">\n\n<h3 id=\"完全图-Complete-graphs\"><a href=\"#完全图-Complete-graphs\" class=\"headerlink\" title=\"完全图(Complete graphs)\"></a>完全图(Complete graphs)</h3><ul>\n<li>无向完全图， 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。</li>\n<li>有向完全图，在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。</li>\n</ul>\n"},{"title":"My Desktop tools","date":"2022-03-11T05:33:14.000Z","_content":"\n### 1，简介\n为方便开发，搞一个PC桌面版工具套装，功能不断更新中，目前开发的功能如下：\n1，adb：adb命令大全示例和执行环境。\n2，Database：数据库管理软件。\n3，Git：adb命令大全示例和执行环境。\n4，Color：取色器。\n5，Screen：可获取屏幕信息，可以对屏幕信息截图(全屏或区域截图)。\n6，Casting：投屏助手\n7，MD：md示例和简单的编辑能力。\n8，TODO\n\n### 2，展示\n{% asset_img adb_tool.png tools shwo %}\n\n### 3，发布\n\n\n\n\n","source":"_posts/My-Desktop-tools.md","raw":"---\ntitle: My Desktop tools\ndate: 2022-03-11 13:33:14\ntags: Tool\n---\n\n### 1，简介\n为方便开发，搞一个PC桌面版工具套装，功能不断更新中，目前开发的功能如下：\n1，adb：adb命令大全示例和执行环境。\n2，Database：数据库管理软件。\n3，Git：adb命令大全示例和执行环境。\n4，Color：取色器。\n5，Screen：可获取屏幕信息，可以对屏幕信息截图(全屏或区域截图)。\n6，Casting：投屏助手\n7，MD：md示例和简单的编辑能力。\n8，TODO\n\n### 2，展示\n{% asset_img adb_tool.png tools shwo %}\n\n### 3，发布\n\n\n\n\n","slug":"My-Desktop-tools","published":1,"updated":"2024-03-13T13:51:22.578Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjr9000hem3if3qg4nrt","content":"<h3 id=\"1，简介\"><a href=\"#1，简介\" class=\"headerlink\" title=\"1，简介\"></a>1，简介</h3><p>为方便开发，搞一个PC桌面版工具套装，功能不断更新中，目前开发的功能如下：<br>1，adb：adb命令大全示例和执行环境。<br>2，Database：数据库管理软件。<br>3，Git：adb命令大全示例和执行环境。<br>4，Color：取色器。<br>5，Screen：可获取屏幕信息，可以对屏幕信息截图(全屏或区域截图)。<br>6，Casting：投屏助手<br>7，MD：md示例和简单的编辑能力。<br>8，TODO</p>\n<h3 id=\"2，展示\"><a href=\"#2，展示\" class=\"headerlink\" title=\"2，展示\"></a>2，展示</h3><img src=\"/2022/03/11/My-Desktop-tools/adb_tool.png\" class=\"\" title=\"tools shwo\">\n\n<h3 id=\"3，发布\"><a href=\"#3，发布\" class=\"headerlink\" title=\"3，发布\"></a>3，发布</h3>","excerpt":"","more":"<h3 id=\"1，简介\"><a href=\"#1，简介\" class=\"headerlink\" title=\"1，简介\"></a>1，简介</h3><p>为方便开发，搞一个PC桌面版工具套装，功能不断更新中，目前开发的功能如下：<br>1，adb：adb命令大全示例和执行环境。<br>2，Database：数据库管理软件。<br>3，Git：adb命令大全示例和执行环境。<br>4，Color：取色器。<br>5，Screen：可获取屏幕信息，可以对屏幕信息截图(全屏或区域截图)。<br>6，Casting：投屏助手<br>7，MD：md示例和简单的编辑能力。<br>8，TODO</p>\n<h3 id=\"2，展示\"><a href=\"#2，展示\" class=\"headerlink\" title=\"2，展示\"></a>2，展示</h3><img src=\"/2022/03/11/My-Desktop-tools/adb_tool.png\" class=\"\" title=\"tools shwo\">\n\n<h3 id=\"3，发布\"><a href=\"#3，发布\" class=\"headerlink\" title=\"3，发布\"></a>3，发布</h3>"},{"title":"OS Develop 2","date":"2022-03-22T12:10:06.000Z","_content":"\n### 简介\n本章介绍汇编语言。\n\n\n### 标号\n标号是充当指令或数据位置标记的标识符。\n- 数据标号\n{% blockquote %}\ncount DW 100 ;定义一个名为count的变量a\n{% endblockquote %}\n\n- 代码标号\n  以冒号结尾，表示一个位置，可以用于跳转。\n{% blockquote %}\nloop:\n\tjmp loop\n{% endblockquote %}\n\n### 伪指令\n伪指令不是真正的指令，它是由NASM的编译器提供支持，伪指令在编译的时候执行。\n- Dx族\n- Resx族\n- equ\n- times\n- vstar & org\n- incbin\n\n### 7种数据Size\n- byte ： 8 位\n- word ： 16 位\n- dword ： 32 位\n- qword ： 64 位\n- tword ： 80 位\n- oword ： 128 位\n- yword ： 256 位\n\n### Dx族\nDx族用来在内存中，顺序定义初始化数据。\nnasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。\n- db : define byte\n- dw ：define word\n- dd ：define doubleword\n- dq ：define quadword\n- dt ：define tword\n- do ：define oword\n- dy ：define yword\n\n例如：\n{% blockquote %}\ndb    0x55                ; just the byte 0x55\ndb    0x55,0x56,0x57      ; three bytes in succession\ndb    'a',0x55            ; character constants are OK\ndb    'hello',13,10,'$'   ; so are string constants\ndw    0x1234              ; 0x34 0x12\ndw    'a'                 ; 0x61 0x00 (it's just a number)\ndw    'ab'                ; 0x61 0x62 (character constant)\ndw    'abc'               ; 0x61 0x62 0x63 0x00 (string)\ndd    0x12345678          ; 0x78 0x56 0x34 0x12\ndd    1.234567e20         ; floating-point constant\ndq    0x123456789abcdef0  ; eight byte constant\ndq    1.234567e20         ; double-precision float\ndt    1.234567e20         ; extended-precision float\n{% endblockquote %}\n\n### Resx族\n这类伪指令，用来定义非初始化数据，非初始化数据存放在bass section中。\n- resb ：reserve byte\n- resw ：reserve word\n- resd ：reserve doubword\n- resq ：reserve quadword\n- rest ：reserve tword\n- reso ：reserve oword\n- resy ：reserve yword\n\n例如：\n{% blockquote %}\nbuffer:         resb    64              ; reserve 64 bytes\nwordvar:        resw    1               ; reserve a word\nrealarray       resq    10              ; array of ten reals\nymmval:         resy    1               ; one YMM register\n{% endblockquote %}\n\n\n### 变量定义\n【变量名】 变量类型  表达式\n例如：\n{% blockquote %}\na db 1,2,3,4,5\ndb 7,8,9,10 ;非变量定义，只定义数据\nb dw 123,123,123\nc db 'hello, world!'\n{% endblockquote %}\n\n上面定义的数据都是顺序存放在内存中的，所以虽然第二行的数据没有定义名字，但是因为他紧跟在a 数组之后 b数组之前，所以使用a+5,或者 b-1 也是可以访问的，只是需要注意的是数据类型和 大端小端的问题。\n声明的变量代表后面数据的地址，例如c是后面字符串的首地址，如果要使用，需要用中括号：\n\n{% blockquote %}\nmov ax, [c]\n{% endblockquote %}\n\n### equ\n它的作用和#define相同，它并不占用内存，在编译之后，它将替换被调用的地方，例如：\n{% blockquote %}\nnum equ 110\nmov ax, num\nmov bx, num\nmov cx, num\n{% endblockquote %}\n\n编译后：\n{% blockquote %}\nmov ax, 110\nmov bx, 110\nmov cx, 110\n{% endblockquote %}\n\n### \\$和\\$$\n\\$表示当前行的汇编地址。\n\\$$表示当前程序的起始汇编地址。\n\n### times\n后面指令重复次数。\n{% blockquote %}\nbuffer: db 'hello, world'\ntimes 64-$+buffer db '' ;补齐64字节\n{% endblockquote %}\n\n### incbin\n包含binary文件。例如\n{% blockquote %}\nncbin “file.dat” ; include the whole file  \nincbin “file.dat”,1024 ; skip the first 1024 bytes  \nincbin “file.dat”,1024,512 ; skip the first 1024, and  \n; actually include at most 512\n{% endblockquote %}\n\n### vstart & org\n程序的加载位置是由加载它的一方来决定的(因为加载后，加载方需要去访问被加载方，去哪里访问，这个是加载方来确定的)。vstart和org是告诉编译器，将后面的所有数据(指令和变量)的地址，加上一个偏移量。\n编译器以相对于文件开头偏移来编址的好处是利于重定位。程序内的地址是从0开始算的，当程序被加载到内存的某个地址(不一定是0)后，就需要用vstart或org来指定偏移量，这个偏移量也就是加载到内存的地址。\n\n\n### mov\n格式：\n{% blockquote %}\nmov 位宽 目的操作数，源操作数\n{% endblockquote %}\n\n目的操作数必需是一个容器，如内存单元、寄存器；源操作数可以是一个立即数，也可以是一个容器。\n\n举例：\n{% blockquote %}\nmov byte [0x00],'2'\n{% endblockquote %}\n\n### loop\nLoop指令需要和cx寄存器配合使用, 用于循环操作, 类似于高级语言中的for, while等。\ncx存放的是循环次数，循环一次，cx中的值减1，当cx中的值大于0时，执行loop循环。\n\n{% blockquote %}\n  mov cx, 11\ns:  \n  add ax, ax\n  loop s\n{% endblockquote %}\n\n### jmp\njmp 是无条件转移指令，无条件转移指令可转到内存中任何程序段，它可以只修改IP，也可以同时修改CS和IP。\n1，短程转移\n指令格式：JMP SHORT OPRD\n语法格式：JMP 地址标号 ；（IP）=（IP）+8位位移量\n指令功能：OPRD为转移地址的标号，指令中的SHORT规定了OPRD为有符号的8位二进制数，OPRD为转移地址的偏移量。该指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，从而实现程序的转移。转移的目标地址OPRD在指令中可以直接使用标号地址，但要求转移的目标地址的范围只能在JMP指令所处地址的－128～+127字节范围之内，如超出该范围，汇编时出错。\n\n2，近程转移\n指令格式：JMP NEAR PTR OPRD\n语法格式：JMP 地址标号 ；（IP）=（IP）+16位位移量\n指令功能：与短程转移的功能和要求相同，不同之处是近程转移的OPRD为有符号的16位二进制数，指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，转移的目标地址的范围只能在JMP指令所处地址的－32768～+32767字节范围之内，如超出该范围，汇编时出错。使用该指令时NEAR可省略。\n\n3，段间转移\n指令格式：JMP FAR PTR OPRD\n语法格式：JMP 地址标号 ；（IP）= 新的偏移地址, ；（CS）= 新的代码段地址\n指令功能：指令中用FAR PTR规定了该指令为段间的转移，OPRD为目的地址的标号，目的地址与JMP指令所在地址不在同一段内。执行该指令时要修改CS和IP的内容，将OPRD所在段的段地址送CS中，OPRD的段内偏移地址送IP中。\n\n4，段内间转移\n指令格式：JMP WORD PTR OPRD\n语法格式：JMP reg16/mem ；（IP）= 新的偏移地址\n指令功能：与短程转移的功能和要求相同，不同之处是段内间接转移的OPRD 可以是除立即数外的任何寄存或存储器寻址方式，转移的目标地址由OPRD的内容确定。\n\n5，段间间接转移\n指令格式：JMP DWORD PTR OPRD\n语法格式：JMP mem32\n指令功能：指令中用DWORD PTR规定了该指令为段间间接转移，OPRD只能是存储器寻址方式。执行该指令时将寻址到的内存单元的第一个字送入IP中，第二个字送入CS中。\n\n### 条件转移\n{% asset_img jmp_condition.png flag registor %}\n\n### call & ret\n在高级语言中，常有主程序调用其他子程序，子程序还可以调用子程序。\ncall指令可以实现调用一个子程序，在子程序里使用ret指令结束子程序的执行并返回主程序（类比C语言中的main函数调用cube函数进行理解），主程序继续往下执行。\n\n{% blockquote %}\nmov ax,0\ncall s     ;s是标号，执行call后，执行s标号所在的子程序\nmov ax,4c00h\nint 21h\n\ns:add ax,1   ;标号所在子程序\n  mov bx,10\n  ret        ;子程序执行完后，返回主程序\n{% endblockquote %}\n\n### push & pop\npush和pop是用来操作栈的2个指令；push将一个寄存器中的数据入栈，pop出栈用一个寄存器接收数据；相关的寄存器`SS:SP`。\n举例：\nmov ax 123H\npush ax 的执行，由以下两步完成。\n(1) SP = SP - 2, SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；\n(2) 将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。\n\n\n### int\nint指令是X86汇编语言中最重要的指令之一。它的作用是引发中断，调用“中断例程”（interrupt routine）\n\n指令格式：\n{% blockquote %}\nint n ;n是中端号\n{% endblockquote %}\n\n指令执行过程：\n{% blockquote %}\n1，取中断类型码n；\n2，标志寄存器入栈（pushf），IF=0，TF=0（重置中断标志位）；\n3，CS、IP入栈；\n4，查中断向量表， (IP)=(n\\*4)，(CS)=(n\\*4+2)。\n{% endblockquote %}\n\n","source":"_posts/OS-Develop-2.md","raw":"---\ntitle: OS Develop 2\ndate: 2022-03-22 20:10:06\ntags:\n   - IT-Basics\n   - OS\n---\n\n### 简介\n本章介绍汇编语言。\n\n\n### 标号\n标号是充当指令或数据位置标记的标识符。\n- 数据标号\n{% blockquote %}\ncount DW 100 ;定义一个名为count的变量a\n{% endblockquote %}\n\n- 代码标号\n  以冒号结尾，表示一个位置，可以用于跳转。\n{% blockquote %}\nloop:\n\tjmp loop\n{% endblockquote %}\n\n### 伪指令\n伪指令不是真正的指令，它是由NASM的编译器提供支持，伪指令在编译的时候执行。\n- Dx族\n- Resx族\n- equ\n- times\n- vstar & org\n- incbin\n\n### 7种数据Size\n- byte ： 8 位\n- word ： 16 位\n- dword ： 32 位\n- qword ： 64 位\n- tword ： 80 位\n- oword ： 128 位\n- yword ： 256 位\n\n### Dx族\nDx族用来在内存中，顺序定义初始化数据。\nnasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。\n- db : define byte\n- dw ：define word\n- dd ：define doubleword\n- dq ：define quadword\n- dt ：define tword\n- do ：define oword\n- dy ：define yword\n\n例如：\n{% blockquote %}\ndb    0x55                ; just the byte 0x55\ndb    0x55,0x56,0x57      ; three bytes in succession\ndb    'a',0x55            ; character constants are OK\ndb    'hello',13,10,'$'   ; so are string constants\ndw    0x1234              ; 0x34 0x12\ndw    'a'                 ; 0x61 0x00 (it's just a number)\ndw    'ab'                ; 0x61 0x62 (character constant)\ndw    'abc'               ; 0x61 0x62 0x63 0x00 (string)\ndd    0x12345678          ; 0x78 0x56 0x34 0x12\ndd    1.234567e20         ; floating-point constant\ndq    0x123456789abcdef0  ; eight byte constant\ndq    1.234567e20         ; double-precision float\ndt    1.234567e20         ; extended-precision float\n{% endblockquote %}\n\n### Resx族\n这类伪指令，用来定义非初始化数据，非初始化数据存放在bass section中。\n- resb ：reserve byte\n- resw ：reserve word\n- resd ：reserve doubword\n- resq ：reserve quadword\n- rest ：reserve tword\n- reso ：reserve oword\n- resy ：reserve yword\n\n例如：\n{% blockquote %}\nbuffer:         resb    64              ; reserve 64 bytes\nwordvar:        resw    1               ; reserve a word\nrealarray       resq    10              ; array of ten reals\nymmval:         resy    1               ; one YMM register\n{% endblockquote %}\n\n\n### 变量定义\n【变量名】 变量类型  表达式\n例如：\n{% blockquote %}\na db 1,2,3,4,5\ndb 7,8,9,10 ;非变量定义，只定义数据\nb dw 123,123,123\nc db 'hello, world!'\n{% endblockquote %}\n\n上面定义的数据都是顺序存放在内存中的，所以虽然第二行的数据没有定义名字，但是因为他紧跟在a 数组之后 b数组之前，所以使用a+5,或者 b-1 也是可以访问的，只是需要注意的是数据类型和 大端小端的问题。\n声明的变量代表后面数据的地址，例如c是后面字符串的首地址，如果要使用，需要用中括号：\n\n{% blockquote %}\nmov ax, [c]\n{% endblockquote %}\n\n### equ\n它的作用和#define相同，它并不占用内存，在编译之后，它将替换被调用的地方，例如：\n{% blockquote %}\nnum equ 110\nmov ax, num\nmov bx, num\nmov cx, num\n{% endblockquote %}\n\n编译后：\n{% blockquote %}\nmov ax, 110\nmov bx, 110\nmov cx, 110\n{% endblockquote %}\n\n### \\$和\\$$\n\\$表示当前行的汇编地址。\n\\$$表示当前程序的起始汇编地址。\n\n### times\n后面指令重复次数。\n{% blockquote %}\nbuffer: db 'hello, world'\ntimes 64-$+buffer db '' ;补齐64字节\n{% endblockquote %}\n\n### incbin\n包含binary文件。例如\n{% blockquote %}\nncbin “file.dat” ; include the whole file  \nincbin “file.dat”,1024 ; skip the first 1024 bytes  \nincbin “file.dat”,1024,512 ; skip the first 1024, and  \n; actually include at most 512\n{% endblockquote %}\n\n### vstart & org\n程序的加载位置是由加载它的一方来决定的(因为加载后，加载方需要去访问被加载方，去哪里访问，这个是加载方来确定的)。vstart和org是告诉编译器，将后面的所有数据(指令和变量)的地址，加上一个偏移量。\n编译器以相对于文件开头偏移来编址的好处是利于重定位。程序内的地址是从0开始算的，当程序被加载到内存的某个地址(不一定是0)后，就需要用vstart或org来指定偏移量，这个偏移量也就是加载到内存的地址。\n\n\n### mov\n格式：\n{% blockquote %}\nmov 位宽 目的操作数，源操作数\n{% endblockquote %}\n\n目的操作数必需是一个容器，如内存单元、寄存器；源操作数可以是一个立即数，也可以是一个容器。\n\n举例：\n{% blockquote %}\nmov byte [0x00],'2'\n{% endblockquote %}\n\n### loop\nLoop指令需要和cx寄存器配合使用, 用于循环操作, 类似于高级语言中的for, while等。\ncx存放的是循环次数，循环一次，cx中的值减1，当cx中的值大于0时，执行loop循环。\n\n{% blockquote %}\n  mov cx, 11\ns:  \n  add ax, ax\n  loop s\n{% endblockquote %}\n\n### jmp\njmp 是无条件转移指令，无条件转移指令可转到内存中任何程序段，它可以只修改IP，也可以同时修改CS和IP。\n1，短程转移\n指令格式：JMP SHORT OPRD\n语法格式：JMP 地址标号 ；（IP）=（IP）+8位位移量\n指令功能：OPRD为转移地址的标号，指令中的SHORT规定了OPRD为有符号的8位二进制数，OPRD为转移地址的偏移量。该指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，从而实现程序的转移。转移的目标地址OPRD在指令中可以直接使用标号地址，但要求转移的目标地址的范围只能在JMP指令所处地址的－128～+127字节范围之内，如超出该范围，汇编时出错。\n\n2，近程转移\n指令格式：JMP NEAR PTR OPRD\n语法格式：JMP 地址标号 ；（IP）=（IP）+16位位移量\n指令功能：与短程转移的功能和要求相同，不同之处是近程转移的OPRD为有符号的16位二进制数，指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，转移的目标地址的范围只能在JMP指令所处地址的－32768～+32767字节范围之内，如超出该范围，汇编时出错。使用该指令时NEAR可省略。\n\n3，段间转移\n指令格式：JMP FAR PTR OPRD\n语法格式：JMP 地址标号 ；（IP）= 新的偏移地址, ；（CS）= 新的代码段地址\n指令功能：指令中用FAR PTR规定了该指令为段间的转移，OPRD为目的地址的标号，目的地址与JMP指令所在地址不在同一段内。执行该指令时要修改CS和IP的内容，将OPRD所在段的段地址送CS中，OPRD的段内偏移地址送IP中。\n\n4，段内间转移\n指令格式：JMP WORD PTR OPRD\n语法格式：JMP reg16/mem ；（IP）= 新的偏移地址\n指令功能：与短程转移的功能和要求相同，不同之处是段内间接转移的OPRD 可以是除立即数外的任何寄存或存储器寻址方式，转移的目标地址由OPRD的内容确定。\n\n5，段间间接转移\n指令格式：JMP DWORD PTR OPRD\n语法格式：JMP mem32\n指令功能：指令中用DWORD PTR规定了该指令为段间间接转移，OPRD只能是存储器寻址方式。执行该指令时将寻址到的内存单元的第一个字送入IP中，第二个字送入CS中。\n\n### 条件转移\n{% asset_img jmp_condition.png flag registor %}\n\n### call & ret\n在高级语言中，常有主程序调用其他子程序，子程序还可以调用子程序。\ncall指令可以实现调用一个子程序，在子程序里使用ret指令结束子程序的执行并返回主程序（类比C语言中的main函数调用cube函数进行理解），主程序继续往下执行。\n\n{% blockquote %}\nmov ax,0\ncall s     ;s是标号，执行call后，执行s标号所在的子程序\nmov ax,4c00h\nint 21h\n\ns:add ax,1   ;标号所在子程序\n  mov bx,10\n  ret        ;子程序执行完后，返回主程序\n{% endblockquote %}\n\n### push & pop\npush和pop是用来操作栈的2个指令；push将一个寄存器中的数据入栈，pop出栈用一个寄存器接收数据；相关的寄存器`SS:SP`。\n举例：\nmov ax 123H\npush ax 的执行，由以下两步完成。\n(1) SP = SP - 2, SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；\n(2) 将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。\n\n\n### int\nint指令是X86汇编语言中最重要的指令之一。它的作用是引发中断，调用“中断例程”（interrupt routine）\n\n指令格式：\n{% blockquote %}\nint n ;n是中端号\n{% endblockquote %}\n\n指令执行过程：\n{% blockquote %}\n1，取中断类型码n；\n2，标志寄存器入栈（pushf），IF=0，TF=0（重置中断标志位）；\n3，CS、IP入栈；\n4，查中断向量表， (IP)=(n\\*4)，(CS)=(n\\*4+2)。\n{% endblockquote %}\n\n","slug":"OS-Develop-2","published":1,"updated":"2024-03-13T13:51:22.590Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjra000kem3ih4vfbu2p","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本章介绍汇编语言。</p>\n<h3 id=\"标号\"><a href=\"#标号\" class=\"headerlink\" title=\"标号\"></a>标号</h3><p>标号是充当指令或数据位置标记的标识符。</p>\n<ul>\n<li><p>数据标号</p>\n<blockquote><p>count DW 100 ;定义一个名为count的变量a</p>\n</blockquote>\n</li>\n<li><p>代码标号<br>以冒号结尾，表示一个位置，可以用于跳转。</p>\n<blockquote><p>loop:<br>    jmp loop</p>\n</blockquote></li>\n</ul>\n<h3 id=\"伪指令\"><a href=\"#伪指令\" class=\"headerlink\" title=\"伪指令\"></a>伪指令</h3><p>伪指令不是真正的指令，它是由NASM的编译器提供支持，伪指令在编译的时候执行。</p>\n<ul>\n<li>Dx族</li>\n<li>Resx族</li>\n<li>equ</li>\n<li>times</li>\n<li>vstar &amp; org</li>\n<li>incbin</li>\n</ul>\n<h3 id=\"7种数据Size\"><a href=\"#7种数据Size\" class=\"headerlink\" title=\"7种数据Size\"></a>7种数据Size</h3><ul>\n<li>byte ： 8 位</li>\n<li>word ： 16 位</li>\n<li>dword ： 32 位</li>\n<li>qword ： 64 位</li>\n<li>tword ： 80 位</li>\n<li>oword ： 128 位</li>\n<li>yword ： 256 位</li>\n</ul>\n<h3 id=\"Dx族\"><a href=\"#Dx族\" class=\"headerlink\" title=\"Dx族\"></a>Dx族</h3><p>Dx族用来在内存中，顺序定义初始化数据。<br>nasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。</p>\n<ul>\n<li>db : define byte</li>\n<li>dw ：define word</li>\n<li>dd ：define doubleword</li>\n<li>dq ：define quadword</li>\n<li>dt ：define tword</li>\n<li>do ：define oword</li>\n<li>dy ：define yword</li>\n</ul>\n<p>例如：</p>\n<blockquote><p>db    0x55                ; just the byte 0x55<br>db    0x55,0x56,0x57      ; three bytes in succession<br>db    ‘a’,0x55            ; character constants are OK<br>db    ‘hello’,13,10,’$’   ; so are string constants<br>dw    0x1234              ; 0x34 0x12<br>dw    ‘a’                 ; 0x61 0x00 (it’s just a number)<br>dw    ‘ab’                ; 0x61 0x62 (character constant)<br>dw    ‘abc’               ; 0x61 0x62 0x63 0x00 (string)<br>dd    0x12345678          ; 0x78 0x56 0x34 0x12<br>dd    1.234567e20         ; floating-point constant<br>dq    0x123456789abcdef0  ; eight byte constant<br>dq    1.234567e20         ; double-precision float<br>dt    1.234567e20         ; extended-precision float</p>\n</blockquote>\n\n<h3 id=\"Resx族\"><a href=\"#Resx族\" class=\"headerlink\" title=\"Resx族\"></a>Resx族</h3><p>这类伪指令，用来定义非初始化数据，非初始化数据存放在bass section中。</p>\n<ul>\n<li>resb ：reserve byte</li>\n<li>resw ：reserve word</li>\n<li>resd ：reserve doubword</li>\n<li>resq ：reserve quadword</li>\n<li>rest ：reserve tword</li>\n<li>reso ：reserve oword</li>\n<li>resy ：reserve yword</li>\n</ul>\n<p>例如：</p>\n<blockquote><p>buffer:         resb    64              ; reserve 64 bytes<br>wordvar:        resw    1               ; reserve a word<br>realarray       resq    10              ; array of ten reals<br>ymmval:         resy    1               ; one YMM register</p>\n</blockquote>\n\n\n<h3 id=\"变量定义\"><a href=\"#变量定义\" class=\"headerlink\" title=\"变量定义\"></a>变量定义</h3><p>【变量名】 变量类型  表达式<br>例如：</p>\n<blockquote><p>a db 1,2,3,4,5<br>db 7,8,9,10 ;非变量定义，只定义数据<br>b dw 123,123,123<br>c db ‘hello, world!’</p>\n</blockquote>\n\n<p>上面定义的数据都是顺序存放在内存中的，所以虽然第二行的数据没有定义名字，但是因为他紧跟在a 数组之后 b数组之前，所以使用a+5,或者 b-1 也是可以访问的，只是需要注意的是数据类型和 大端小端的问题。<br>声明的变量代表后面数据的地址，例如c是后面字符串的首地址，如果要使用，需要用中括号：</p>\n<blockquote><p>mov ax, [c]</p>\n</blockquote>\n\n<h3 id=\"equ\"><a href=\"#equ\" class=\"headerlink\" title=\"equ\"></a>equ</h3><p>它的作用和#define相同，它并不占用内存，在编译之后，它将替换被调用的地方，例如：</p>\n<blockquote><p>num equ 110<br>mov ax, num<br>mov bx, num<br>mov cx, num</p>\n</blockquote>\n\n<p>编译后：</p>\n<blockquote><p>mov ax, 110<br>mov bx, 110<br>mov cx, 110</p>\n</blockquote>\n\n<h3 id=\"和\"><a href=\"#和\" class=\"headerlink\" title=\"$和$$\"></a>$和$$</h3><p>$表示当前行的汇编地址。<br>$$表示当前程序的起始汇编地址。</p>\n<h3 id=\"times\"><a href=\"#times\" class=\"headerlink\" title=\"times\"></a>times</h3><p>后面指令重复次数。</p>\n<blockquote><p>buffer: db ‘hello, world’<br>times 64-$+buffer db ‘’ ;补齐64字节</p>\n</blockquote>\n\n<h3 id=\"incbin\"><a href=\"#incbin\" class=\"headerlink\" title=\"incbin\"></a>incbin</h3><p>包含binary文件。例如</p>\n<blockquote><p>ncbin “file.dat” ; include the whole file<br>incbin “file.dat”,1024 ; skip the first 1024 bytes<br>incbin “file.dat”,1024,512 ; skip the first 1024, and<br>; actually include at most 512</p>\n</blockquote>\n\n<h3 id=\"vstart-org\"><a href=\"#vstart-org\" class=\"headerlink\" title=\"vstart &amp; org\"></a>vstart &amp; org</h3><p>程序的加载位置是由加载它的一方来决定的(因为加载后，加载方需要去访问被加载方，去哪里访问，这个是加载方来确定的)。vstart和org是告诉编译器，将后面的所有数据(指令和变量)的地址，加上一个偏移量。<br>编译器以相对于文件开头偏移来编址的好处是利于重定位。程序内的地址是从0开始算的，当程序被加载到内存的某个地址(不一定是0)后，就需要用vstart或org来指定偏移量，这个偏移量也就是加载到内存的地址。</p>\n<h3 id=\"mov\"><a href=\"#mov\" class=\"headerlink\" title=\"mov\"></a>mov</h3><p>格式：</p>\n<blockquote><p>mov 位宽 目的操作数，源操作数</p>\n</blockquote>\n\n<p>目的操作数必需是一个容器，如内存单元、寄存器；源操作数可以是一个立即数，也可以是一个容器。</p>\n<p>举例：</p>\n<blockquote><p>mov byte [0x00],’2’</p>\n</blockquote>\n\n<h3 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h3><p>Loop指令需要和cx寄存器配合使用, 用于循环操作, 类似于高级语言中的for, while等。<br>cx存放的是循环次数，循环一次，cx中的值减1，当cx中的值大于0时，执行loop循环。</p>\n<blockquote><p>  mov cx, 11<br>s:<br>  add ax, ax<br>  loop s</p>\n</blockquote>\n\n<h3 id=\"jmp\"><a href=\"#jmp\" class=\"headerlink\" title=\"jmp\"></a>jmp</h3><p>jmp 是无条件转移指令，无条件转移指令可转到内存中任何程序段，它可以只修改IP，也可以同时修改CS和IP。<br>1，短程转移<br>指令格式：JMP SHORT OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D;（IP）+8位位移量<br>指令功能：OPRD为转移地址的标号，指令中的SHORT规定了OPRD为有符号的8位二进制数，OPRD为转移地址的偏移量。该指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，从而实现程序的转移。转移的目标地址OPRD在指令中可以直接使用标号地址，但要求转移的目标地址的范围只能在JMP指令所处地址的－128～+127字节范围之内，如超出该范围，汇编时出错。</p>\n<p>2，近程转移<br>指令格式：JMP NEAR PTR OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D;（IP）+16位位移量<br>指令功能：与短程转移的功能和要求相同，不同之处是近程转移的OPRD为有符号的16位二进制数，指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，转移的目标地址的范围只能在JMP指令所处地址的－32768～+32767字节范围之内，如超出该范围，汇编时出错。使用该指令时NEAR可省略。</p>\n<p>3，段间转移<br>指令格式：JMP FAR PTR OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D; 新的偏移地址, ；（CS）&#x3D; 新的代码段地址<br>指令功能：指令中用FAR PTR规定了该指令为段间的转移，OPRD为目的地址的标号，目的地址与JMP指令所在地址不在同一段内。执行该指令时要修改CS和IP的内容，将OPRD所在段的段地址送CS中，OPRD的段内偏移地址送IP中。</p>\n<p>4，段内间转移<br>指令格式：JMP WORD PTR OPRD<br>语法格式：JMP reg16&#x2F;mem ；（IP）&#x3D; 新的偏移地址<br>指令功能：与短程转移的功能和要求相同，不同之处是段内间接转移的OPRD 可以是除立即数外的任何寄存或存储器寻址方式，转移的目标地址由OPRD的内容确定。</p>\n<p>5，段间间接转移<br>指令格式：JMP DWORD PTR OPRD<br>语法格式：JMP mem32<br>指令功能：指令中用DWORD PTR规定了该指令为段间间接转移，OPRD只能是存储器寻址方式。执行该指令时将寻址到的内存单元的第一个字送入IP中，第二个字送入CS中。</p>\n<h3 id=\"条件转移\"><a href=\"#条件转移\" class=\"headerlink\" title=\"条件转移\"></a>条件转移</h3><img src=\"/2022/03/22/OS-Develop-2/jmp_condition.png\" class=\"\" title=\"flag registor\">\n\n<h3 id=\"call-ret\"><a href=\"#call-ret\" class=\"headerlink\" title=\"call &amp; ret\"></a>call &amp; ret</h3><p>在高级语言中，常有主程序调用其他子程序，子程序还可以调用子程序。<br>call指令可以实现调用一个子程序，在子程序里使用ret指令结束子程序的执行并返回主程序（类比C语言中的main函数调用cube函数进行理解），主程序继续往下执行。</p>\n<blockquote><p>mov ax,0<br>call s     ;s是标号，执行call后，执行s标号所在的子程序<br>mov ax,4c00h<br>int 21h</p>\n<p>s:add ax,1   ;标号所在子程序<br>  mov bx,10<br>  ret        ;子程序执行完后，返回主程序</p>\n</blockquote>\n\n<h3 id=\"push-pop\"><a href=\"#push-pop\" class=\"headerlink\" title=\"push &amp; pop\"></a>push &amp; pop</h3><p>push和pop是用来操作栈的2个指令；push将一个寄存器中的数据入栈，pop出栈用一个寄存器接收数据；相关的寄存器<code>SS:SP</code>。<br>举例：<br>mov ax 123H<br>push ax 的执行，由以下两步完成。<br>(1) SP &#x3D; SP - 2, SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；<br>(2) 将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。</p>\n<h3 id=\"int\"><a href=\"#int\" class=\"headerlink\" title=\"int\"></a>int</h3><p>int指令是X86汇编语言中最重要的指令之一。它的作用是引发中断，调用“中断例程”（interrupt routine）</p>\n<p>指令格式：</p>\n<blockquote><p>int n ;n是中端号</p>\n</blockquote>\n\n<p>指令执行过程：</p>\n<blockquote><p>1，取中断类型码n；<br>2，标志寄存器入栈（pushf），IF&#x3D;0，TF&#x3D;0（重置中断标志位）；<br>3，CS、IP入栈；<br>4，查中断向量表， (IP)&#x3D;(n*4)，(CS)&#x3D;(n*4+2)。</p>\n</blockquote>\n\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本章介绍汇编语言。</p>\n<h3 id=\"标号\"><a href=\"#标号\" class=\"headerlink\" title=\"标号\"></a>标号</h3><p>标号是充当指令或数据位置标记的标识符。</p>\n<ul>\n<li><p>数据标号</p>\n<blockquote><p>count DW 100 ;定义一个名为count的变量a</p>\n</blockquote>\n</li>\n<li><p>代码标号<br>以冒号结尾，表示一个位置，可以用于跳转。</p>\n<blockquote><p>loop:<br>    jmp loop</p>\n</blockquote></li>\n</ul>\n<h3 id=\"伪指令\"><a href=\"#伪指令\" class=\"headerlink\" title=\"伪指令\"></a>伪指令</h3><p>伪指令不是真正的指令，它是由NASM的编译器提供支持，伪指令在编译的时候执行。</p>\n<ul>\n<li>Dx族</li>\n<li>Resx族</li>\n<li>equ</li>\n<li>times</li>\n<li>vstar &amp; org</li>\n<li>incbin</li>\n</ul>\n<h3 id=\"7种数据Size\"><a href=\"#7种数据Size\" class=\"headerlink\" title=\"7种数据Size\"></a>7种数据Size</h3><ul>\n<li>byte ： 8 位</li>\n<li>word ： 16 位</li>\n<li>dword ： 32 位</li>\n<li>qword ： 64 位</li>\n<li>tword ： 80 位</li>\n<li>oword ： 128 位</li>\n<li>yword ： 256 位</li>\n</ul>\n<h3 id=\"Dx族\"><a href=\"#Dx族\" class=\"headerlink\" title=\"Dx族\"></a>Dx族</h3><p>Dx族用来在内存中，顺序定义初始化数据。<br>nasm 定义了用于初始化上面 7 种 size 的 db 家族，它们用于定义初化常量值。</p>\n<ul>\n<li>db : define byte</li>\n<li>dw ：define word</li>\n<li>dd ：define doubleword</li>\n<li>dq ：define quadword</li>\n<li>dt ：define tword</li>\n<li>do ：define oword</li>\n<li>dy ：define yword</li>\n</ul>\n<p>例如：</p>\n<blockquote><p>db    0x55                ; just the byte 0x55<br>db    0x55,0x56,0x57      ; three bytes in succession<br>db    ‘a’,0x55            ; character constants are OK<br>db    ‘hello’,13,10,’$’   ; so are string constants<br>dw    0x1234              ; 0x34 0x12<br>dw    ‘a’                 ; 0x61 0x00 (it’s just a number)<br>dw    ‘ab’                ; 0x61 0x62 (character constant)<br>dw    ‘abc’               ; 0x61 0x62 0x63 0x00 (string)<br>dd    0x12345678          ; 0x78 0x56 0x34 0x12<br>dd    1.234567e20         ; floating-point constant<br>dq    0x123456789abcdef0  ; eight byte constant<br>dq    1.234567e20         ; double-precision float<br>dt    1.234567e20         ; extended-precision float</p>\n</blockquote>\n\n<h3 id=\"Resx族\"><a href=\"#Resx族\" class=\"headerlink\" title=\"Resx族\"></a>Resx族</h3><p>这类伪指令，用来定义非初始化数据，非初始化数据存放在bass section中。</p>\n<ul>\n<li>resb ：reserve byte</li>\n<li>resw ：reserve word</li>\n<li>resd ：reserve doubword</li>\n<li>resq ：reserve quadword</li>\n<li>rest ：reserve tword</li>\n<li>reso ：reserve oword</li>\n<li>resy ：reserve yword</li>\n</ul>\n<p>例如：</p>\n<blockquote><p>buffer:         resb    64              ; reserve 64 bytes<br>wordvar:        resw    1               ; reserve a word<br>realarray       resq    10              ; array of ten reals<br>ymmval:         resy    1               ; one YMM register</p>\n</blockquote>\n\n\n<h3 id=\"变量定义\"><a href=\"#变量定义\" class=\"headerlink\" title=\"变量定义\"></a>变量定义</h3><p>【变量名】 变量类型  表达式<br>例如：</p>\n<blockquote><p>a db 1,2,3,4,5<br>db 7,8,9,10 ;非变量定义，只定义数据<br>b dw 123,123,123<br>c db ‘hello, world!’</p>\n</blockquote>\n\n<p>上面定义的数据都是顺序存放在内存中的，所以虽然第二行的数据没有定义名字，但是因为他紧跟在a 数组之后 b数组之前，所以使用a+5,或者 b-1 也是可以访问的，只是需要注意的是数据类型和 大端小端的问题。<br>声明的变量代表后面数据的地址，例如c是后面字符串的首地址，如果要使用，需要用中括号：</p>\n<blockquote><p>mov ax, [c]</p>\n</blockquote>\n\n<h3 id=\"equ\"><a href=\"#equ\" class=\"headerlink\" title=\"equ\"></a>equ</h3><p>它的作用和#define相同，它并不占用内存，在编译之后，它将替换被调用的地方，例如：</p>\n<blockquote><p>num equ 110<br>mov ax, num<br>mov bx, num<br>mov cx, num</p>\n</blockquote>\n\n<p>编译后：</p>\n<blockquote><p>mov ax, 110<br>mov bx, 110<br>mov cx, 110</p>\n</blockquote>\n\n<h3 id=\"和\"><a href=\"#和\" class=\"headerlink\" title=\"$和$$\"></a>$和$$</h3><p>$表示当前行的汇编地址。<br>$$表示当前程序的起始汇编地址。</p>\n<h3 id=\"times\"><a href=\"#times\" class=\"headerlink\" title=\"times\"></a>times</h3><p>后面指令重复次数。</p>\n<blockquote><p>buffer: db ‘hello, world’<br>times 64-$+buffer db ‘’ ;补齐64字节</p>\n</blockquote>\n\n<h3 id=\"incbin\"><a href=\"#incbin\" class=\"headerlink\" title=\"incbin\"></a>incbin</h3><p>包含binary文件。例如</p>\n<blockquote><p>ncbin “file.dat” ; include the whole file<br>incbin “file.dat”,1024 ; skip the first 1024 bytes<br>incbin “file.dat”,1024,512 ; skip the first 1024, and<br>; actually include at most 512</p>\n</blockquote>\n\n<h3 id=\"vstart-org\"><a href=\"#vstart-org\" class=\"headerlink\" title=\"vstart &amp; org\"></a>vstart &amp; org</h3><p>程序的加载位置是由加载它的一方来决定的(因为加载后，加载方需要去访问被加载方，去哪里访问，这个是加载方来确定的)。vstart和org是告诉编译器，将后面的所有数据(指令和变量)的地址，加上一个偏移量。<br>编译器以相对于文件开头偏移来编址的好处是利于重定位。程序内的地址是从0开始算的，当程序被加载到内存的某个地址(不一定是0)后，就需要用vstart或org来指定偏移量，这个偏移量也就是加载到内存的地址。</p>\n<h3 id=\"mov\"><a href=\"#mov\" class=\"headerlink\" title=\"mov\"></a>mov</h3><p>格式：</p>\n<blockquote><p>mov 位宽 目的操作数，源操作数</p>\n</blockquote>\n\n<p>目的操作数必需是一个容器，如内存单元、寄存器；源操作数可以是一个立即数，也可以是一个容器。</p>\n<p>举例：</p>\n<blockquote><p>mov byte [0x00],’2’</p>\n</blockquote>\n\n<h3 id=\"loop\"><a href=\"#loop\" class=\"headerlink\" title=\"loop\"></a>loop</h3><p>Loop指令需要和cx寄存器配合使用, 用于循环操作, 类似于高级语言中的for, while等。<br>cx存放的是循环次数，循环一次，cx中的值减1，当cx中的值大于0时，执行loop循环。</p>\n<blockquote><p>  mov cx, 11<br>s:<br>  add ax, ax<br>  loop s</p>\n</blockquote>\n\n<h3 id=\"jmp\"><a href=\"#jmp\" class=\"headerlink\" title=\"jmp\"></a>jmp</h3><p>jmp 是无条件转移指令，无条件转移指令可转到内存中任何程序段，它可以只修改IP，也可以同时修改CS和IP。<br>1，短程转移<br>指令格式：JMP SHORT OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D;（IP）+8位位移量<br>指令功能：OPRD为转移地址的标号，指令中的SHORT规定了OPRD为有符号的8位二进制数，OPRD为转移地址的偏移量。该指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，从而实现程序的转移。转移的目标地址OPRD在指令中可以直接使用标号地址，但要求转移的目标地址的范围只能在JMP指令所处地址的－128～+127字节范围之内，如超出该范围，汇编时出错。</p>\n<p>2，近程转移<br>指令格式：JMP NEAR PTR OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D;（IP）+16位位移量<br>指令功能：与短程转移的功能和要求相同，不同之处是近程转移的OPRD为有符号的16位二进制数，指令将程序执行的顺序转移到由（IP）+OPRD形成的新的程序执行的目标地址，转移的目标地址的范围只能在JMP指令所处地址的－32768～+32767字节范围之内，如超出该范围，汇编时出错。使用该指令时NEAR可省略。</p>\n<p>3，段间转移<br>指令格式：JMP FAR PTR OPRD<br>语法格式：JMP 地址标号 ；（IP）&#x3D; 新的偏移地址, ；（CS）&#x3D; 新的代码段地址<br>指令功能：指令中用FAR PTR规定了该指令为段间的转移，OPRD为目的地址的标号，目的地址与JMP指令所在地址不在同一段内。执行该指令时要修改CS和IP的内容，将OPRD所在段的段地址送CS中，OPRD的段内偏移地址送IP中。</p>\n<p>4，段内间转移<br>指令格式：JMP WORD PTR OPRD<br>语法格式：JMP reg16&#x2F;mem ；（IP）&#x3D; 新的偏移地址<br>指令功能：与短程转移的功能和要求相同，不同之处是段内间接转移的OPRD 可以是除立即数外的任何寄存或存储器寻址方式，转移的目标地址由OPRD的内容确定。</p>\n<p>5，段间间接转移<br>指令格式：JMP DWORD PTR OPRD<br>语法格式：JMP mem32<br>指令功能：指令中用DWORD PTR规定了该指令为段间间接转移，OPRD只能是存储器寻址方式。执行该指令时将寻址到的内存单元的第一个字送入IP中，第二个字送入CS中。</p>\n<h3 id=\"条件转移\"><a href=\"#条件转移\" class=\"headerlink\" title=\"条件转移\"></a>条件转移</h3><img src=\"/2022/03/22/OS-Develop-2/jmp_condition.png\" class=\"\" title=\"flag registor\">\n\n<h3 id=\"call-ret\"><a href=\"#call-ret\" class=\"headerlink\" title=\"call &amp; ret\"></a>call &amp; ret</h3><p>在高级语言中，常有主程序调用其他子程序，子程序还可以调用子程序。<br>call指令可以实现调用一个子程序，在子程序里使用ret指令结束子程序的执行并返回主程序（类比C语言中的main函数调用cube函数进行理解），主程序继续往下执行。</p>\n<blockquote><p>mov ax,0<br>call s     ;s是标号，执行call后，执行s标号所在的子程序<br>mov ax,4c00h<br>int 21h</p>\n<p>s:add ax,1   ;标号所在子程序<br>  mov bx,10<br>  ret        ;子程序执行完后，返回主程序</p>\n</blockquote>\n\n<h3 id=\"push-pop\"><a href=\"#push-pop\" class=\"headerlink\" title=\"push &amp; pop\"></a>push &amp; pop</h3><p>push和pop是用来操作栈的2个指令；push将一个寄存器中的数据入栈，pop出栈用一个寄存器接收数据；相关的寄存器<code>SS:SP</code>。<br>举例：<br>mov ax 123H<br>push ax 的执行，由以下两步完成。<br>(1) SP &#x3D; SP - 2, SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；<br>(2) 将ax中的内容送入SS:SP 指向的内存单元处，SS:SP此时指向新栈顶。</p>\n<h3 id=\"int\"><a href=\"#int\" class=\"headerlink\" title=\"int\"></a>int</h3><p>int指令是X86汇编语言中最重要的指令之一。它的作用是引发中断，调用“中断例程”（interrupt routine）</p>\n<p>指令格式：</p>\n<blockquote><p>int n ;n是中端号</p>\n</blockquote>\n\n<p>指令执行过程：</p>\n<blockquote><p>1，取中断类型码n；<br>2，标志寄存器入栈（pushf），IF&#x3D;0，TF&#x3D;0（重置中断标志位）；<br>3，CS、IP入栈；<br>4，查中断向量表， (IP)&#x3D;(n*4)，(CS)&#x3D;(n*4+2)。</p>\n</blockquote>\n\n"},{"title":"OS Develop 1","date":"2022-03-17T05:23:10.000Z","_content":"\n#### 简介\n本章对操作系统开发，涉及的概念做简单讨论，更深入的见后续。\n\n\n### CPU工作方式\nCPU大体分为3部分：控制单元、运算单元和存储单元。\n{% asset_img cpu_workflow.png cpu workflow %}\n\n\n### X86、X64、X86-64、IA-32和IA-64\n- **X86**：这是一种指令集架构家族，最初由英特尔开发。它基于英特尔8086微处理器及其8088变体。8086于1978年推出，作为英特尔8位8080微处理器的完全16位扩展。\n\n- **X64**：这是一个通用术语，指的是x86指令集的64位扩展。它最初由AMD使用，名为AMD64，后来由英特尔实施，名为Intel64。\n\n- **X86-64**：这是x64和AMD64的另一个名称，表示x86指令集的64位扩展。它支持比其前身可能的虚拟内存和物理内存的大量增加，使程序能够在内存中存储更大量的数据。\n\n- **IA-32**：这是x86指令集的一个版本，支持32位计算。它于1985年由英特尔引入，尽管基于30多年前的设计，但它仍然是今天销售的大多数台式机和笔记本电脑的基础。\n\n- **IA-64**：这是一种64位指令集架构，由英特尔开发并于2001年引入，配备了用于企业和高性能计算的Itanium处理器。它与x86架构不向后兼容。\n\n\n### x86寄存器简介\n1，通用寄存器\n通用寄存器可以有多种用途，可以同来保存任何数据；虽说通用，但还是约定了它们的惯用法，比如一般情况下，将cx寄存器用作循环的次数控制，bx用于存储起始地址，这是约定俗成的东西。\n{% asset_img common_registor.png tools shwo %}\n\n2，段寄存器\nx86的段寄存器有6个----CS/DS/ES/SS/FS/GS，均为16位。\nCS：存储代码段的段选择子，代码段保存正在执行的指令。处理器从代码段读取指令时，CS中的段选择子与EIP的值(要执行的下一条指令在代码段中的偏移量)组成逻辑地址。\nDS：数据段寄存器。\nSS：堆栈段寄存器。\nES，FS和GS：给操作系统用的，不用操作系统，用途不一样。\n\n3，状态寄存器\n16位模式下，标志寄存器名称为FLAG，寄存器大小16位。\n32位模式下，标志寄存器的名称为EFLAG，寄存器大小32位。\n64位模式下，为RFLAG，寄存器大小64位。\n\n它的主要作用包括：\n- 存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位\n- 执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。\n- 控制CPU的工作方式，例如IF、VM、TF等标志位。\n\n状态寄存器的各位作用：\n{% asset_img flag_registor.png flag registor %}\n\n\n4，控制寄存器\n控制寄存器决定处理器的操作模式当前执行任务的特性，比如实时模式和保护模式。\n{% asset_img control_registor.jpeg flag registor %}\n\n\n### 内存寻址方式\n分为三大类：\n- 寄存器寻址\n- 立即数寻址\n- 内存寻址\n\n内存寻址用分为：\n- 直接寻址\n- 基址寻址\n- 变址寻址\n- 机址变址寻址\n\n\n### 段寄存器和总线\n数据总线，它的宽度决定数据交换速度。\n控制总线，它的宽度决定可以控制的外设数量。\n地址总线，它决定了内存寻址范围。\n\n段寄存器产生是由于数据总线和地址总线宽度不一致；数据总线宽度，也就是ALU宽度，也是我们常说的16位和32位CPU（也是寄存器的宽度），比如32位的CPU地址总线可以是32位，也可以是36位。\n\n早期，Intel决定让8086访问地址空间为1M，也就是地址总线为20位，但此时数据总线是16位，地址总线宽度大于数据总线，Intel想了一个办法，它加了4个16位的段寄存器(CS,DS,ES,SS)，它们存储的是地址总线高16位的段基址，原来的16地址就变成了段内的偏移量，这样就可以访问到1M内存了。\n\n\n### MMIO和PMIO\n- MMIO\n内存映射方式（并不是映射到主板插的内存条上，是总线访问的内存地址）。\n\n- PMIO\n通过寄存器端口访问。\n\n### 实时模式和保护模式\n- 8086 具有 16 位的段寄存器、指令指针寄存器和通用寄存器（CS、SS、DS、ES、IP、AX、BX、CX、DX、SI、DI、BP、SP），因此，我们称它为 16 位的处理器。尽管它可以访问 1MB 的内存，但是只能分段进行，而且由于只能使用 16 位的段内偏移量，故段的长度最大只能是 64KB。8086 只有一种工作模式，即实模式；当然，这个名称是后来才提出来的。\n\n- 80286 也是一款 16 位的处理器，大部分的寄存器都和 8086 处理器一样。因此，80286 和 8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段；尽管它有 24 根地址线，理论上可以访问 2^24，即 16MB 的内存,但依然只能分成多个段来进行。但是，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16 位保护模式很少为人所知的原因。\n\n- 1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。和 8086/80286 不同，80386 处理器的寄存器是 32 位的，而且拥有 32 根地址线，可以访问 2^32，即 4GB 的内存。80386以及所有后续的 32 位处理器，都兼容实模式，可以运行实模式下的 8086 程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相当于一个非常快速的 8086 处理器。只有在进行一番设置之后，才能运行在保护模式下。在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。32 位保护模式兼容 80286 的 16 位保护模式。\n\n### 实时模式内存布局\n![](/images/real_time_mm.png)\n\n### 虚拟地址空间\n1，虚拟地址空间的大小是怎么决定的\nX86_64体系结构的CPU工作在Long Mode（64位模式）时，虚拟地址的宽度是64位，但是当前的实现都不允许使用2^64字节（16EB）的整个地址空间。在可预见的未来，大多数操作系统和应用程序不需要这么大的地址空间，因此实现如此宽的虚拟地址只会增加地址转换的复杂性和成本，而没有真正的好处。因此，AMD决定在该体系结构的第一个实现中，实际只将虚拟地址的最低有效48位用于地址转换（页表查找）中。\n\n2，小内存如何应对大虚拟地址空间\n物理内存的大小和虚拟地址空间的大小是完全没关系的，虚拟地址空间虽大，但虚拟地址空间的虚拟地址主要用于页表转换，页表能顺利转换的前提是要完成页表填充，页表填充又发生在缺页异常处理中，缺页异常填充页表时首先要向伙伴系统申请内存，而伙伴系统分配的内存都是从物理内存中划分出来的，物理内存的大小决定了它能分配的page数。所以物理内存的大小和虚拟地址空间的大小是没有直接对应关系的。\n\n\n### 全局描述符表（GDT）\n它是由段描述符构成的表。\n段描述符用来描述内存段的属性，它占连续的8个字节。\n{% asset_img gdt.png gdt %}\n\n- G-为0表示“段界限”的单位是字节，为1表示单位为4K。\n- D/B-用来指定段内偏移地址和操作数的大小；对于代码段来说，此位是D，为0表示是16位，为1表示32为；对于栈段来说，此为使B，若为0则使用的是16位的sp寄存器，若为1则使用的32位的esp寄存器。\n- L-为1表示64代码段，为0表示32位代码段。\n- AVL-操作系统可以随意使用，没有具体功能。\n- P-为1表示段存在于内存中（如内存不足时，置换到磁盘），0表示在内存中。\n- DPL-Descriptor Privilege Level，用来表示段的特权级；分别是 0、1、2、3 级特权，数字越小，特权级越大。\n- S和TYPE-S为0表示系统段，为1表示内存段，在S不同值下，用通过TYPE来区分具体的段类型。\n\n\n### 选择子(selector)\n在保护模式下，段寄存器中保存的不再是段基址了，里面保存的内容叫“选择子(selector)”；选择子就像数组下标一样用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组。\n\n\n### A20\n实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以16后再加上段内偏移地址。 实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”访问策略继续可用，CPU采取的做法是将超过1MB的部分自动回绕到0地址。超过1MB多余出来的内存被称为高端内存区HMA。对于只有20位地址线的CPU，不需要任何额外操作便能自动实现地址回绕。\n\nCPU发展到了80286后，虽然地址总线从原来的20位发展到了24位，从而能够访问的内存范围可达到2的24次方，即16MB。但任何时候，Intel都会把兼容放在第一位。80286是第一款具有保护模式的CPU，它在实模式下时，其表现也应该和8086/8088一模一样。按照兼容的要求，80286及后续CPU的实模式应该与8086/8088完全一样，即仍然只使用其中的20条地址线。\n\n在保护模式下，我们要使用80286的24条地址线，如果访问0x100000～0x10FFEF之间的内存，系统将直接访问这块物理内存，并不会像8086/8088那样回绕到 0。 IBM设计了A20Gate来控制是否20位回环。 \n\n如果A20Gate被打开，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存。如果A20 Gate被禁止，当访问0x100000～0x10FFEF之间的地址时，CPU 将采用8086/8088的地址回绕。\n\n### 开启保护模式\n- 配置GDT\n- 打开A20\n- 将CR0的pe置为1\n\n\n### 流水线\n为了提高CPU执行效率，将每一步操作就绪划分成粒度更细的微的操作，然后将这些微操作放到多级流水线上同时去执行。\n\n\n### 开启分页机制\n- 准备好页目录表和页表\n- 将页表地址写入控制寄存器cr3\n- 寄存器cr0的PG位置1\n\n\n### 为啥要多级分页\n每当进程创建时，操作系统都会为进程分配页表，整个操作系统并非只有一个页表。\n在32操作系统中，每个页为4K，每个页表项为4B，虚拟地址空间为4G（2的32次方），那么页表的大小就为4M，当进程创建时，如果单级页表的话，那就要将页表内容全部创建出来，那么每个进程都要4M的页表内存空间，那内存消耗时巨大的。如果是多级页表就可以按需分配。\n\n\n### 操作系统和用户进程\n用户进程必须运行在低特权级，当用户进程访问资源时，需要向操作系统申请，操作系统去操作，然后将结果返回给用户进程，进程可以有无限多个，而操作系统是所有用户进程共享的。可以把操作系统看作服务端，用户进程看作客户端。\n\n\n\n","source":"_posts/OS-Develop-1.md","raw":"---\ntitle: OS Develop 1\ndate: 2022-03-17 13:23:10\ntags:\n   - IT-Basics\n   - OS\n---\n\n#### 简介\n本章对操作系统开发，涉及的概念做简单讨论，更深入的见后续。\n\n\n### CPU工作方式\nCPU大体分为3部分：控制单元、运算单元和存储单元。\n{% asset_img cpu_workflow.png cpu workflow %}\n\n\n### X86、X64、X86-64、IA-32和IA-64\n- **X86**：这是一种指令集架构家族，最初由英特尔开发。它基于英特尔8086微处理器及其8088变体。8086于1978年推出，作为英特尔8位8080微处理器的完全16位扩展。\n\n- **X64**：这是一个通用术语，指的是x86指令集的64位扩展。它最初由AMD使用，名为AMD64，后来由英特尔实施，名为Intel64。\n\n- **X86-64**：这是x64和AMD64的另一个名称，表示x86指令集的64位扩展。它支持比其前身可能的虚拟内存和物理内存的大量增加，使程序能够在内存中存储更大量的数据。\n\n- **IA-32**：这是x86指令集的一个版本，支持32位计算。它于1985年由英特尔引入，尽管基于30多年前的设计，但它仍然是今天销售的大多数台式机和笔记本电脑的基础。\n\n- **IA-64**：这是一种64位指令集架构，由英特尔开发并于2001年引入，配备了用于企业和高性能计算的Itanium处理器。它与x86架构不向后兼容。\n\n\n### x86寄存器简介\n1，通用寄存器\n通用寄存器可以有多种用途，可以同来保存任何数据；虽说通用，但还是约定了它们的惯用法，比如一般情况下，将cx寄存器用作循环的次数控制，bx用于存储起始地址，这是约定俗成的东西。\n{% asset_img common_registor.png tools shwo %}\n\n2，段寄存器\nx86的段寄存器有6个----CS/DS/ES/SS/FS/GS，均为16位。\nCS：存储代码段的段选择子，代码段保存正在执行的指令。处理器从代码段读取指令时，CS中的段选择子与EIP的值(要执行的下一条指令在代码段中的偏移量)组成逻辑地址。\nDS：数据段寄存器。\nSS：堆栈段寄存器。\nES，FS和GS：给操作系统用的，不用操作系统，用途不一样。\n\n3，状态寄存器\n16位模式下，标志寄存器名称为FLAG，寄存器大小16位。\n32位模式下，标志寄存器的名称为EFLAG，寄存器大小32位。\n64位模式下，为RFLAG，寄存器大小64位。\n\n它的主要作用包括：\n- 存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位\n- 执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。\n- 控制CPU的工作方式，例如IF、VM、TF等标志位。\n\n状态寄存器的各位作用：\n{% asset_img flag_registor.png flag registor %}\n\n\n4，控制寄存器\n控制寄存器决定处理器的操作模式当前执行任务的特性，比如实时模式和保护模式。\n{% asset_img control_registor.jpeg flag registor %}\n\n\n### 内存寻址方式\n分为三大类：\n- 寄存器寻址\n- 立即数寻址\n- 内存寻址\n\n内存寻址用分为：\n- 直接寻址\n- 基址寻址\n- 变址寻址\n- 机址变址寻址\n\n\n### 段寄存器和总线\n数据总线，它的宽度决定数据交换速度。\n控制总线，它的宽度决定可以控制的外设数量。\n地址总线，它决定了内存寻址范围。\n\n段寄存器产生是由于数据总线和地址总线宽度不一致；数据总线宽度，也就是ALU宽度，也是我们常说的16位和32位CPU（也是寄存器的宽度），比如32位的CPU地址总线可以是32位，也可以是36位。\n\n早期，Intel决定让8086访问地址空间为1M，也就是地址总线为20位，但此时数据总线是16位，地址总线宽度大于数据总线，Intel想了一个办法，它加了4个16位的段寄存器(CS,DS,ES,SS)，它们存储的是地址总线高16位的段基址，原来的16地址就变成了段内的偏移量，这样就可以访问到1M内存了。\n\n\n### MMIO和PMIO\n- MMIO\n内存映射方式（并不是映射到主板插的内存条上，是总线访问的内存地址）。\n\n- PMIO\n通过寄存器端口访问。\n\n### 实时模式和保护模式\n- 8086 具有 16 位的段寄存器、指令指针寄存器和通用寄存器（CS、SS、DS、ES、IP、AX、BX、CX、DX、SI、DI、BP、SP），因此，我们称它为 16 位的处理器。尽管它可以访问 1MB 的内存，但是只能分段进行，而且由于只能使用 16 位的段内偏移量，故段的长度最大只能是 64KB。8086 只有一种工作模式，即实模式；当然，这个名称是后来才提出来的。\n\n- 80286 也是一款 16 位的处理器，大部分的寄存器都和 8086 处理器一样。因此，80286 和 8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段；尽管它有 24 根地址线，理论上可以访问 2^24，即 16MB 的内存,但依然只能分成多个段来进行。但是，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16 位保护模式很少为人所知的原因。\n\n- 1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。和 8086/80286 不同，80386 处理器的寄存器是 32 位的，而且拥有 32 根地址线，可以访问 2^32，即 4GB 的内存。80386以及所有后续的 32 位处理器，都兼容实模式，可以运行实模式下的 8086 程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相当于一个非常快速的 8086 处理器。只有在进行一番设置之后，才能运行在保护模式下。在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。32 位保护模式兼容 80286 的 16 位保护模式。\n\n### 实时模式内存布局\n![](/images/real_time_mm.png)\n\n### 虚拟地址空间\n1，虚拟地址空间的大小是怎么决定的\nX86_64体系结构的CPU工作在Long Mode（64位模式）时，虚拟地址的宽度是64位，但是当前的实现都不允许使用2^64字节（16EB）的整个地址空间。在可预见的未来，大多数操作系统和应用程序不需要这么大的地址空间，因此实现如此宽的虚拟地址只会增加地址转换的复杂性和成本，而没有真正的好处。因此，AMD决定在该体系结构的第一个实现中，实际只将虚拟地址的最低有效48位用于地址转换（页表查找）中。\n\n2，小内存如何应对大虚拟地址空间\n物理内存的大小和虚拟地址空间的大小是完全没关系的，虚拟地址空间虽大，但虚拟地址空间的虚拟地址主要用于页表转换，页表能顺利转换的前提是要完成页表填充，页表填充又发生在缺页异常处理中，缺页异常填充页表时首先要向伙伴系统申请内存，而伙伴系统分配的内存都是从物理内存中划分出来的，物理内存的大小决定了它能分配的page数。所以物理内存的大小和虚拟地址空间的大小是没有直接对应关系的。\n\n\n### 全局描述符表（GDT）\n它是由段描述符构成的表。\n段描述符用来描述内存段的属性，它占连续的8个字节。\n{% asset_img gdt.png gdt %}\n\n- G-为0表示“段界限”的单位是字节，为1表示单位为4K。\n- D/B-用来指定段内偏移地址和操作数的大小；对于代码段来说，此位是D，为0表示是16位，为1表示32为；对于栈段来说，此为使B，若为0则使用的是16位的sp寄存器，若为1则使用的32位的esp寄存器。\n- L-为1表示64代码段，为0表示32位代码段。\n- AVL-操作系统可以随意使用，没有具体功能。\n- P-为1表示段存在于内存中（如内存不足时，置换到磁盘），0表示在内存中。\n- DPL-Descriptor Privilege Level，用来表示段的特权级；分别是 0、1、2、3 级特权，数字越小，特权级越大。\n- S和TYPE-S为0表示系统段，为1表示内存段，在S不同值下，用通过TYPE来区分具体的段类型。\n\n\n### 选择子(selector)\n在保护模式下，段寄存器中保存的不再是段基址了，里面保存的内容叫“选择子(selector)”；选择子就像数组下标一样用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组。\n\n\n### A20\n实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以16后再加上段内偏移地址。 实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”访问策略继续可用，CPU采取的做法是将超过1MB的部分自动回绕到0地址。超过1MB多余出来的内存被称为高端内存区HMA。对于只有20位地址线的CPU，不需要任何额外操作便能自动实现地址回绕。\n\nCPU发展到了80286后，虽然地址总线从原来的20位发展到了24位，从而能够访问的内存范围可达到2的24次方，即16MB。但任何时候，Intel都会把兼容放在第一位。80286是第一款具有保护模式的CPU，它在实模式下时，其表现也应该和8086/8088一模一样。按照兼容的要求，80286及后续CPU的实模式应该与8086/8088完全一样，即仍然只使用其中的20条地址线。\n\n在保护模式下，我们要使用80286的24条地址线，如果访问0x100000～0x10FFEF之间的内存，系统将直接访问这块物理内存，并不会像8086/8088那样回绕到 0。 IBM设计了A20Gate来控制是否20位回环。 \n\n如果A20Gate被打开，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存。如果A20 Gate被禁止，当访问0x100000～0x10FFEF之间的地址时，CPU 将采用8086/8088的地址回绕。\n\n### 开启保护模式\n- 配置GDT\n- 打开A20\n- 将CR0的pe置为1\n\n\n### 流水线\n为了提高CPU执行效率，将每一步操作就绪划分成粒度更细的微的操作，然后将这些微操作放到多级流水线上同时去执行。\n\n\n### 开启分页机制\n- 准备好页目录表和页表\n- 将页表地址写入控制寄存器cr3\n- 寄存器cr0的PG位置1\n\n\n### 为啥要多级分页\n每当进程创建时，操作系统都会为进程分配页表，整个操作系统并非只有一个页表。\n在32操作系统中，每个页为4K，每个页表项为4B，虚拟地址空间为4G（2的32次方），那么页表的大小就为4M，当进程创建时，如果单级页表的话，那就要将页表内容全部创建出来，那么每个进程都要4M的页表内存空间，那内存消耗时巨大的。如果是多级页表就可以按需分配。\n\n\n### 操作系统和用户进程\n用户进程必须运行在低特权级，当用户进程访问资源时，需要向操作系统申请，操作系统去操作，然后将结果返回给用户进程，进程可以有无限多个，而操作系统是所有用户进程共享的。可以把操作系统看作服务端，用户进程看作客户端。\n\n\n\n","slug":"OS-Develop-1","published":1,"updated":"2024-03-13T13:51:22.581Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjra000mem3ie7hybj3n","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>本章对操作系统开发，涉及的概念做简单讨论，更深入的见后续。</p>\n<h3 id=\"CPU工作方式\"><a href=\"#CPU工作方式\" class=\"headerlink\" title=\"CPU工作方式\"></a>CPU工作方式</h3><p>CPU大体分为3部分：控制单元、运算单元和存储单元。</p>\n<img src=\"/2022/03/17/OS-Develop-1/cpu_workflow.png\" class=\"\" title=\"cpu workflow\">\n\n\n<h3 id=\"X86、X64、X86-64、IA-32和IA-64\"><a href=\"#X86、X64、X86-64、IA-32和IA-64\" class=\"headerlink\" title=\"X86、X64、X86-64、IA-32和IA-64\"></a>X86、X64、X86-64、IA-32和IA-64</h3><ul>\n<li><p><strong>X86</strong>：这是一种指令集架构家族，最初由英特尔开发。它基于英特尔8086微处理器及其8088变体。8086于1978年推出，作为英特尔8位8080微处理器的完全16位扩展。</p>\n</li>\n<li><p><strong>X64</strong>：这是一个通用术语，指的是x86指令集的64位扩展。它最初由AMD使用，名为AMD64，后来由英特尔实施，名为Intel64。</p>\n</li>\n<li><p><strong>X86-64</strong>：这是x64和AMD64的另一个名称，表示x86指令集的64位扩展。它支持比其前身可能的虚拟内存和物理内存的大量增加，使程序能够在内存中存储更大量的数据。</p>\n</li>\n<li><p><strong>IA-32</strong>：这是x86指令集的一个版本，支持32位计算。它于1985年由英特尔引入，尽管基于30多年前的设计，但它仍然是今天销售的大多数台式机和笔记本电脑的基础。</p>\n</li>\n<li><p><strong>IA-64</strong>：这是一种64位指令集架构，由英特尔开发并于2001年引入，配备了用于企业和高性能计算的Itanium处理器。它与x86架构不向后兼容。</p>\n</li>\n</ul>\n<h3 id=\"x86寄存器简介\"><a href=\"#x86寄存器简介\" class=\"headerlink\" title=\"x86寄存器简介\"></a>x86寄存器简介</h3><p>1，通用寄存器<br>通用寄存器可以有多种用途，可以同来保存任何数据；虽说通用，但还是约定了它们的惯用法，比如一般情况下，将cx寄存器用作循环的次数控制，bx用于存储起始地址，这是约定俗成的东西。</p>\n<img src=\"/2022/03/17/OS-Develop-1/common_registor.png\" class=\"\" title=\"tools shwo\">\n\n<p>2，段寄存器<br>x86的段寄存器有6个—-CS&#x2F;DS&#x2F;ES&#x2F;SS&#x2F;FS&#x2F;GS，均为16位。<br>CS：存储代码段的段选择子，代码段保存正在执行的指令。处理器从代码段读取指令时，CS中的段选择子与EIP的值(要执行的下一条指令在代码段中的偏移量)组成逻辑地址。<br>DS：数据段寄存器。<br>SS：堆栈段寄存器。<br>ES，FS和GS：给操作系统用的，不用操作系统，用途不一样。</p>\n<p>3，状态寄存器<br>16位模式下，标志寄存器名称为FLAG，寄存器大小16位。<br>32位模式下，标志寄存器的名称为EFLAG，寄存器大小32位。<br>64位模式下，为RFLAG，寄存器大小64位。</p>\n<p>它的主要作用包括：</p>\n<ul>\n<li>存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位</li>\n<li>执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。</li>\n<li>控制CPU的工作方式，例如IF、VM、TF等标志位。</li>\n</ul>\n<p>状态寄存器的各位作用：</p>\n<img src=\"/2022/03/17/OS-Develop-1/flag_registor.png\" class=\"\" title=\"flag registor\">\n\n\n<p>4，控制寄存器<br>控制寄存器决定处理器的操作模式当前执行任务的特性，比如实时模式和保护模式。</p>\n<img src=\"/2022/03/17/OS-Develop-1/control_registor.jpeg\" class=\"\" title=\"flag registor\">\n\n\n<h3 id=\"内存寻址方式\"><a href=\"#内存寻址方式\" class=\"headerlink\" title=\"内存寻址方式\"></a>内存寻址方式</h3><p>分为三大类：</p>\n<ul>\n<li>寄存器寻址</li>\n<li>立即数寻址</li>\n<li>内存寻址</li>\n</ul>\n<p>内存寻址用分为：</p>\n<ul>\n<li>直接寻址</li>\n<li>基址寻址</li>\n<li>变址寻址</li>\n<li>机址变址寻址</li>\n</ul>\n<h3 id=\"段寄存器和总线\"><a href=\"#段寄存器和总线\" class=\"headerlink\" title=\"段寄存器和总线\"></a>段寄存器和总线</h3><p>数据总线，它的宽度决定数据交换速度。<br>控制总线，它的宽度决定可以控制的外设数量。<br>地址总线，它决定了内存寻址范围。</p>\n<p>段寄存器产生是由于数据总线和地址总线宽度不一致；数据总线宽度，也就是ALU宽度，也是我们常说的16位和32位CPU（也是寄存器的宽度），比如32位的CPU地址总线可以是32位，也可以是36位。</p>\n<p>早期，Intel决定让8086访问地址空间为1M，也就是地址总线为20位，但此时数据总线是16位，地址总线宽度大于数据总线，Intel想了一个办法，它加了4个16位的段寄存器(CS,DS,ES,SS)，它们存储的是地址总线高16位的段基址，原来的16地址就变成了段内的偏移量，这样就可以访问到1M内存了。</p>\n<h3 id=\"MMIO和PMIO\"><a href=\"#MMIO和PMIO\" class=\"headerlink\" title=\"MMIO和PMIO\"></a>MMIO和PMIO</h3><ul>\n<li><p>MMIO<br>内存映射方式（并不是映射到主板插的内存条上，是总线访问的内存地址）。</p>\n</li>\n<li><p>PMIO<br>通过寄存器端口访问。</p>\n</li>\n</ul>\n<h3 id=\"实时模式和保护模式\"><a href=\"#实时模式和保护模式\" class=\"headerlink\" title=\"实时模式和保护模式\"></a>实时模式和保护模式</h3><ul>\n<li><p>8086 具有 16 位的段寄存器、指令指针寄存器和通用寄存器（CS、SS、DS、ES、IP、AX、BX、CX、DX、SI、DI、BP、SP），因此，我们称它为 16 位的处理器。尽管它可以访问 1MB 的内存，但是只能分段进行，而且由于只能使用 16 位的段内偏移量，故段的长度最大只能是 64KB。8086 只有一种工作模式，即实模式；当然，这个名称是后来才提出来的。</p>\n</li>\n<li><p>80286 也是一款 16 位的处理器，大部分的寄存器都和 8086 处理器一样。因此，80286 和 8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段；尽管它有 24 根地址线，理论上可以访问 2^24，即 16MB 的内存,但依然只能分成多个段来进行。但是，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16 位保护模式很少为人所知的原因。</p>\n</li>\n<li><p>1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。和 8086&#x2F;80286 不同，80386 处理器的寄存器是 32 位的，而且拥有 32 根地址线，可以访问 2^32，即 4GB 的内存。80386以及所有后续的 32 位处理器，都兼容实模式，可以运行实模式下的 8086 程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相当于一个非常快速的 8086 处理器。只有在进行一番设置之后，才能运行在保护模式下。在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。32 位保护模式兼容 80286 的 16 位保护模式。</p>\n</li>\n</ul>\n<h3 id=\"实时模式内存布局\"><a href=\"#实时模式内存布局\" class=\"headerlink\" title=\"实时模式内存布局\"></a>实时模式内存布局</h3><p><img src=\"/images/real_time_mm.png\"></p>\n<h3 id=\"虚拟地址空间\"><a href=\"#虚拟地址空间\" class=\"headerlink\" title=\"虚拟地址空间\"></a>虚拟地址空间</h3><p>1，虚拟地址空间的大小是怎么决定的<br>X86_64体系结构的CPU工作在Long Mode（64位模式）时，虚拟地址的宽度是64位，但是当前的实现都不允许使用2^64字节（16EB）的整个地址空间。在可预见的未来，大多数操作系统和应用程序不需要这么大的地址空间，因此实现如此宽的虚拟地址只会增加地址转换的复杂性和成本，而没有真正的好处。因此，AMD决定在该体系结构的第一个实现中，实际只将虚拟地址的最低有效48位用于地址转换（页表查找）中。</p>\n<p>2，小内存如何应对大虚拟地址空间<br>物理内存的大小和虚拟地址空间的大小是完全没关系的，虚拟地址空间虽大，但虚拟地址空间的虚拟地址主要用于页表转换，页表能顺利转换的前提是要完成页表填充，页表填充又发生在缺页异常处理中，缺页异常填充页表时首先要向伙伴系统申请内存，而伙伴系统分配的内存都是从物理内存中划分出来的，物理内存的大小决定了它能分配的page数。所以物理内存的大小和虚拟地址空间的大小是没有直接对应关系的。</p>\n<h3 id=\"全局描述符表（GDT）\"><a href=\"#全局描述符表（GDT）\" class=\"headerlink\" title=\"全局描述符表（GDT）\"></a>全局描述符表（GDT）</h3><p>它是由段描述符构成的表。<br>段描述符用来描述内存段的属性，它占连续的8个字节。</p>\n<img src=\"/2022/03/17/OS-Develop-1/gdt.png\" class=\"\" title=\"gdt\">\n\n<ul>\n<li>G-为0表示“段界限”的单位是字节，为1表示单位为4K。</li>\n<li>D&#x2F;B-用来指定段内偏移地址和操作数的大小；对于代码段来说，此位是D，为0表示是16位，为1表示32为；对于栈段来说，此为使B，若为0则使用的是16位的sp寄存器，若为1则使用的32位的esp寄存器。</li>\n<li>L-为1表示64代码段，为0表示32位代码段。</li>\n<li>AVL-操作系统可以随意使用，没有具体功能。</li>\n<li>P-为1表示段存在于内存中（如内存不足时，置换到磁盘），0表示在内存中。</li>\n<li>DPL-Descriptor Privilege Level，用来表示段的特权级；分别是 0、1、2、3 级特权，数字越小，特权级越大。</li>\n<li>S和TYPE-S为0表示系统段，为1表示内存段，在S不同值下，用通过TYPE来区分具体的段类型。</li>\n</ul>\n<h3 id=\"选择子-selector\"><a href=\"#选择子-selector\" class=\"headerlink\" title=\"选择子(selector)\"></a>选择子(selector)</h3><p>在保护模式下，段寄存器中保存的不再是段基址了，里面保存的内容叫“选择子(selector)”；选择子就像数组下标一样用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组。</p>\n<h3 id=\"A20\"><a href=\"#A20\" class=\"headerlink\" title=\"A20\"></a>A20</h3><p>实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以16后再加上段内偏移地址。 实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”访问策略继续可用，CPU采取的做法是将超过1MB的部分自动回绕到0地址。超过1MB多余出来的内存被称为高端内存区HMA。对于只有20位地址线的CPU，不需要任何额外操作便能自动实现地址回绕。</p>\n<p>CPU发展到了80286后，虽然地址总线从原来的20位发展到了24位，从而能够访问的内存范围可达到2的24次方，即16MB。但任何时候，Intel都会把兼容放在第一位。80286是第一款具有保护模式的CPU，它在实模式下时，其表现也应该和8086&#x2F;8088一模一样。按照兼容的要求，80286及后续CPU的实模式应该与8086&#x2F;8088完全一样，即仍然只使用其中的20条地址线。</p>\n<p>在保护模式下，我们要使用80286的24条地址线，如果访问0x100000～0x10FFEF之间的内存，系统将直接访问这块物理内存，并不会像8086&#x2F;8088那样回绕到 0。 IBM设计了A20Gate来控制是否20位回环。 </p>\n<p>如果A20Gate被打开，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存。如果A20 Gate被禁止，当访问0x100000～0x10FFEF之间的地址时，CPU 将采用8086&#x2F;8088的地址回绕。</p>\n<h3 id=\"开启保护模式\"><a href=\"#开启保护模式\" class=\"headerlink\" title=\"开启保护模式\"></a>开启保护模式</h3><ul>\n<li>配置GDT</li>\n<li>打开A20</li>\n<li>将CR0的pe置为1</li>\n</ul>\n<h3 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h3><p>为了提高CPU执行效率，将每一步操作就绪划分成粒度更细的微的操作，然后将这些微操作放到多级流水线上同时去执行。</p>\n<h3 id=\"开启分页机制\"><a href=\"#开启分页机制\" class=\"headerlink\" title=\"开启分页机制\"></a>开启分页机制</h3><ul>\n<li>准备好页目录表和页表</li>\n<li>将页表地址写入控制寄存器cr3</li>\n<li>寄存器cr0的PG位置1</li>\n</ul>\n<h3 id=\"为啥要多级分页\"><a href=\"#为啥要多级分页\" class=\"headerlink\" title=\"为啥要多级分页\"></a>为啥要多级分页</h3><p>每当进程创建时，操作系统都会为进程分配页表，整个操作系统并非只有一个页表。<br>在32操作系统中，每个页为4K，每个页表项为4B，虚拟地址空间为4G（2的32次方），那么页表的大小就为4M，当进程创建时，如果单级页表的话，那就要将页表内容全部创建出来，那么每个进程都要4M的页表内存空间，那内存消耗时巨大的。如果是多级页表就可以按需分配。</p>\n<h3 id=\"操作系统和用户进程\"><a href=\"#操作系统和用户进程\" class=\"headerlink\" title=\"操作系统和用户进程\"></a>操作系统和用户进程</h3><p>用户进程必须运行在低特权级，当用户进程访问资源时，需要向操作系统申请，操作系统去操作，然后将结果返回给用户进程，进程可以有无限多个，而操作系统是所有用户进程共享的。可以把操作系统看作服务端，用户进程看作客户端。</p>\n","excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>本章对操作系统开发，涉及的概念做简单讨论，更深入的见后续。</p>\n<h3 id=\"CPU工作方式\"><a href=\"#CPU工作方式\" class=\"headerlink\" title=\"CPU工作方式\"></a>CPU工作方式</h3><p>CPU大体分为3部分：控制单元、运算单元和存储单元。</p>\n<img src=\"/2022/03/17/OS-Develop-1/cpu_workflow.png\" class=\"\" title=\"cpu workflow\">\n\n\n<h3 id=\"X86、X64、X86-64、IA-32和IA-64\"><a href=\"#X86、X64、X86-64、IA-32和IA-64\" class=\"headerlink\" title=\"X86、X64、X86-64、IA-32和IA-64\"></a>X86、X64、X86-64、IA-32和IA-64</h3><ul>\n<li><p><strong>X86</strong>：这是一种指令集架构家族，最初由英特尔开发。它基于英特尔8086微处理器及其8088变体。8086于1978年推出，作为英特尔8位8080微处理器的完全16位扩展。</p>\n</li>\n<li><p><strong>X64</strong>：这是一个通用术语，指的是x86指令集的64位扩展。它最初由AMD使用，名为AMD64，后来由英特尔实施，名为Intel64。</p>\n</li>\n<li><p><strong>X86-64</strong>：这是x64和AMD64的另一个名称，表示x86指令集的64位扩展。它支持比其前身可能的虚拟内存和物理内存的大量增加，使程序能够在内存中存储更大量的数据。</p>\n</li>\n<li><p><strong>IA-32</strong>：这是x86指令集的一个版本，支持32位计算。它于1985年由英特尔引入，尽管基于30多年前的设计，但它仍然是今天销售的大多数台式机和笔记本电脑的基础。</p>\n</li>\n<li><p><strong>IA-64</strong>：这是一种64位指令集架构，由英特尔开发并于2001年引入，配备了用于企业和高性能计算的Itanium处理器。它与x86架构不向后兼容。</p>\n</li>\n</ul>\n<h3 id=\"x86寄存器简介\"><a href=\"#x86寄存器简介\" class=\"headerlink\" title=\"x86寄存器简介\"></a>x86寄存器简介</h3><p>1，通用寄存器<br>通用寄存器可以有多种用途，可以同来保存任何数据；虽说通用，但还是约定了它们的惯用法，比如一般情况下，将cx寄存器用作循环的次数控制，bx用于存储起始地址，这是约定俗成的东西。</p>\n<img src=\"/2022/03/17/OS-Develop-1/common_registor.png\" class=\"\" title=\"tools shwo\">\n\n<p>2，段寄存器<br>x86的段寄存器有6个—-CS&#x2F;DS&#x2F;ES&#x2F;SS&#x2F;FS&#x2F;GS，均为16位。<br>CS：存储代码段的段选择子，代码段保存正在执行的指令。处理器从代码段读取指令时，CS中的段选择子与EIP的值(要执行的下一条指令在代码段中的偏移量)组成逻辑地址。<br>DS：数据段寄存器。<br>SS：堆栈段寄存器。<br>ES，FS和GS：给操作系统用的，不用操作系统，用途不一样。</p>\n<p>3，状态寄存器<br>16位模式下，标志寄存器名称为FLAG，寄存器大小16位。<br>32位模式下，标志寄存器的名称为EFLAG，寄存器大小32位。<br>64位模式下，为RFLAG，寄存器大小64位。</p>\n<p>它的主要作用包括：</p>\n<ul>\n<li>存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位</li>\n<li>执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。</li>\n<li>控制CPU的工作方式，例如IF、VM、TF等标志位。</li>\n</ul>\n<p>状态寄存器的各位作用：</p>\n<img src=\"/2022/03/17/OS-Develop-1/flag_registor.png\" class=\"\" title=\"flag registor\">\n\n\n<p>4，控制寄存器<br>控制寄存器决定处理器的操作模式当前执行任务的特性，比如实时模式和保护模式。</p>\n<img src=\"/2022/03/17/OS-Develop-1/control_registor.jpeg\" class=\"\" title=\"flag registor\">\n\n\n<h3 id=\"内存寻址方式\"><a href=\"#内存寻址方式\" class=\"headerlink\" title=\"内存寻址方式\"></a>内存寻址方式</h3><p>分为三大类：</p>\n<ul>\n<li>寄存器寻址</li>\n<li>立即数寻址</li>\n<li>内存寻址</li>\n</ul>\n<p>内存寻址用分为：</p>\n<ul>\n<li>直接寻址</li>\n<li>基址寻址</li>\n<li>变址寻址</li>\n<li>机址变址寻址</li>\n</ul>\n<h3 id=\"段寄存器和总线\"><a href=\"#段寄存器和总线\" class=\"headerlink\" title=\"段寄存器和总线\"></a>段寄存器和总线</h3><p>数据总线，它的宽度决定数据交换速度。<br>控制总线，它的宽度决定可以控制的外设数量。<br>地址总线，它决定了内存寻址范围。</p>\n<p>段寄存器产生是由于数据总线和地址总线宽度不一致；数据总线宽度，也就是ALU宽度，也是我们常说的16位和32位CPU（也是寄存器的宽度），比如32位的CPU地址总线可以是32位，也可以是36位。</p>\n<p>早期，Intel决定让8086访问地址空间为1M，也就是地址总线为20位，但此时数据总线是16位，地址总线宽度大于数据总线，Intel想了一个办法，它加了4个16位的段寄存器(CS,DS,ES,SS)，它们存储的是地址总线高16位的段基址，原来的16地址就变成了段内的偏移量，这样就可以访问到1M内存了。</p>\n<h3 id=\"MMIO和PMIO\"><a href=\"#MMIO和PMIO\" class=\"headerlink\" title=\"MMIO和PMIO\"></a>MMIO和PMIO</h3><ul>\n<li><p>MMIO<br>内存映射方式（并不是映射到主板插的内存条上，是总线访问的内存地址）。</p>\n</li>\n<li><p>PMIO<br>通过寄存器端口访问。</p>\n</li>\n</ul>\n<h3 id=\"实时模式和保护模式\"><a href=\"#实时模式和保护模式\" class=\"headerlink\" title=\"实时模式和保护模式\"></a>实时模式和保护模式</h3><ul>\n<li><p>8086 具有 16 位的段寄存器、指令指针寄存器和通用寄存器（CS、SS、DS、ES、IP、AX、BX、CX、DX、SI、DI、BP、SP），因此，我们称它为 16 位的处理器。尽管它可以访问 1MB 的内存，但是只能分段进行，而且由于只能使用 16 位的段内偏移量，故段的长度最大只能是 64KB。8086 只有一种工作模式，即实模式；当然，这个名称是后来才提出来的。</p>\n</li>\n<li><p>80286 也是一款 16 位的处理器，大部分的寄存器都和 8086 处理器一样。因此，80286 和 8086 一样，因为段寄存器是 16 位的，而且只能使用 16 位的偏移地址，在实模式下只能使用 64KB 的段；尽管它有 24 根地址线，理论上可以访问 2^24，即 16MB 的内存,但依然只能分成多个段来进行。但是，80286 和 8086 不一样的地方在于，它第一次提出了保护模式的概念。在保护模式下，段寄存器中保存的不再是段地址，而是段选择子，真正的段地址位于段寄存器的描述符高速缓存中，是 24 位的。因此，运行在保护模式下的 80286 处理器可以访问全部 16MB 内存。由于 80286 的通用寄存器是 16 位的，只能提供 16 位的偏移地址，因此，和 8086 一样，即使是运行在保护模式下，段的长度依然不能超过 64KB。对段长度的限制妨碍了 80286 处理器的应用，这就是 16 位保护模式很少为人所知的原因。</p>\n</li>\n<li><p>1985 年的 80386 处理器是 Intel 公司的第一款 32 位产品，而且获得了极大成功，是后续所有 32 位产品的基础。和 8086&#x2F;80286 不同，80386 处理器的寄存器是 32 位的，而且拥有 32 根地址线，可以访问 2^32，即 4GB 的内存。80386以及所有后续的 32 位处理器，都兼容实模式，可以运行实模式下的 8086 程序。而且，在刚加电时，这些处理器都自动处于实模式下，此时，它相当于一个非常快速的 8086 处理器。只有在进行一番设置之后，才能运行在保护模式下。在保护模式下，所有的 32 位处理器都可以访问多达 4GB 的内存，它们可以工作在分段模型下，每个段的基地址是 32 位的，段内偏移量也是 32 位的，因此，段的长度不受限制。在最典型的情况下，可以将整个 4GB 内存定义成一个段来处理，这就是所谓的平坦模式。在平坦模式下，可以执行 4GB 范围内的控制转移，也可以使用 32 位的偏移量访问任何 4GB 范围内的任何位置。32 位保护模式兼容 80286 的 16 位保护模式。</p>\n</li>\n</ul>\n<h3 id=\"实时模式内存布局\"><a href=\"#实时模式内存布局\" class=\"headerlink\" title=\"实时模式内存布局\"></a>实时模式内存布局</h3><p><img src=\"/images/real_time_mm.png\"></p>\n<h3 id=\"虚拟地址空间\"><a href=\"#虚拟地址空间\" class=\"headerlink\" title=\"虚拟地址空间\"></a>虚拟地址空间</h3><p>1，虚拟地址空间的大小是怎么决定的<br>X86_64体系结构的CPU工作在Long Mode（64位模式）时，虚拟地址的宽度是64位，但是当前的实现都不允许使用2^64字节（16EB）的整个地址空间。在可预见的未来，大多数操作系统和应用程序不需要这么大的地址空间，因此实现如此宽的虚拟地址只会增加地址转换的复杂性和成本，而没有真正的好处。因此，AMD决定在该体系结构的第一个实现中，实际只将虚拟地址的最低有效48位用于地址转换（页表查找）中。</p>\n<p>2，小内存如何应对大虚拟地址空间<br>物理内存的大小和虚拟地址空间的大小是完全没关系的，虚拟地址空间虽大，但虚拟地址空间的虚拟地址主要用于页表转换，页表能顺利转换的前提是要完成页表填充，页表填充又发生在缺页异常处理中，缺页异常填充页表时首先要向伙伴系统申请内存，而伙伴系统分配的内存都是从物理内存中划分出来的，物理内存的大小决定了它能分配的page数。所以物理内存的大小和虚拟地址空间的大小是没有直接对应关系的。</p>\n<h3 id=\"全局描述符表（GDT）\"><a href=\"#全局描述符表（GDT）\" class=\"headerlink\" title=\"全局描述符表（GDT）\"></a>全局描述符表（GDT）</h3><p>它是由段描述符构成的表。<br>段描述符用来描述内存段的属性，它占连续的8个字节。</p>\n<img src=\"/2022/03/17/OS-Develop-1/gdt.png\" class=\"\" title=\"gdt\">\n\n<ul>\n<li>G-为0表示“段界限”的单位是字节，为1表示单位为4K。</li>\n<li>D&#x2F;B-用来指定段内偏移地址和操作数的大小；对于代码段来说，此位是D，为0表示是16位，为1表示32为；对于栈段来说，此为使B，若为0则使用的是16位的sp寄存器，若为1则使用的32位的esp寄存器。</li>\n<li>L-为1表示64代码段，为0表示32位代码段。</li>\n<li>AVL-操作系统可以随意使用，没有具体功能。</li>\n<li>P-为1表示段存在于内存中（如内存不足时，置换到磁盘），0表示在内存中。</li>\n<li>DPL-Descriptor Privilege Level，用来表示段的特权级；分别是 0、1、2、3 级特权，数字越小，特权级越大。</li>\n<li>S和TYPE-S为0表示系统段，为1表示内存段，在S不同值下，用通过TYPE来区分具体的段类型。</li>\n</ul>\n<h3 id=\"选择子-selector\"><a href=\"#选择子-selector\" class=\"headerlink\" title=\"选择子(selector)\"></a>选择子(selector)</h3><p>在保护模式下，段寄存器中保存的不再是段基址了，里面保存的内容叫“选择子(selector)”；选择子就像数组下标一样用这个数来索引全局描述符表中的段描述符，把全局描述符表当成数组。</p>\n<h3 id=\"A20\"><a href=\"#A20\" class=\"headerlink\" title=\"A20\"></a>A20</h3><p>实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以16后再加上段内偏移地址。 实模式下寄存器都是16位的，如果段基址和段内偏移地址都为16位的最大值，即0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，即0x10FFEF。由于实模式下的地址线是20位，最大寻址空间是1MB，即0x00000～0xFFFFF。超出1MB内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”访问策略继续可用，CPU采取的做法是将超过1MB的部分自动回绕到0地址。超过1MB多余出来的内存被称为高端内存区HMA。对于只有20位地址线的CPU，不需要任何额外操作便能自动实现地址回绕。</p>\n<p>CPU发展到了80286后，虽然地址总线从原来的20位发展到了24位，从而能够访问的内存范围可达到2的24次方，即16MB。但任何时候，Intel都会把兼容放在第一位。80286是第一款具有保护模式的CPU，它在实模式下时，其表现也应该和8086&#x2F;8088一模一样。按照兼容的要求，80286及后续CPU的实模式应该与8086&#x2F;8088完全一样，即仍然只使用其中的20条地址线。</p>\n<p>在保护模式下，我们要使用80286的24条地址线，如果访问0x100000～0x10FFEF之间的内存，系统将直接访问这块物理内存，并不会像8086&#x2F;8088那样回绕到 0。 IBM设计了A20Gate来控制是否20位回环。 </p>\n<p>如果A20Gate被打开，当访问到0x100000～0x10FFEF之间的地址时，CPU将真正访问这块物理内存。如果A20 Gate被禁止，当访问0x100000～0x10FFEF之间的地址时，CPU 将采用8086&#x2F;8088的地址回绕。</p>\n<h3 id=\"开启保护模式\"><a href=\"#开启保护模式\" class=\"headerlink\" title=\"开启保护模式\"></a>开启保护模式</h3><ul>\n<li>配置GDT</li>\n<li>打开A20</li>\n<li>将CR0的pe置为1</li>\n</ul>\n<h3 id=\"流水线\"><a href=\"#流水线\" class=\"headerlink\" title=\"流水线\"></a>流水线</h3><p>为了提高CPU执行效率，将每一步操作就绪划分成粒度更细的微的操作，然后将这些微操作放到多级流水线上同时去执行。</p>\n<h3 id=\"开启分页机制\"><a href=\"#开启分页机制\" class=\"headerlink\" title=\"开启分页机制\"></a>开启分页机制</h3><ul>\n<li>准备好页目录表和页表</li>\n<li>将页表地址写入控制寄存器cr3</li>\n<li>寄存器cr0的PG位置1</li>\n</ul>\n<h3 id=\"为啥要多级分页\"><a href=\"#为啥要多级分页\" class=\"headerlink\" title=\"为啥要多级分页\"></a>为啥要多级分页</h3><p>每当进程创建时，操作系统都会为进程分配页表，整个操作系统并非只有一个页表。<br>在32操作系统中，每个页为4K，每个页表项为4B，虚拟地址空间为4G（2的32次方），那么页表的大小就为4M，当进程创建时，如果单级页表的话，那就要将页表内容全部创建出来，那么每个进程都要4M的页表内存空间，那内存消耗时巨大的。如果是多级页表就可以按需分配。</p>\n<h3 id=\"操作系统和用户进程\"><a href=\"#操作系统和用户进程\" class=\"headerlink\" title=\"操作系统和用户进程\"></a>操作系统和用户进程</h3><p>用户进程必须运行在低特权级，当用户进程访问资源时，需要向操作系统申请，操作系统去操作，然后将结果返回给用户进程，进程可以有无限多个，而操作系统是所有用户进程共享的。可以把操作系统看作服务端，用户进程看作客户端。</p>\n"},{"title":"Markdown Tutorial","date":"2022-02-03T14:04:15.000Z","_content":"\n### 标题语法\n要创建标题，在单词或短语前面添加井号 (\\#)，后面一个空格，然后加上标题。\\#的数量代表了标题的级别。(例如：\\#\\#\\# My Header)。\n\n### 段落\n要创建段落，请使用空白行将一行或多行文本进行分隔。\n\n### 换行\n在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。\n\n### 粗体\n要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。\n\n### 斜体\n要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。\n\n### 粗体和斜体\n要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。\n\n### 引用\n要创建块引用，请在段落前添加一个 \\>符号。\n块引用可以包含多个段落。为段落之间的空白行添加一个 \\> 符号。\n\n块引用可以嵌套。在要嵌套的段落前添加一个 \\>\\> 符号。\n\n\n### 列表\n1，有序列表\n要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n2，无序列表\n要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n3，嵌套\n要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。\n\n### 代码\n要将单词或短语表示为代码，请将其包裹在反引号 (\\`) 中。\n\n\n### 分割线\n要创建分隔线，请在单独一行上使用三个或多个星号 (\\*\\*\\*)、破折号 (\\-\\-\\-) 或下划线 (\\_\\_\\_) ，并且不能包含其他内容。\n\n\n### 链接\n链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：\\[超链接显示名\\](超链接地址 \"超链接title\")\n\n\n### 图片\n插入图片Markdown语法代码：\\!\\[图片alt\\](图片链接 \"图片title\")。\n\n\n### 转义字符\n显示原本用于格式化Markdown文档的字符（比如\\*等），可以在字符前面添加反斜杠字符 \\ 。\n\n\n### 内嵌html标签\n对于Markdown涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是HTML或是Markdown，只需将HTML标签添加到Markdown文本中即可。\n出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Markdown-Tutorial.md","raw":"---\ntitle: Markdown Tutorial\ndate: 2022-02-3 22:04:15\ntags: Tool\n---\n\n### 标题语法\n要创建标题，在单词或短语前面添加井号 (\\#)，后面一个空格，然后加上标题。\\#的数量代表了标题的级别。(例如：\\#\\#\\# My Header)。\n\n### 段落\n要创建段落，请使用空白行将一行或多行文本进行分隔。\n\n### 换行\n在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。\n\n### 粗体\n要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。\n\n### 斜体\n要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。\n\n### 粗体和斜体\n要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。\n\n### 引用\n要创建块引用，请在段落前添加一个 \\>符号。\n块引用可以包含多个段落。为段落之间的空白行添加一个 \\> 符号。\n\n块引用可以嵌套。在要嵌套的段落前添加一个 \\>\\> 符号。\n\n\n### 列表\n1，有序列表\n要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\n2，无序列表\n要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n3，嵌套\n要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。\n\n### 代码\n要将单词或短语表示为代码，请将其包裹在反引号 (\\`) 中。\n\n\n### 分割线\n要创建分隔线，请在单独一行上使用三个或多个星号 (\\*\\*\\*)、破折号 (\\-\\-\\-) 或下划线 (\\_\\_\\_) ，并且不能包含其他内容。\n\n\n### 链接\n链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：\\[超链接显示名\\](超链接地址 \"超链接title\")\n\n\n### 图片\n插入图片Markdown语法代码：\\!\\[图片alt\\](图片链接 \"图片title\")。\n\n\n### 转义字符\n显示原本用于格式化Markdown文档的字符（比如\\*等），可以在字符前面添加反斜杠字符 \\ 。\n\n\n### 内嵌html标签\n对于Markdown涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是HTML或是Markdown，只需将HTML标签添加到Markdown文本中即可。\n出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Markdown-Tutorial","published":1,"updated":"2024-03-13T13:51:22.578Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjrc000pem3ig5qm1pup","content":"<h3 id=\"标题语法\"><a href=\"#标题语法\" class=\"headerlink\" title=\"标题语法\"></a>标题语法</h3><p>要创建标题，在单词或短语前面添加井号 (#)，后面一个空格，然后加上标题。#的数量代表了标题的级别。(例如：### My Header)。</p>\n<h3 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h3><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p>\n<h3 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h3><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。</p>\n<h3 id=\"粗体\"><a href=\"#粗体\" class=\"headerlink\" title=\"粗体\"></a>粗体</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。</p>\n<h3 id=\"斜体\"><a href=\"#斜体\" class=\"headerlink\" title=\"斜体\"></a>斜体</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。</p>\n<h3 id=\"粗体和斜体\"><a href=\"#粗体和斜体\" class=\"headerlink\" title=\"粗体和斜体\"></a>粗体和斜体</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>要创建块引用，请在段落前添加一个 &gt;符号。<br>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。</p>\n<p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>1，有序列表<br>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。<br>2，无序列表<br>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。<br>3，嵌套<br>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。</p>\n<h3 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h3><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。</p>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。<br>超链接Markdown语法代码：[超链接显示名](超链接地址 “超链接title”)</p>\n<h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p>插入图片Markdown语法代码：![图片alt](图片链接 “图片title”)。</p>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>显示原本用于格式化Markdown文档的字符（比如*等），可以在字符前面添加反斜杠字符 \\ 。</p>\n<h3 id=\"内嵌html标签\"><a href=\"#内嵌html标签\" class=\"headerlink\" title=\"内嵌html标签\"></a>内嵌html标签</h3><p>对于Markdown涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是HTML或是Markdown，只需将HTML标签添加到Markdown文本中即可。<br>出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。</p>\n","excerpt":"","more":"<h3 id=\"标题语法\"><a href=\"#标题语法\" class=\"headerlink\" title=\"标题语法\"></a>标题语法</h3><p>要创建标题，在单词或短语前面添加井号 (#)，后面一个空格，然后加上标题。#的数量代表了标题的级别。(例如：### My Header)。</p>\n<h3 id=\"段落\"><a href=\"#段落\" class=\"headerlink\" title=\"段落\"></a>段落</h3><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p>\n<h3 id=\"换行\"><a href=\"#换行\" class=\"headerlink\" title=\"换行\"></a>换行</h3><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行。</p>\n<h3 id=\"粗体\"><a href=\"#粗体\" class=\"headerlink\" title=\"粗体\"></a>粗体</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。</p>\n<h3 id=\"斜体\"><a href=\"#斜体\" class=\"headerlink\" title=\"斜体\"></a>斜体</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。</p>\n<h3 id=\"粗体和斜体\"><a href=\"#粗体和斜体\" class=\"headerlink\" title=\"粗体和斜体\"></a>粗体和斜体</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。</p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>要创建块引用，请在段落前添加一个 &gt;符号。<br>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。</p>\n<p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>1，有序列表<br>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。<br>2，无序列表<br>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。<br>3，嵌套<br>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。</p>\n<h3 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h3><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。</p>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。<br>超链接Markdown语法代码：[超链接显示名](超链接地址 “超链接title”)</p>\n<h3 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h3><p>插入图片Markdown语法代码：![图片alt](图片链接 “图片title”)。</p>\n<h3 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h3><p>显示原本用于格式化Markdown文档的字符（比如*等），可以在字符前面添加反斜杠字符 \\ 。</p>\n<h3 id=\"内嵌html标签\"><a href=\"#内嵌html标签\" class=\"headerlink\" title=\"内嵌html标签\"></a>内嵌html标签</h3><p>对于Markdown涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是HTML或是Markdown，只需将HTML标签添加到Markdown文本中即可。<br>出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。</p>\n"},{"title":"OS Develop 3","date":"2022-03-28T10:20:09.000Z","_content":"\n### 简介\n本章讨论BIOS：Base Input & Output System，基本输入输出系统。(顺带点DOS)\n\n### 开始\nBIOS是计算机上第一个运行的软件，它存放在只读存储器ROM上。开机后，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0，此地址便是BIOS的入口地址，BIOS是在实模式下运行的。\n\n### BIOS和DOS\n\n系统板的ROM中存放着一套程序，称为BIOS基本输入输出系统。BIOS最主要功能是基于中断向量表，创建中断例程，中断例程提供了对硬件访问的方法。BIOS中主要包含几下部分内容：\n- 硬件系统的检测和初始化程序；  \n- 外部中断(后面讲解)和内部中断的中断例程；  \n- 用于对硬件设备进行 I/O操作的中断例程；  \n- 其他和硬件系统相关的中断例程.\n- 交接给MBR\n\n操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供了中断例程中包含了许多子程序，这些子程序实现了程序员在编程时经常需要用到的功能。程序员在编程时，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。\n\n### BIOS和外设\nBIOS中断例程访问外设，依赖外设ROM上的初始化代码和功能调用接口。访问方式有两种：\n- MMIO\n在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种IO方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存。因此，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。\n\n- PMIO\n在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节(例如：outb, outw, outl)从/到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。\n\n\n### 中断\n中断指令(in)，中断号，中断向量表，中断例程(处理程序)。\n中断向量表是CPU硬件原生支持的；中断例程是BIOS，DOS等创建的。\n\n\n### BIOS内存位置\n![](/images/real_time_mm.png)\n\n### 结束\nBIOS最后一项工作是校验启动盘中0盘0道1扇区的内容，如果扇区最后分别是0x55和0xaa，BIOS则认为此扇区中存在MBR可执行程序，然后会将此扇区中的内容加载到物理地址0x7c00处，大小为512字节，随后跳转到给地址，执行该处的程序。","source":"_posts/OS-Develop-3.md","raw":"---\ntitle: OS Develop 3\ndate: 2022-03-28 18:20:09\ntags:\n   - IT-Basics\n   - OS\n---\n\n### 简介\n本章讨论BIOS：Base Input & Output System，基本输入输出系统。(顺带点DOS)\n\n### 开始\nBIOS是计算机上第一个运行的软件，它存放在只读存储器ROM上。开机后，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0，此地址便是BIOS的入口地址，BIOS是在实模式下运行的。\n\n### BIOS和DOS\n\n系统板的ROM中存放着一套程序，称为BIOS基本输入输出系统。BIOS最主要功能是基于中断向量表，创建中断例程，中断例程提供了对硬件访问的方法。BIOS中主要包含几下部分内容：\n- 硬件系统的检测和初始化程序；  \n- 外部中断(后面讲解)和内部中断的中断例程；  \n- 用于对硬件设备进行 I/O操作的中断例程；  \n- 其他和硬件系统相关的中断例程.\n- 交接给MBR\n\n操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供了中断例程中包含了许多子程序，这些子程序实现了程序员在编程时经常需要用到的功能。程序员在编程时，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。\n\n### BIOS和外设\nBIOS中断例程访问外设，依赖外设ROM上的初始化代码和功能调用接口。访问方式有两种：\n- MMIO\n在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种IO方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存。因此，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。\n\n- PMIO\n在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节(例如：outb, outw, outl)从/到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。\n\n\n### 中断\n中断指令(in)，中断号，中断向量表，中断例程(处理程序)。\n中断向量表是CPU硬件原生支持的；中断例程是BIOS，DOS等创建的。\n\n\n### BIOS内存位置\n![](/images/real_time_mm.png)\n\n### 结束\nBIOS最后一项工作是校验启动盘中0盘0道1扇区的内容，如果扇区最后分别是0x55和0xaa，BIOS则认为此扇区中存在MBR可执行程序，然后会将此扇区中的内容加载到物理地址0x7c00处，大小为512字节，随后跳转到给地址，执行该处的程序。","slug":"OS-Develop-3","published":1,"updated":"2024-03-13T13:51:22.593Z","comments":1,"layout":"post","photos":[],"_id":"cltpwvjri001hem3if1ahfg0p","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本章讨论BIOS：Base Input &amp; Output System，基本输入输出系统。(顺带点DOS)</p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>BIOS是计算机上第一个运行的软件，它存放在只读存储器ROM上。开机后，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0，此地址便是BIOS的入口地址，BIOS是在实模式下运行的。</p>\n<h3 id=\"BIOS和DOS\"><a href=\"#BIOS和DOS\" class=\"headerlink\" title=\"BIOS和DOS\"></a>BIOS和DOS</h3><p>系统板的ROM中存放着一套程序，称为BIOS基本输入输出系统。BIOS最主要功能是基于中断向量表，创建中断例程，中断例程提供了对硬件访问的方法。BIOS中主要包含几下部分内容：</p>\n<ul>\n<li>硬件系统的检测和初始化程序；  </li>\n<li>外部中断(后面讲解)和内部中断的中断例程；  </li>\n<li>用于对硬件设备进行 I&#x2F;O操作的中断例程；  </li>\n<li>其他和硬件系统相关的中断例程.</li>\n<li>交接给MBR</li>\n</ul>\n<p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供了中断例程中包含了许多子程序，这些子程序实现了程序员在编程时经常需要用到的功能。程序员在编程时，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p>\n<h3 id=\"BIOS和外设\"><a href=\"#BIOS和外设\" class=\"headerlink\" title=\"BIOS和外设\"></a>BIOS和外设</h3><p>BIOS中断例程访问外设，依赖外设ROM上的初始化代码和功能调用接口。访问方式有两种：</p>\n<ul>\n<li><p>MMIO<br>在MMIO中，内存和I&#x2F;O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种IO方法，它使用相同的地址总线来处理内存和I&#x2F;O设备，I&#x2F;O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I&#x2F;O设备的内存。因此，用于访问内存的CPU指令也可来访问I&#x2F;O设备。每个I&#x2F;O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I&#x2F;O设备，CPU必须预留给I&#x2F;O一个地址区域，该地址区域不能给物理内存使用。</p>\n</li>\n<li><p>PMIO<br>在PMIO中，内存和I&#x2F;O设备有各自的地址空间。 端口映射I&#x2F;O通常使用一种特殊的CPU指令，专门执行I&#x2F;O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读&#x2F;写1,2,4个字节(例如：outb, outw, outl)从&#x2F;到IO设备上。I&#x2F;O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I&#x2F;O引脚，要么增加一条专用的I&#x2F;O总线。由于I&#x2F;O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I&#x2F;O)。</p>\n</li>\n</ul>\n<h3 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h3><p>中断指令(in)，中断号，中断向量表，中断例程(处理程序)。<br>中断向量表是CPU硬件原生支持的；中断例程是BIOS，DOS等创建的。</p>\n<h3 id=\"BIOS内存位置\"><a href=\"#BIOS内存位置\" class=\"headerlink\" title=\"BIOS内存位置\"></a>BIOS内存位置</h3><p><img src=\"/images/real_time_mm.png\"></p>\n<h3 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h3><p>BIOS最后一项工作是校验启动盘中0盘0道1扇区的内容，如果扇区最后分别是0x55和0xaa，BIOS则认为此扇区中存在MBR可执行程序，然后会将此扇区中的内容加载到物理地址0x7c00处，大小为512字节，随后跳转到给地址，执行该处的程序。</p>\n","excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>本章讨论BIOS：Base Input &amp; Output System，基本输入输出系统。(顺带点DOS)</p>\n<h3 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h3><p>BIOS是计算机上第一个运行的软件，它存放在只读存储器ROM上。开机后，CPU的cs:ip寄存器被强制初始化为0xF000:0xFFF0，此地址便是BIOS的入口地址，BIOS是在实模式下运行的。</p>\n<h3 id=\"BIOS和DOS\"><a href=\"#BIOS和DOS\" class=\"headerlink\" title=\"BIOS和DOS\"></a>BIOS和DOS</h3><p>系统板的ROM中存放着一套程序，称为BIOS基本输入输出系统。BIOS最主要功能是基于中断向量表，创建中断例程，中断例程提供了对硬件访问的方法。BIOS中主要包含几下部分内容：</p>\n<ul>\n<li>硬件系统的检测和初始化程序；  </li>\n<li>外部中断(后面讲解)和内部中断的中断例程；  </li>\n<li>用于对硬件设备进行 I&#x2F;O操作的中断例程；  </li>\n<li>其他和硬件系统相关的中断例程.</li>\n<li>交接给MBR</li>\n</ul>\n<p>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。BIOS和DOS在所提供了中断例程中包含了许多子程序，这些子程序实现了程序员在编程时经常需要用到的功能。程序员在编程时，可以用int指令直接调用BIOS和DOS提供的中断例程，来完成某些工作和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p>\n<h3 id=\"BIOS和外设\"><a href=\"#BIOS和外设\" class=\"headerlink\" title=\"BIOS和外设\"></a>BIOS和外设</h3><p>BIOS中断例程访问外设，依赖外设ROM上的初始化代码和功能调用接口。访问方式有两种：</p>\n<ul>\n<li><p>MMIO<br>在MMIO中，内存和I&#x2F;O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种IO方法，它使用相同的地址总线来处理内存和I&#x2F;O设备，I&#x2F;O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I&#x2F;O设备的内存。因此，用于访问内存的CPU指令也可来访问I&#x2F;O设备。每个I&#x2F;O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I&#x2F;O设备，CPU必须预留给I&#x2F;O一个地址区域，该地址区域不能给物理内存使用。</p>\n</li>\n<li><p>PMIO<br>在PMIO中，内存和I&#x2F;O设备有各自的地址空间。 端口映射I&#x2F;O通常使用一种特殊的CPU指令，专门执行I&#x2F;O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读&#x2F;写1,2,4个字节(例如：outb, outw, outl)从&#x2F;到IO设备上。I&#x2F;O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I&#x2F;O引脚，要么增加一条专用的I&#x2F;O总线。由于I&#x2F;O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I&#x2F;O)。</p>\n</li>\n</ul>\n<h3 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h3><p>中断指令(in)，中断号，中断向量表，中断例程(处理程序)。<br>中断向量表是CPU硬件原生支持的；中断例程是BIOS，DOS等创建的。</p>\n<h3 id=\"BIOS内存位置\"><a href=\"#BIOS内存位置\" class=\"headerlink\" title=\"BIOS内存位置\"></a>BIOS内存位置</h3><p><img src=\"/images/real_time_mm.png\"></p>\n<h3 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h3><p>BIOS最后一项工作是校验启动盘中0盘0道1扇区的内容，如果扇区最后分别是0x55和0xaa，BIOS则认为此扇区中存在MBR可执行程序，然后会将此扇区中的内容加载到物理地址0x7c00处，大小为512字节，随后跳转到给地址，执行该处的程序。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Algorithm-1/bubble_sort.gif","slug":"bubble_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/bucket_sort.gif","slug":"bucket_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/count_sort.gif","slug":"count_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/heap_sort.gif","slug":"heap_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/insertion_sort.gif","slug":"insertion_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/merge_sort.gif","slug":"merge_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/quick_sort.gif","slug":"quick_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/radix_sort.gif","slug":"radix_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/selection_sort.gif","slug":"selection_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/shell_sort.gif","slug":"shell_sort.gif","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Algorithm-1/sort_algorithm.png","slug":"sort_algorithm.png","post":"cltpwvjqw0001em3i8lt30i6e","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-1/hash_table_link_addr.png","slug":"hash_table_link_addr.png","post":"cltpwvjr5000bem3i18mu4nqk","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-1/struct_array.png","slug":"struct_array.png","post":"cltpwvjr5000bem3i18mu4nqk","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-1/struct_double_queue.png","slug":"struct_double_queue.png","post":"cltpwvjr5000bem3i18mu4nqk","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-1/struct_hash_imp.png","slug":"struct_hash_imp.png","post":"cltpwvjr5000bem3i18mu4nqk","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-1/struct_hash_table.png","slug":"struct_hash_table.png","post":"cltpwvjr5000bem3i18mu4nqk","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-1/struct_link_list.png","slug":"struct_link_list.png","post":"cltpwvjr5000bem3i18mu4nqk","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-1/struct_queue.png","slug":"struct_queue.png","post":"cltpwvjr5000bem3i18mu4nqk","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-1/struct_stack.png","slug":"struct_stack.png","post":"cltpwvjr5000bem3i18mu4nqk","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-2/complete_binary_tree.png","slug":"complete_binary_tree.png","post":"cltpwvjr6000cem3ie1od8azl","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-2/struct_full_binary_tree.png","slug":"struct_full_binary_tree.png","post":"cltpwvjr6000cem3ie1od8azl","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-2/struct_tree.png","slug":"struct_tree.png","post":"cltpwvjr6000cem3ie1od8azl","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-3/struct_directed_graphs.png","slug":"struct_directed_graphs.png","post":"cltpwvjr7000fem3i8idgbltc","modified":0,"renderable":0},{"_id":"source/_posts/Data-Struct-3/struct_undirected_graphs.png","slug":"struct_undirected_graphs.png","post":"cltpwvjr7000fem3i8idgbltc","modified":0,"renderable":0},{"_id":"source/_posts/My-Desktop-tools/adb_tool.png","slug":"adb_tool.png","post":"cltpwvjr9000hem3if3qg4nrt","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-2/jmp_condition.png","slug":"jmp_condition.png","post":"cltpwvjra000kem3ih4vfbu2p","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/common_registor.png","slug":"common_registor.png","post":"cltpwvjra000mem3ie7hybj3n","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/control_registor.jpeg","slug":"control_registor.jpeg","post":"cltpwvjra000mem3ie7hybj3n","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/cpu_workflow.png","slug":"cpu_workflow.png","post":"cltpwvjra000mem3ie7hybj3n","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/flag_registor.png","slug":"flag_registor.png","post":"cltpwvjra000mem3ie7hybj3n","modified":0,"renderable":0},{"_id":"source/_posts/OS-Develop-1/gdt.png","slug":"gdt.png","post":"cltpwvjra000mem3ie7hybj3n","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cltpwvjqr0000em3i1lob7hts","tag_id":"cltpwvjqy0002em3i10aicrj3","_id":"cltpwvjr30007em3igbsq3m75"},{"post_id":"cltpwvjr5000bem3i18mu4nqk","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjr6000eem3i1zk8dt5k"},{"post_id":"cltpwvjr5000bem3i18mu4nqk","tag_id":"cltpwvjr5000aem3if0kx3uw5","_id":"cltpwvjr8000gem3igq9186mn"},{"post_id":"cltpwvjqw0001em3i8lt30i6e","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjra000jem3ib1rqamxv"},{"post_id":"cltpwvjqw0001em3i8lt30i6e","tag_id":"cltpwvjr5000aem3if0kx3uw5","_id":"cltpwvjra000lem3i88h96tzu"},{"post_id":"cltpwvjr6000cem3ie1od8azl","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjrb000oem3iaacsawvz"},{"post_id":"cltpwvjr6000cem3ie1od8azl","tag_id":"cltpwvjr5000aem3if0kx3uw5","_id":"cltpwvjrc000qem3i5zptb3q7"},{"post_id":"cltpwvjr7000fem3i8idgbltc","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjrc000sem3i96ddbzmo"},{"post_id":"cltpwvjr7000fem3i8idgbltc","tag_id":"cltpwvjr5000aem3if0kx3uw5","_id":"cltpwvjrd000tem3ihc8fh93h"},{"post_id":"cltpwvjr00003em3i0p2eeja4","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjrd000vem3i4sx87t2a"},{"post_id":"cltpwvjr00003em3i0p2eeja4","tag_id":"cltpwvjr5000aem3if0kx3uw5","_id":"cltpwvjrd000wem3i30ov9o02"},{"post_id":"cltpwvjr10004em3i468z9ae3","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjrd000yem3i3m471bre"},{"post_id":"cltpwvjr10004em3i468z9ae3","tag_id":"cltpwvjr5000aem3if0kx3uw5","_id":"cltpwvjrd000zem3idsng1heh"},{"post_id":"cltpwvjr20005em3ic6di34eo","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjre0011em3i18du8eij"},{"post_id":"cltpwvjr20005em3ic6di34eo","tag_id":"cltpwvjr5000aem3if0kx3uw5","_id":"cltpwvjre0012em3i51lzei13"},{"post_id":"cltpwvjr30008em3i9t0f87m5","tag_id":"cltpwvjrd0010em3i2ogw9xjw","_id":"cltpwvjre0014em3iespggz1h"},{"post_id":"cltpwvjr30008em3i9t0f87m5","tag_id":"cltpwvjqy0002em3i10aicrj3","_id":"cltpwvjre0015em3igczqfl1w"},{"post_id":"cltpwvjr40009em3ieawb2eny","tag_id":"cltpwvjre0013em3i3xam21bg","_id":"cltpwvjre0017em3ienf95m57"},{"post_id":"cltpwvjr9000hem3if3qg4nrt","tag_id":"cltpwvjre0016em3i5iga0t37","_id":"cltpwvjrf0019em3i8285bwvp"},{"post_id":"cltpwvjra000kem3ih4vfbu2p","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjrf001bem3i5h6aeeox"},{"post_id":"cltpwvjra000kem3ih4vfbu2p","tag_id":"cltpwvjrf0018em3i5e6se3ey","_id":"cltpwvjrf001cem3i7kx5e0vl"},{"post_id":"cltpwvjra000mem3ie7hybj3n","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjrf001eem3i00trg33k"},{"post_id":"cltpwvjra000mem3ie7hybj3n","tag_id":"cltpwvjrf0018em3i5e6se3ey","_id":"cltpwvjrf001fem3i4btf8vwz"},{"post_id":"cltpwvjrc000pem3ig5qm1pup","tag_id":"cltpwvjre0016em3i5iga0t37","_id":"cltpwvjrf001gem3iai7e6lgx"},{"post_id":"cltpwvjri001hem3if1ahfg0p","tag_id":"cltpwvjr20006em3icb0b2jsc","_id":"cltpwvjri001iem3ieazh0s7k"},{"post_id":"cltpwvjri001hem3if1ahfg0p","tag_id":"cltpwvjrf0018em3i5e6se3ey","_id":"cltpwvjri001jem3i4qnq5wjd"}],"Tag":[{"name":"Android","_id":"cltpwvjqy0002em3i10aicrj3"},{"name":"IT-Basics","_id":"cltpwvjr20006em3icb0b2jsc"},{"name":"Algorithm","_id":"cltpwvjr5000aem3if0kx3uw5"},{"name":"Blockchain","_id":"cltpwvjrd0010em3i2ogw9xjw"},{"name":"Backend","_id":"cltpwvjre0013em3i3xam21bg"},{"name":"Tool","_id":"cltpwvjre0016em3i5iga0t37"},{"name":"OS","_id":"cltpwvjrf0018em3i5e6se3ey"}]}}